"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[9085],{3961:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CO: () => (/* binding */ getPaddingFromTooltipModel),\n/* harmony export */   Qx: () => (/* binding */ createTooltipMarkup),\n/* harmony export */   Yu: () => (/* binding */ buildTooltipMarkup),\n/* harmony export */   aw: () => (/* binding */ retrieveVisualColorForTooltipMarker),\n/* harmony export */   lb: () => (/* binding */ TooltipMarkupStyleCreator)\n/* harmony export */ });\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29687);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(83412);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31825);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(24326);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1';\nfunction getTooltipLineHeight(textStyle) {\n  var lineHeight = textStyle.lineHeight;\n  if (lineHeight == null) {\n    return TOOLTIP_LINE_HEIGHT_CSS;\n  } else {\n    return \"line-height:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(lineHeight + '') + \"px\";\n  }\n}\n// TODO: more textStyle option\nfunction getTooltipTextStyle(textStyle, renderMode) {\n  var nameFontColor = textStyle.color || '#6e7079';\n  var nameFontSize = textStyle.fontSize || 12;\n  var nameFontWeight = textStyle.fontWeight || '400';\n  var valueFontColor = textStyle.color || '#464646';\n  var valueFontSize = textStyle.fontSize || 14;\n  var valueFontWeight = textStyle.fontWeight || '900';\n  if (renderMode === 'html') {\n    // `textStyle` is probably from user input, should be encoded to reduce security risk.\n    return {\n      // eslint-disable-next-line max-len\n      nameStyle: \"font-size:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(nameFontSize + '') + \"px;color:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(nameFontColor) + \";font-weight:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(nameFontWeight + ''),\n      // eslint-disable-next-line max-len\n      valueStyle: \"font-size:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(valueFontSize + '') + \"px;color:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(valueFontColor) + \";font-weight:\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(valueFontWeight + '')\n    };\n  } else {\n    return {\n      nameStyle: {\n        fontSize: nameFontSize,\n        fill: nameFontColor,\n        fontWeight: nameFontWeight\n      },\n      valueStyle: {\n        fontSize: valueFontSize,\n        fill: valueFontColor,\n        fontWeight: valueFontWeight\n      }\n    };\n  }\n}\n// See `TooltipMarkupLayoutIntent['innerGapLevel']`.\n// (value from UI design)\nvar HTML_GAPS = [0, 10, 20, 30];\nvar RICH_TEXT_GAPS = ['', '\\n', '\\n\\n', '\\n\\n\\n'];\n// eslint-disable-next-line max-len\nfunction createTooltipMarkup(type, option) {\n  option.type = type;\n  return option;\n}\nfunction isSectionFragment(frag) {\n  return frag.type === 'section';\n}\nfunction getBuilder(frag) {\n  return isSectionFragment(frag) ? buildSection : buildNameValue;\n}\nfunction getBlockGapLevel(frag) {\n  if (isSectionFragment(frag)) {\n    var gapLevel_1 = 0;\n    var subBlockLen = frag.blocks.length;\n    var hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader;\n    (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(frag.blocks, function (subBlock) {\n      var subGapLevel = getBlockGapLevel(subBlock);\n      // If the some of the sub-blocks have some gaps (like 10px) inside, this block\n      // should use a larger gap (like 20px) to distinguish those sub-blocks.\n      if (subGapLevel >= gapLevel_1) {\n        gapLevel_1 = subGapLevel + +(hasInnerGap_1 && (\n        // 0 always can not be readable gap level.\n        !subGapLevel\n        // If no header, always keep the sub gap level. Otherwise\n        // look weird in case `multipleSeries`.\n        || isSectionFragment(subBlock) && !subBlock.noHeader));\n      }\n    });\n    return gapLevel_1;\n  }\n  return 0;\n}\nfunction buildSection(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {\n  var noHeader = fragment.noHeader;\n  var gaps = getGap(getBlockGapLevel(fragment));\n  var subMarkupTextList = [];\n  var subBlocks = fragment.blocks || [];\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.assert)(!subBlocks || (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(subBlocks));\n  subBlocks = subBlocks || [];\n  var orderMode = ctx.orderMode;\n  if (fragment.sortBlocks && orderMode) {\n    subBlocks = subBlocks.slice();\n    var orderMap = {\n      valueAsc: 'asc',\n      valueDesc: 'desc'\n    };\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.hasOwn)(orderMap, orderMode)) {\n      var comparator_1 = new _data_helper_dataValueHelper_js__WEBPACK_IMPORTED_MODULE_2__/* .SortOrderComparator */ .Fl(orderMap[orderMode], null);\n      subBlocks.sort(function (a, b) {\n        return comparator_1.evaluate(a.sortParam, b.sortParam);\n      });\n    }\n    // FIXME 'seriesDesc' necessary?\n    else if (orderMode === 'seriesDesc') {\n      subBlocks.reverse();\n    }\n  }\n  (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(subBlocks, function (subBlock, idx) {\n    var valueFormatter = fragment.valueFormatter;\n    var subMarkupText = getBuilder(subBlock)(\n    // Inherit valueFormatter\n    valueFormatter ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)({}, ctx), {\n      valueFormatter: valueFormatter\n    }) : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle);\n    subMarkupText != null && subMarkupTextList.push(subMarkupText);\n  });\n  var subMarkupText = ctx.renderMode === 'richText' ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(toolTipTextStyle, subMarkupTextList.join(''), noHeader ? topMarginForOuterGap : gaps.html);\n  if (noHeader) {\n    return subMarkupText;\n  }\n  var displayableHeader = (0,_util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .makeValueReadable */ .yC)(fragment.header, 'ordinal', ctx.useUTC);\n  var nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle;\n  var tooltipLineHeight = getTooltipLineHeight(toolTipTextStyle);\n  if (ctx.renderMode === 'richText') {\n    return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText;\n  } else {\n    return wrapBlockHTML(toolTipTextStyle, \"<div style=\\\"\" + nameStyle + \";\" + tooltipLineHeight + \";\\\">\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(displayableHeader) + '</div>' + subMarkupText, topMarginForOuterGap);\n  }\n}\nfunction buildNameValue(ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {\n  var renderMode = ctx.renderMode;\n  var noName = fragment.noName;\n  var noValue = fragment.noValue;\n  var noMarker = !fragment.markerType;\n  var name = fragment.name;\n  var useUTC = ctx.useUTC;\n  var valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function (value) {\n    value = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(value) ? value : [value];\n    return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(value, function (val, idx) {\n      return (0,_util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .makeValueReadable */ .yC)(val, (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC);\n    });\n  };\n  if (noName && noValue) {\n    return;\n  }\n  var markerStr = noMarker ? '' : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || '#333', renderMode);\n  var readableName = noName ? '' : (0,_util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .makeValueReadable */ .yC)(name, 'ordinal', useUTC);\n  var valueTypeOption = fragment.valueType;\n  var readableValueList = noValue ? [] : valueFormatter(fragment.value, fragment.dataIndex);\n  var valueAlignRight = !noMarker || !noName;\n  // It little weird if only value next to marker but far from marker.\n  var valueCloseToMarker = !noMarker && noName;\n  var _a = getTooltipTextStyle(toolTipTextStyle, renderMode),\n    nameStyle = _a.nameStyle,\n    valueStyle = _a.valueStyle;\n  return renderMode === 'richText' ? (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameRichText(ctx, readableName, nameStyle))\n  // Value has commas inside, so use ' ' as delimiter for multiple values.\n  + (noValue ? '' : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML(toolTipTextStyle, (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? '' : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap);\n}\n/**\r\n * @return markupText. null/undefined means no content.\r\n */\nfunction buildTooltipMarkup(fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {\n  if (!fragment) {\n    return;\n  }\n  var builder = getBuilder(fragment);\n  var ctx = {\n    useUTC: useUTC,\n    renderMode: renderMode,\n    orderMode: orderMode,\n    markupStyleCreator: markupStyleCreator,\n    valueFormatter: fragment.valueFormatter\n  };\n  return builder(ctx, fragment, 0, toolTipTextStyle);\n}\nfunction getGap(gapLevel) {\n  return {\n    html: HTML_GAPS[gapLevel],\n    richText: RICH_TEXT_GAPS[gapLevel]\n  };\n}\nfunction wrapBlockHTML(textStyle, encodedContent, topGap) {\n  var clearfix = '<div style=\"clear:both\"></div>';\n  var marginCSS = \"margin: \" + topGap + \"px 0 0\";\n  var tooltipLineHeight = getTooltipLineHeight(textStyle);\n  return \"<div style=\\\"\" + marginCSS + \";\" + tooltipLineHeight + \";\\\">\" + encodedContent + clearfix + '</div>';\n}\nfunction wrapInlineNameHTML(name, leftHasMarker, style) {\n  var marginCss = leftHasMarker ? 'margin-left:2px' : '';\n  return \"<span style=\\\"\" + style + \";\" + marginCss + \"\\\">\" + (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(name) + '</span>';\n}\nfunction wrapInlineValueHTML(valueList, alignRight, valueCloseToMarker, style) {\n  // Do not too close to marker, considering there are multiple values separated by spaces.\n  var paddingStr = valueCloseToMarker ? '10px' : '20px';\n  var alignCSS = alignRight ? \"float:right;margin-left:\" + paddingStr : '';\n  valueList = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(valueList) ? valueList : [valueList];\n  return \"<span style=\\\"\" + alignCSS + \";\" + style + \"\\\">\"\n  // Value has commas inside, so use '  ' as delimiter for multiple values.\n  + (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.map)(valueList, function (value) {\n    return (0,_util_format_js__WEBPACK_IMPORTED_MODULE_0__/* .encodeHTML */ .Me)(value);\n  }).join('&nbsp;&nbsp;') + '</span>';\n}\nfunction wrapInlineNameRichText(ctx, name, style) {\n  return ctx.markupStyleCreator.wrapRichTextStyle(name, style);\n}\nfunction wrapInlineValueRichText(ctx, values, alignRight, valueCloseToMarker, style) {\n  var styles = [style];\n  var paddingLeft = valueCloseToMarker ? 10 : 20;\n  alignRight && styles.push({\n    padding: [0, 0, 0, paddingLeft],\n    align: 'right'\n  });\n  // Value has commas inside, so use '  ' as delimiter for multiple values.\n  return ctx.markupStyleCreator.wrapRichTextStyle((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(values) ? values.join('  ') : values, styles);\n}\nfunction retrieveVisualColorForTooltipMarker(series, dataIndex) {\n  var style = series.getData().getItemVisual(dataIndex, 'style');\n  var color = style[series.visualDrawType];\n  return (0,_util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .convertToColorString */ .he)(color);\n}\nfunction getPaddingFromTooltipModel(model, renderMode) {\n  var padding = model.get('padding');\n  return padding != null ? padding\n  // We give slightly different to look pretty.\n  : renderMode === 'richText' ? [8, 10] : 10;\n}\n/**\r\n * The major feature is generate styles for `renderMode: 'richText'`.\r\n * But it also serves `renderMode: 'html'` to provide\r\n * \"renderMode-independent\" API.\r\n */\nvar TooltipMarkupStyleCreator = /** @class */function () {\n  function TooltipMarkupStyleCreator() {\n    this.richTextStyles = {};\n    // Notice that \"generate a style name\" usually happens repeatedly when mouse is moving and\n    // a tooltip is displayed. So we put the `_nextStyleNameId` as a member of each creator\n    // rather than static shared by all creators (which will cause it increase to fast).\n    this._nextStyleNameId = (0,_util_number_js__WEBPACK_IMPORTED_MODULE_4__/* .getRandomIdBase */ .IH)();\n  }\n  TooltipMarkupStyleCreator.prototype._generateStyleName = function () {\n    return '__EC_aUTo_' + this._nextStyleNameId++;\n  };\n  TooltipMarkupStyleCreator.prototype.makeTooltipMarker = function (markerType, colorStr, renderMode) {\n    var markerId = renderMode === 'richText' ? this._generateStyleName() : null;\n    var marker = (0,_util_format_js__WEBPACK_IMPORTED_MODULE_3__/* .getTooltipMarker */ .qg)({\n      color: colorStr,\n      type: markerType,\n      renderMode: renderMode,\n      markerId: markerId\n    });\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString)(marker)) {\n      return marker;\n    } else {\n      if (false) {}\n      this.richTextStyles[markerId] = marker.style;\n      return marker.content;\n    }\n  };\n  /**\r\n   * @usage\r\n   * ```ts\r\n   * const styledText = markupStyleCreator.wrapRichTextStyle([\r\n   *     // The styles will be auto merged.\r\n   *     {\r\n   *         fontSize: 12,\r\n   *         color: 'blue'\r\n   *     },\r\n   *     {\r\n   *         padding: 20\r\n   *     }\r\n   * ]);\r\n   * ```\r\n   */\n  TooltipMarkupStyleCreator.prototype.wrapRichTextStyle = function (text, styles) {\n    var finalStl = {};\n    if ((0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray)(styles)) {\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each)(styles, function (stl) {\n        return (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(finalStl, stl);\n      });\n    } else {\n      (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.extend)(finalStl, styles);\n    }\n    var styleName = this._generateStyleName();\n    this.richTextStyles[styleName] = finalStl;\n    return \"{\" + styleName + \"|\" + text + \"}\";\n  };\n  return TooltipMarkupStyleCreator;\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk2MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC90b29sdGlwTWFya3VwLmpzPzc4MDQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBnZXRUb29sdGlwTWFya2VyLCBlbmNvZGVIVE1MLCBtYWtlVmFsdWVSZWFkYWJsZSwgY29udmVydFRvQ29sb3JTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgeyBpc1N0cmluZywgZWFjaCwgaGFzT3duLCBpc0FycmF5LCBtYXAsIGFzc2VydCwgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFNvcnRPcmRlckNvbXBhcmF0b3IgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhVmFsdWVIZWxwZXIuanMnO1xuaW1wb3J0IHsgZ2V0UmFuZG9tSWRCYXNlIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xudmFyIFRPT0xUSVBfTElORV9IRUlHSFRfQ1NTID0gJ2xpbmUtaGVpZ2h0OjEnO1xuZnVuY3Rpb24gZ2V0VG9vbHRpcExpbmVIZWlnaHQodGV4dFN0eWxlKSB7XG4gIHZhciBsaW5lSGVpZ2h0ID0gdGV4dFN0eWxlLmxpbmVIZWlnaHQ7XG4gIGlmIChsaW5lSGVpZ2h0ID09IG51bGwpIHtcbiAgICByZXR1cm4gVE9PTFRJUF9MSU5FX0hFSUdIVF9DU1M7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwibGluZS1oZWlnaHQ6XCIgKyBlbmNvZGVIVE1MKGxpbmVIZWlnaHQgKyAnJykgKyBcInB4XCI7XG4gIH1cbn1cbi8vIFRPRE86IG1vcmUgdGV4dFN0eWxlIG9wdGlvblxuZnVuY3Rpb24gZ2V0VG9vbHRpcFRleHRTdHlsZSh0ZXh0U3R5bGUsIHJlbmRlck1vZGUpIHtcbiAgdmFyIG5hbWVGb250Q29sb3IgPSB0ZXh0U3R5bGUuY29sb3IgfHwgJyM2ZTcwNzknO1xuICB2YXIgbmFtZUZvbnRTaXplID0gdGV4dFN0eWxlLmZvbnRTaXplIHx8IDEyO1xuICB2YXIgbmFtZUZvbnRXZWlnaHQgPSB0ZXh0U3R5bGUuZm9udFdlaWdodCB8fCAnNDAwJztcbiAgdmFyIHZhbHVlRm9udENvbG9yID0gdGV4dFN0eWxlLmNvbG9yIHx8ICcjNDY0NjQ2JztcbiAgdmFyIHZhbHVlRm9udFNpemUgPSB0ZXh0U3R5bGUuZm9udFNpemUgfHwgMTQ7XG4gIHZhciB2YWx1ZUZvbnRXZWlnaHQgPSB0ZXh0U3R5bGUuZm9udFdlaWdodCB8fCAnOTAwJztcbiAgaWYgKHJlbmRlck1vZGUgPT09ICdodG1sJykge1xuICAgIC8vIGB0ZXh0U3R5bGVgIGlzIHByb2JhYmx5IGZyb20gdXNlciBpbnB1dCwgc2hvdWxkIGJlIGVuY29kZWQgdG8gcmVkdWNlIHNlY3VyaXR5IHJpc2suXG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICBuYW1lU3R5bGU6IFwiZm9udC1zaXplOlwiICsgZW5jb2RlSFRNTChuYW1lRm9udFNpemUgKyAnJykgKyBcInB4O2NvbG9yOlwiICsgZW5jb2RlSFRNTChuYW1lRm9udENvbG9yKSArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZW5jb2RlSFRNTChuYW1lRm9udFdlaWdodCArICcnKSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gICAgICB2YWx1ZVN0eWxlOiBcImZvbnQtc2l6ZTpcIiArIGVuY29kZUhUTUwodmFsdWVGb250U2l6ZSArICcnKSArIFwicHg7Y29sb3I6XCIgKyBlbmNvZGVIVE1MKHZhbHVlRm9udENvbG9yKSArIFwiO2ZvbnQtd2VpZ2h0OlwiICsgZW5jb2RlSFRNTCh2YWx1ZUZvbnRXZWlnaHQgKyAnJylcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lU3R5bGU6IHtcbiAgICAgICAgZm9udFNpemU6IG5hbWVGb250U2l6ZSxcbiAgICAgICAgZmlsbDogbmFtZUZvbnRDb2xvcixcbiAgICAgICAgZm9udFdlaWdodDogbmFtZUZvbnRXZWlnaHRcbiAgICAgIH0sXG4gICAgICB2YWx1ZVN0eWxlOiB7XG4gICAgICAgIGZvbnRTaXplOiB2YWx1ZUZvbnRTaXplLFxuICAgICAgICBmaWxsOiB2YWx1ZUZvbnRDb2xvcixcbiAgICAgICAgZm9udFdlaWdodDogdmFsdWVGb250V2VpZ2h0XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuLy8gU2VlIGBUb29sdGlwTWFya3VwTGF5b3V0SW50ZW50Wydpbm5lckdhcExldmVsJ11gLlxuLy8gKHZhbHVlIGZyb20gVUkgZGVzaWduKVxudmFyIEhUTUxfR0FQUyA9IFswLCAxMCwgMjAsIDMwXTtcbnZhciBSSUNIX1RFWFRfR0FQUyA9IFsnJywgJ1xcbicsICdcXG5cXG4nLCAnXFxuXFxuXFxuJ107XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRvb2x0aXBNYXJrdXAodHlwZSwgb3B0aW9uKSB7XG4gIG9wdGlvbi50eXBlID0gdHlwZTtcbiAgcmV0dXJuIG9wdGlvbjtcbn1cbmZ1bmN0aW9uIGlzU2VjdGlvbkZyYWdtZW50KGZyYWcpIHtcbiAgcmV0dXJuIGZyYWcudHlwZSA9PT0gJ3NlY3Rpb24nO1xufVxuZnVuY3Rpb24gZ2V0QnVpbGRlcihmcmFnKSB7XG4gIHJldHVybiBpc1NlY3Rpb25GcmFnbWVudChmcmFnKSA/IGJ1aWxkU2VjdGlvbiA6IGJ1aWxkTmFtZVZhbHVlO1xufVxuZnVuY3Rpb24gZ2V0QmxvY2tHYXBMZXZlbChmcmFnKSB7XG4gIGlmIChpc1NlY3Rpb25GcmFnbWVudChmcmFnKSkge1xuICAgIHZhciBnYXBMZXZlbF8xID0gMDtcbiAgICB2YXIgc3ViQmxvY2tMZW4gPSBmcmFnLmJsb2Nrcy5sZW5ndGg7XG4gICAgdmFyIGhhc0lubmVyR2FwXzEgPSBzdWJCbG9ja0xlbiA+IDEgfHwgc3ViQmxvY2tMZW4gPiAwICYmICFmcmFnLm5vSGVhZGVyO1xuICAgIGVhY2goZnJhZy5ibG9ja3MsIGZ1bmN0aW9uIChzdWJCbG9jaykge1xuICAgICAgdmFyIHN1YkdhcExldmVsID0gZ2V0QmxvY2tHYXBMZXZlbChzdWJCbG9jayk7XG4gICAgICAvLyBJZiB0aGUgc29tZSBvZiB0aGUgc3ViLWJsb2NrcyBoYXZlIHNvbWUgZ2FwcyAobGlrZSAxMHB4KSBpbnNpZGUsIHRoaXMgYmxvY2tcbiAgICAgIC8vIHNob3VsZCB1c2UgYSBsYXJnZXIgZ2FwIChsaWtlIDIwcHgpIHRvIGRpc3Rpbmd1aXNoIHRob3NlIHN1Yi1ibG9ja3MuXG4gICAgICBpZiAoc3ViR2FwTGV2ZWwgPj0gZ2FwTGV2ZWxfMSkge1xuICAgICAgICBnYXBMZXZlbF8xID0gc3ViR2FwTGV2ZWwgKyArKGhhc0lubmVyR2FwXzEgJiYgKFxuICAgICAgICAvLyAwIGFsd2F5cyBjYW4gbm90IGJlIHJlYWRhYmxlIGdhcCBsZXZlbC5cbiAgICAgICAgIXN1YkdhcExldmVsXG4gICAgICAgIC8vIElmIG5vIGhlYWRlciwgYWx3YXlzIGtlZXAgdGhlIHN1YiBnYXAgbGV2ZWwuIE90aGVyd2lzZVxuICAgICAgICAvLyBsb29rIHdlaXJkIGluIGNhc2UgYG11bHRpcGxlU2VyaWVzYC5cbiAgICAgICAgfHwgaXNTZWN0aW9uRnJhZ21lbnQoc3ViQmxvY2spICYmICFzdWJCbG9jay5ub0hlYWRlcikpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnYXBMZXZlbF8xO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gYnVpbGRTZWN0aW9uKGN0eCwgZnJhZ21lbnQsIHRvcE1hcmdpbkZvck91dGVyR2FwLCB0b29sVGlwVGV4dFN0eWxlKSB7XG4gIHZhciBub0hlYWRlciA9IGZyYWdtZW50Lm5vSGVhZGVyO1xuICB2YXIgZ2FwcyA9IGdldEdhcChnZXRCbG9ja0dhcExldmVsKGZyYWdtZW50KSk7XG4gIHZhciBzdWJNYXJrdXBUZXh0TGlzdCA9IFtdO1xuICB2YXIgc3ViQmxvY2tzID0gZnJhZ21lbnQuYmxvY2tzIHx8IFtdO1xuICBhc3NlcnQoIXN1YkJsb2NrcyB8fCBpc0FycmF5KHN1YkJsb2NrcykpO1xuICBzdWJCbG9ja3MgPSBzdWJCbG9ja3MgfHwgW107XG4gIHZhciBvcmRlck1vZGUgPSBjdHgub3JkZXJNb2RlO1xuICBpZiAoZnJhZ21lbnQuc29ydEJsb2NrcyAmJiBvcmRlck1vZGUpIHtcbiAgICBzdWJCbG9ja3MgPSBzdWJCbG9ja3Muc2xpY2UoKTtcbiAgICB2YXIgb3JkZXJNYXAgPSB7XG4gICAgICB2YWx1ZUFzYzogJ2FzYycsXG4gICAgICB2YWx1ZURlc2M6ICdkZXNjJ1xuICAgIH07XG4gICAgaWYgKGhhc093bihvcmRlck1hcCwgb3JkZXJNb2RlKSkge1xuICAgICAgdmFyIGNvbXBhcmF0b3JfMSA9IG5ldyBTb3J0T3JkZXJDb21wYXJhdG9yKG9yZGVyTWFwW29yZGVyTW9kZV0sIG51bGwpO1xuICAgICAgc3ViQmxvY2tzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JfMS5ldmFsdWF0ZShhLnNvcnRQYXJhbSwgYi5zb3J0UGFyYW0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEZJWE1FICdzZXJpZXNEZXNjJyBuZWNlc3Nhcnk/XG4gICAgZWxzZSBpZiAob3JkZXJNb2RlID09PSAnc2VyaWVzRGVzYycpIHtcbiAgICAgIHN1YkJsb2Nrcy5yZXZlcnNlKCk7XG4gICAgfVxuICB9XG4gIGVhY2goc3ViQmxvY2tzLCBmdW5jdGlvbiAoc3ViQmxvY2ssIGlkeCkge1xuICAgIHZhciB2YWx1ZUZvcm1hdHRlciA9IGZyYWdtZW50LnZhbHVlRm9ybWF0dGVyO1xuICAgIHZhciBzdWJNYXJrdXBUZXh0ID0gZ2V0QnVpbGRlcihzdWJCbG9jaykoXG4gICAgLy8gSW5oZXJpdCB2YWx1ZUZvcm1hdHRlclxuICAgIHZhbHVlRm9ybWF0dGVyID8gZXh0ZW5kKGV4dGVuZCh7fSwgY3R4KSwge1xuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHZhbHVlRm9ybWF0dGVyXG4gICAgfSkgOiBjdHgsIHN1YkJsb2NrLCBpZHggPiAwID8gZ2Fwcy5odG1sIDogMCwgdG9vbFRpcFRleHRTdHlsZSk7XG4gICAgc3ViTWFya3VwVGV4dCAhPSBudWxsICYmIHN1Yk1hcmt1cFRleHRMaXN0LnB1c2goc3ViTWFya3VwVGV4dCk7XG4gIH0pO1xuICB2YXIgc3ViTWFya3VwVGV4dCA9IGN0eC5yZW5kZXJNb2RlID09PSAncmljaFRleHQnID8gc3ViTWFya3VwVGV4dExpc3Quam9pbihnYXBzLnJpY2hUZXh0KSA6IHdyYXBCbG9ja0hUTUwodG9vbFRpcFRleHRTdHlsZSwgc3ViTWFya3VwVGV4dExpc3Quam9pbignJyksIG5vSGVhZGVyID8gdG9wTWFyZ2luRm9yT3V0ZXJHYXAgOiBnYXBzLmh0bWwpO1xuICBpZiAobm9IZWFkZXIpIHtcbiAgICByZXR1cm4gc3ViTWFya3VwVGV4dDtcbiAgfVxuICB2YXIgZGlzcGxheWFibGVIZWFkZXIgPSBtYWtlVmFsdWVSZWFkYWJsZShmcmFnbWVudC5oZWFkZXIsICdvcmRpbmFsJywgY3R4LnVzZVVUQyk7XG4gIHZhciBuYW1lU3R5bGUgPSBnZXRUb29sdGlwVGV4dFN0eWxlKHRvb2xUaXBUZXh0U3R5bGUsIGN0eC5yZW5kZXJNb2RlKS5uYW1lU3R5bGU7XG4gIHZhciB0b29sdGlwTGluZUhlaWdodCA9IGdldFRvb2x0aXBMaW5lSGVpZ2h0KHRvb2xUaXBUZXh0U3R5bGUpO1xuICBpZiAoY3R4LnJlbmRlck1vZGUgPT09ICdyaWNoVGV4dCcpIHtcbiAgICByZXR1cm4gd3JhcElubGluZU5hbWVSaWNoVGV4dChjdHgsIGRpc3BsYXlhYmxlSGVhZGVyLCBuYW1lU3R5bGUpICsgZ2Fwcy5yaWNoVGV4dCArIHN1Yk1hcmt1cFRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHdyYXBCbG9ja0hUTUwodG9vbFRpcFRleHRTdHlsZSwgXCI8ZGl2IHN0eWxlPVxcXCJcIiArIG5hbWVTdHlsZSArIFwiO1wiICsgdG9vbHRpcExpbmVIZWlnaHQgKyBcIjtcXFwiPlwiICsgZW5jb2RlSFRNTChkaXNwbGF5YWJsZUhlYWRlcikgKyAnPC9kaXY+JyArIHN1Yk1hcmt1cFRleHQsIHRvcE1hcmdpbkZvck91dGVyR2FwKTtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGROYW1lVmFsdWUoY3R4LCBmcmFnbWVudCwgdG9wTWFyZ2luRm9yT3V0ZXJHYXAsIHRvb2xUaXBUZXh0U3R5bGUpIHtcbiAgdmFyIHJlbmRlck1vZGUgPSBjdHgucmVuZGVyTW9kZTtcbiAgdmFyIG5vTmFtZSA9IGZyYWdtZW50Lm5vTmFtZTtcbiAgdmFyIG5vVmFsdWUgPSBmcmFnbWVudC5ub1ZhbHVlO1xuICB2YXIgbm9NYXJrZXIgPSAhZnJhZ21lbnQubWFya2VyVHlwZTtcbiAgdmFyIG5hbWUgPSBmcmFnbWVudC5uYW1lO1xuICB2YXIgdXNlVVRDID0gY3R4LnVzZVVUQztcbiAgdmFyIHZhbHVlRm9ybWF0dGVyID0gZnJhZ21lbnQudmFsdWVGb3JtYXR0ZXIgfHwgY3R4LnZhbHVlRm9ybWF0dGVyIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhbHVlID0gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG4gICAgcmV0dXJuIG1hcCh2YWx1ZSwgZnVuY3Rpb24gKHZhbCwgaWR4KSB7XG4gICAgICByZXR1cm4gbWFrZVZhbHVlUmVhZGFibGUodmFsLCBpc0FycmF5KHZhbHVlVHlwZU9wdGlvbikgPyB2YWx1ZVR5cGVPcHRpb25baWR4XSA6IHZhbHVlVHlwZU9wdGlvbiwgdXNlVVRDKTtcbiAgICB9KTtcbiAgfTtcbiAgaWYgKG5vTmFtZSAmJiBub1ZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXJrZXJTdHIgPSBub01hcmtlciA/ICcnIDogY3R4Lm1hcmt1cFN0eWxlQ3JlYXRvci5tYWtlVG9vbHRpcE1hcmtlcihmcmFnbWVudC5tYXJrZXJUeXBlLCBmcmFnbWVudC5tYXJrZXJDb2xvciB8fCAnIzMzMycsIHJlbmRlck1vZGUpO1xuICB2YXIgcmVhZGFibGVOYW1lID0gbm9OYW1lID8gJycgOiBtYWtlVmFsdWVSZWFkYWJsZShuYW1lLCAnb3JkaW5hbCcsIHVzZVVUQyk7XG4gIHZhciB2YWx1ZVR5cGVPcHRpb24gPSBmcmFnbWVudC52YWx1ZVR5cGU7XG4gIHZhciByZWFkYWJsZVZhbHVlTGlzdCA9IG5vVmFsdWUgPyBbXSA6IHZhbHVlRm9ybWF0dGVyKGZyYWdtZW50LnZhbHVlLCBmcmFnbWVudC5kYXRhSW5kZXgpO1xuICB2YXIgdmFsdWVBbGlnblJpZ2h0ID0gIW5vTWFya2VyIHx8ICFub05hbWU7XG4gIC8vIEl0IGxpdHRsZSB3ZWlyZCBpZiBvbmx5IHZhbHVlIG5leHQgdG8gbWFya2VyIGJ1dCBmYXIgZnJvbSBtYXJrZXIuXG4gIHZhciB2YWx1ZUNsb3NlVG9NYXJrZXIgPSAhbm9NYXJrZXIgJiYgbm9OYW1lO1xuICB2YXIgX2EgPSBnZXRUb29sdGlwVGV4dFN0eWxlKHRvb2xUaXBUZXh0U3R5bGUsIHJlbmRlck1vZGUpLFxuICAgIG5hbWVTdHlsZSA9IF9hLm5hbWVTdHlsZSxcbiAgICB2YWx1ZVN0eWxlID0gX2EudmFsdWVTdHlsZTtcbiAgcmV0dXJuIHJlbmRlck1vZGUgPT09ICdyaWNoVGV4dCcgPyAobm9NYXJrZXIgPyAnJyA6IG1hcmtlclN0cikgKyAobm9OYW1lID8gJycgOiB3cmFwSW5saW5lTmFtZVJpY2hUZXh0KGN0eCwgcmVhZGFibGVOYW1lLCBuYW1lU3R5bGUpKVxuICAvLyBWYWx1ZSBoYXMgY29tbWFzIGluc2lkZSwgc28gdXNlICcgJyBhcyBkZWxpbWl0ZXIgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgKyAobm9WYWx1ZSA/ICcnIDogd3JhcElubGluZVZhbHVlUmljaFRleHQoY3R4LCByZWFkYWJsZVZhbHVlTGlzdCwgdmFsdWVBbGlnblJpZ2h0LCB2YWx1ZUNsb3NlVG9NYXJrZXIsIHZhbHVlU3R5bGUpKSA6IHdyYXBCbG9ja0hUTUwodG9vbFRpcFRleHRTdHlsZSwgKG5vTWFya2VyID8gJycgOiBtYXJrZXJTdHIpICsgKG5vTmFtZSA/ICcnIDogd3JhcElubGluZU5hbWVIVE1MKHJlYWRhYmxlTmFtZSwgIW5vTWFya2VyLCBuYW1lU3R5bGUpKSArIChub1ZhbHVlID8gJycgOiB3cmFwSW5saW5lVmFsdWVIVE1MKHJlYWRhYmxlVmFsdWVMaXN0LCB2YWx1ZUFsaWduUmlnaHQsIHZhbHVlQ2xvc2VUb01hcmtlciwgdmFsdWVTdHlsZSkpLCB0b3BNYXJnaW5Gb3JPdXRlckdhcCk7XG59XG4vKipcclxuICogQHJldHVybiBtYXJrdXBUZXh0LiBudWxsL3VuZGVmaW5lZCBtZWFucyBubyBjb250ZW50LlxyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFRvb2x0aXBNYXJrdXAoZnJhZ21lbnQsIG1hcmt1cFN0eWxlQ3JlYXRvciwgcmVuZGVyTW9kZSwgb3JkZXJNb2RlLCB1c2VVVEMsIHRvb2xUaXBUZXh0U3R5bGUpIHtcbiAgaWYgKCFmcmFnbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYnVpbGRlciA9IGdldEJ1aWxkZXIoZnJhZ21lbnQpO1xuICB2YXIgY3R4ID0ge1xuICAgIHVzZVVUQzogdXNlVVRDLFxuICAgIHJlbmRlck1vZGU6IHJlbmRlck1vZGUsXG4gICAgb3JkZXJNb2RlOiBvcmRlck1vZGUsXG4gICAgbWFya3VwU3R5bGVDcmVhdG9yOiBtYXJrdXBTdHlsZUNyZWF0b3IsXG4gICAgdmFsdWVGb3JtYXR0ZXI6IGZyYWdtZW50LnZhbHVlRm9ybWF0dGVyXG4gIH07XG4gIHJldHVybiBidWlsZGVyKGN0eCwgZnJhZ21lbnQsIDAsIHRvb2xUaXBUZXh0U3R5bGUpO1xufVxuZnVuY3Rpb24gZ2V0R2FwKGdhcExldmVsKSB7XG4gIHJldHVybiB7XG4gICAgaHRtbDogSFRNTF9HQVBTW2dhcExldmVsXSxcbiAgICByaWNoVGV4dDogUklDSF9URVhUX0dBUFNbZ2FwTGV2ZWxdXG4gIH07XG59XG5mdW5jdGlvbiB3cmFwQmxvY2tIVE1MKHRleHRTdHlsZSwgZW5jb2RlZENvbnRlbnQsIHRvcEdhcCkge1xuICB2YXIgY2xlYXJmaXggPSAnPGRpdiBzdHlsZT1cImNsZWFyOmJvdGhcIj48L2Rpdj4nO1xuICB2YXIgbWFyZ2luQ1NTID0gXCJtYXJnaW46IFwiICsgdG9wR2FwICsgXCJweCAwIDBcIjtcbiAgdmFyIHRvb2x0aXBMaW5lSGVpZ2h0ID0gZ2V0VG9vbHRpcExpbmVIZWlnaHQodGV4dFN0eWxlKTtcbiAgcmV0dXJuIFwiPGRpdiBzdHlsZT1cXFwiXCIgKyBtYXJnaW5DU1MgKyBcIjtcIiArIHRvb2x0aXBMaW5lSGVpZ2h0ICsgXCI7XFxcIj5cIiArIGVuY29kZWRDb250ZW50ICsgY2xlYXJmaXggKyAnPC9kaXY+Jztcbn1cbmZ1bmN0aW9uIHdyYXBJbmxpbmVOYW1lSFRNTChuYW1lLCBsZWZ0SGFzTWFya2VyLCBzdHlsZSkge1xuICB2YXIgbWFyZ2luQ3NzID0gbGVmdEhhc01hcmtlciA/ICdtYXJnaW4tbGVmdDoycHgnIDogJyc7XG4gIHJldHVybiBcIjxzcGFuIHN0eWxlPVxcXCJcIiArIHN0eWxlICsgXCI7XCIgKyBtYXJnaW5Dc3MgKyBcIlxcXCI+XCIgKyBlbmNvZGVIVE1MKG5hbWUpICsgJzwvc3Bhbj4nO1xufVxuZnVuY3Rpb24gd3JhcElubGluZVZhbHVlSFRNTCh2YWx1ZUxpc3QsIGFsaWduUmlnaHQsIHZhbHVlQ2xvc2VUb01hcmtlciwgc3R5bGUpIHtcbiAgLy8gRG8gbm90IHRvbyBjbG9zZSB0byBtYXJrZXIsIGNvbnNpZGVyaW5nIHRoZXJlIGFyZSBtdWx0aXBsZSB2YWx1ZXMgc2VwYXJhdGVkIGJ5IHNwYWNlcy5cbiAgdmFyIHBhZGRpbmdTdHIgPSB2YWx1ZUNsb3NlVG9NYXJrZXIgPyAnMTBweCcgOiAnMjBweCc7XG4gIHZhciBhbGlnbkNTUyA9IGFsaWduUmlnaHQgPyBcImZsb2F0OnJpZ2h0O21hcmdpbi1sZWZ0OlwiICsgcGFkZGluZ1N0ciA6ICcnO1xuICB2YWx1ZUxpc3QgPSBpc0FycmF5KHZhbHVlTGlzdCkgPyB2YWx1ZUxpc3QgOiBbdmFsdWVMaXN0XTtcbiAgcmV0dXJuIFwiPHNwYW4gc3R5bGU9XFxcIlwiICsgYWxpZ25DU1MgKyBcIjtcIiArIHN0eWxlICsgXCJcXFwiPlwiXG4gIC8vIFZhbHVlIGhhcyBjb21tYXMgaW5zaWRlLCBzbyB1c2UgJyAgJyBhcyBkZWxpbWl0ZXIgZm9yIG11bHRpcGxlIHZhbHVlcy5cbiAgKyBtYXAodmFsdWVMaXN0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZW5jb2RlSFRNTCh2YWx1ZSk7XG4gIH0pLmpvaW4oJyZuYnNwOyZuYnNwOycpICsgJzwvc3Bhbj4nO1xufVxuZnVuY3Rpb24gd3JhcElubGluZU5hbWVSaWNoVGV4dChjdHgsIG5hbWUsIHN0eWxlKSB7XG4gIHJldHVybiBjdHgubWFya3VwU3R5bGVDcmVhdG9yLndyYXBSaWNoVGV4dFN0eWxlKG5hbWUsIHN0eWxlKTtcbn1cbmZ1bmN0aW9uIHdyYXBJbmxpbmVWYWx1ZVJpY2hUZXh0KGN0eCwgdmFsdWVzLCBhbGlnblJpZ2h0LCB2YWx1ZUNsb3NlVG9NYXJrZXIsIHN0eWxlKSB7XG4gIHZhciBzdHlsZXMgPSBbc3R5bGVdO1xuICB2YXIgcGFkZGluZ0xlZnQgPSB2YWx1ZUNsb3NlVG9NYXJrZXIgPyAxMCA6IDIwO1xuICBhbGlnblJpZ2h0ICYmIHN0eWxlcy5wdXNoKHtcbiAgICBwYWRkaW5nOiBbMCwgMCwgMCwgcGFkZGluZ0xlZnRdLFxuICAgIGFsaWduOiAncmlnaHQnXG4gIH0pO1xuICAvLyBWYWx1ZSBoYXMgY29tbWFzIGluc2lkZSwgc28gdXNlICcgICcgYXMgZGVsaW1pdGVyIGZvciBtdWx0aXBsZSB2YWx1ZXMuXG4gIHJldHVybiBjdHgubWFya3VwU3R5bGVDcmVhdG9yLndyYXBSaWNoVGV4dFN0eWxlKGlzQXJyYXkodmFsdWVzKSA/IHZhbHVlcy5qb2luKCcgICcpIDogdmFsdWVzLCBzdHlsZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJldHJpZXZlVmlzdWFsQ29sb3JGb3JUb29sdGlwTWFya2VyKHNlcmllcywgZGF0YUluZGV4KSB7XG4gIHZhciBzdHlsZSA9IHNlcmllcy5nZXREYXRhKCkuZ2V0SXRlbVZpc3VhbChkYXRhSW5kZXgsICdzdHlsZScpO1xuICB2YXIgY29sb3IgPSBzdHlsZVtzZXJpZXMudmlzdWFsRHJhd1R5cGVdO1xuICByZXR1cm4gY29udmVydFRvQ29sb3JTdHJpbmcoY29sb3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhZGRpbmdGcm9tVG9vbHRpcE1vZGVsKG1vZGVsLCByZW5kZXJNb2RlKSB7XG4gIHZhciBwYWRkaW5nID0gbW9kZWwuZ2V0KCdwYWRkaW5nJyk7XG4gIHJldHVybiBwYWRkaW5nICE9IG51bGwgPyBwYWRkaW5nXG4gIC8vIFdlIGdpdmUgc2xpZ2h0bHkgZGlmZmVyZW50IHRvIGxvb2sgcHJldHR5LlxuICA6IHJlbmRlck1vZGUgPT09ICdyaWNoVGV4dCcgPyBbOCwgMTBdIDogMTA7XG59XG4vKipcclxuICogVGhlIG1ham9yIGZlYXR1cmUgaXMgZ2VuZXJhdGUgc3R5bGVzIGZvciBgcmVuZGVyTW9kZTogJ3JpY2hUZXh0J2AuXHJcbiAqIEJ1dCBpdCBhbHNvIHNlcnZlcyBgcmVuZGVyTW9kZTogJ2h0bWwnYCB0byBwcm92aWRlXHJcbiAqIFwicmVuZGVyTW9kZS1pbmRlcGVuZGVudFwiIEFQSS5cclxuICovXG52YXIgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvciA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IoKSB7XG4gICAgdGhpcy5yaWNoVGV4dFN0eWxlcyA9IHt9O1xuICAgIC8vIE5vdGljZSB0aGF0IFwiZ2VuZXJhdGUgYSBzdHlsZSBuYW1lXCIgdXN1YWxseSBoYXBwZW5zIHJlcGVhdGVkbHkgd2hlbiBtb3VzZSBpcyBtb3ZpbmcgYW5kXG4gICAgLy8gYSB0b29sdGlwIGlzIGRpc3BsYXllZC4gU28gd2UgcHV0IHRoZSBgX25leHRTdHlsZU5hbWVJZGAgYXMgYSBtZW1iZXIgb2YgZWFjaCBjcmVhdG9yXG4gICAgLy8gcmF0aGVyIHRoYW4gc3RhdGljIHNoYXJlZCBieSBhbGwgY3JlYXRvcnMgKHdoaWNoIHdpbGwgY2F1c2UgaXQgaW5jcmVhc2UgdG8gZmFzdCkuXG4gICAgdGhpcy5fbmV4dFN0eWxlTmFtZUlkID0gZ2V0UmFuZG9tSWRCYXNlKCk7XG4gIH1cbiAgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU3R5bGVOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnX19FQ19hVVRvXycgKyB0aGlzLl9uZXh0U3R5bGVOYW1lSWQrKztcbiAgfTtcbiAgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvci5wcm90b3R5cGUubWFrZVRvb2x0aXBNYXJrZXIgPSBmdW5jdGlvbiAobWFya2VyVHlwZSwgY29sb3JTdHIsIHJlbmRlck1vZGUpIHtcbiAgICB2YXIgbWFya2VySWQgPSByZW5kZXJNb2RlID09PSAncmljaFRleHQnID8gdGhpcy5fZ2VuZXJhdGVTdHlsZU5hbWUoKSA6IG51bGw7XG4gICAgdmFyIG1hcmtlciA9IGdldFRvb2x0aXBNYXJrZXIoe1xuICAgICAgY29sb3I6IGNvbG9yU3RyLFxuICAgICAgdHlwZTogbWFya2VyVHlwZSxcbiAgICAgIHJlbmRlck1vZGU6IHJlbmRlck1vZGUsXG4gICAgICBtYXJrZXJJZDogbWFya2VySWRcbiAgICB9KTtcbiAgICBpZiAoaXNTdHJpbmcobWFya2VyKSkge1xuICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgYXNzZXJ0KG1hcmtlcklkKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmljaFRleHRTdHlsZXNbbWFya2VySWRdID0gbWFya2VyLnN0eWxlO1xuICAgICAgcmV0dXJuIG1hcmtlci5jb250ZW50O1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogQHVzYWdlXHJcbiAgICogYGBgdHNcclxuICAgKiBjb25zdCBzdHlsZWRUZXh0ID0gbWFya3VwU3R5bGVDcmVhdG9yLndyYXBSaWNoVGV4dFN0eWxlKFtcclxuICAgKiAgICAgLy8gVGhlIHN0eWxlcyB3aWxsIGJlIGF1dG8gbWVyZ2VkLlxyXG4gICAqICAgICB7XHJcbiAgICogICAgICAgICBmb250U2l6ZTogMTIsXHJcbiAgICogICAgICAgICBjb2xvcjogJ2JsdWUnXHJcbiAgICogICAgIH0sXHJcbiAgICogICAgIHtcclxuICAgKiAgICAgICAgIHBhZGRpbmc6IDIwXHJcbiAgICogICAgIH1cclxuICAgKiBdKTtcclxuICAgKiBgYGBcclxuICAgKi9cbiAgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvci5wcm90b3R5cGUud3JhcFJpY2hUZXh0U3R5bGUgPSBmdW5jdGlvbiAodGV4dCwgc3R5bGVzKSB7XG4gICAgdmFyIGZpbmFsU3RsID0ge307XG4gICAgaWYgKGlzQXJyYXkoc3R5bGVzKSkge1xuICAgICAgZWFjaChzdHlsZXMsIGZ1bmN0aW9uIChzdGwpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZChmaW5hbFN0bCwgc3RsKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHRlbmQoZmluYWxTdGwsIHN0eWxlcyk7XG4gICAgfVxuICAgIHZhciBzdHlsZU5hbWUgPSB0aGlzLl9nZW5lcmF0ZVN0eWxlTmFtZSgpO1xuICAgIHRoaXMucmljaFRleHRTdHlsZXNbc3R5bGVOYW1lXSA9IGZpbmFsU3RsO1xuICAgIHJldHVybiBcIntcIiArIHN0eWxlTmFtZSArIFwifFwiICsgdGV4dCArIFwifVwiO1xuICB9O1xuICByZXR1cm4gVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvcjtcbn0oKTtcbmV4cG9ydCB7IFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IgfTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3961\n")},4235:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ defaultSeriesFormatTooltip)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(98026);\n/* harmony import */ var _tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3961);\n/* harmony import */ var _data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(58267);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(48170);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nfunction defaultSeriesFormatTooltip(opt) {\n  var series = opt.series;\n  var dataIndex = opt.dataIndex;\n  var multipleSeries = opt.multipleSeries;\n  var data = series.getData();\n  var tooltipDims = data.mapDimensionsAll('defaultedTooltip');\n  var tooltipDimLen = tooltipDims.length;\n  var value = series.getRawValue(dataIndex);\n  var isValueArr = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.isArray)(value);\n  var markerColor = (0,_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_1__/* .retrieveVisualColorForTooltipMarker */ .aw)(series, dataIndex);\n  // Complicated rule for pretty tooltip.\n  var inlineValue;\n  var inlineValueType;\n  var subBlocks;\n  var sortParam;\n  if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {\n    var formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor);\n    inlineValue = formatArrResult.inlineValues;\n    inlineValueType = formatArrResult.inlineValueTypes;\n    subBlocks = formatArrResult.blocks;\n    // Only support tooltip sort by the first inline value. It's enough in most cases.\n    sortParam = formatArrResult.inlineValues[0];\n  } else if (tooltipDimLen) {\n    var dimInfo = data.getDimensionInfo(tooltipDims[0]);\n    sortParam = inlineValue = (0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__/* .retrieveRawValue */ .QE)(data, dataIndex, tooltipDims[0]);\n    inlineValueType = dimInfo.type;\n  } else {\n    sortParam = inlineValue = isValueArr ? value[0] : value;\n  }\n  // Do not show generated series name. It might not be readable.\n  var seriesNameSpecified = (0,_util_model_js__WEBPACK_IMPORTED_MODULE_3__/* .isNameSpecified */ .O0)(series);\n  var seriesName = seriesNameSpecified && series.name || '';\n  var itemName = data.getName(dataIndex);\n  var inlineName = multipleSeries ? seriesName : itemName;\n  return (0,_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_1__/* .createTooltipMarkup */ .Qx)('section', {\n    header: seriesName,\n    // When series name is not specified, do not show a header line with only '-'.\n    // This case always happens in tooltip.trigger: 'item'.\n    noHeader: multipleSeries || !seriesNameSpecified,\n    sortParam: sortParam,\n    blocks: [(0,_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_1__/* .createTooltipMarkup */ .Qx)('nameValue', {\n      markerType: 'item',\n      markerColor: markerColor,\n      // Do not mix display seriesName and itemName in one tooltip,\n      // which might confuses users.\n      name: inlineName,\n      // name dimension might be auto assigned, where the name might\n      // be not readable. So we check trim here.\n      noName: !(0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.trim)(inlineName),\n      value: inlineValue,\n      valueType: inlineValueType,\n      dataIndex: dataIndex\n    })].concat(subBlocks || [])\n  });\n}\nfunction formatTooltipArrayValue(value, series, dataIndex, tooltipDims, colorStr) {\n  // check: category-no-encode-has-axis-data in dataset.html\n  var data = series.getData();\n  var isValueMultipleLine = (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.reduce)(value, function (isValueMultipleLine, val, idx) {\n    var dimItem = data.getDimensionInfo(idx);\n    return isValueMultipleLine = isValueMultipleLine || dimItem && dimItem.tooltip !== false && dimItem.displayName != null;\n  }, false);\n  var inlineValues = [];\n  var inlineValueTypes = [];\n  var blocks = [];\n  tooltipDims.length ? (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(tooltipDims, function (dim) {\n    setEachItem((0,_data_helper_dataProvider_js__WEBPACK_IMPORTED_MODULE_2__/* .retrieveRawValue */ .QE)(data, dataIndex, dim), dim);\n  })\n  // By default, all dims is used on tooltip.\n  : (0,zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_0__.each)(value, setEachItem);\n  function setEachItem(val, dim) {\n    var dimInfo = data.getDimensionInfo(dim);\n    // If `dimInfo.tooltip` is not set, show tooltip.\n    if (!dimInfo || dimInfo.otherDims.tooltip === false) {\n      return;\n    }\n    if (isValueMultipleLine) {\n      blocks.push((0,_tooltipMarkup_js__WEBPACK_IMPORTED_MODULE_1__/* .createTooltipMarkup */ .Qx)('nameValue', {\n        markerType: 'subItem',\n        markerColor: colorStr,\n        name: dimInfo.displayName,\n        value: val,\n        valueType: dimInfo.type\n      }));\n    } else {\n      inlineValues.push(val);\n      inlineValueTypes.push(dimInfo.type);\n    }\n  }\n  return {\n    inlineValues: inlineValues,\n    inlineValueTypes: inlineValueTypes,\n    blocks: blocks\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDIzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvc2VyaWVzRm9ybWF0VG9vbHRpcC5qcz81MDI3Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgdHJpbSwgaXNBcnJheSwgZWFjaCwgcmVkdWNlIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IHJldHJpZXZlVmlzdWFsQ29sb3JGb3JUb29sdGlwTWFya2VyLCBjcmVhdGVUb29sdGlwTWFya3VwIH0gZnJvbSAnLi90b29sdGlwTWFya3VwLmpzJztcbmltcG9ydCB7IHJldHJpZXZlUmF3VmFsdWUgfSBmcm9tICcuLi8uLi9kYXRhL2hlbHBlci9kYXRhUHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgaXNOYW1lU3BlY2lmaWVkIH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFNlcmllc0Zvcm1hdFRvb2x0aXAob3B0KSB7XG4gIHZhciBzZXJpZXMgPSBvcHQuc2VyaWVzO1xuICB2YXIgZGF0YUluZGV4ID0gb3B0LmRhdGFJbmRleDtcbiAgdmFyIG11bHRpcGxlU2VyaWVzID0gb3B0Lm11bHRpcGxlU2VyaWVzO1xuICB2YXIgZGF0YSA9IHNlcmllcy5nZXREYXRhKCk7XG4gIHZhciB0b29sdGlwRGltcyA9IGRhdGEubWFwRGltZW5zaW9uc0FsbCgnZGVmYXVsdGVkVG9vbHRpcCcpO1xuICB2YXIgdG9vbHRpcERpbUxlbiA9IHRvb2x0aXBEaW1zLmxlbmd0aDtcbiAgdmFyIHZhbHVlID0gc2VyaWVzLmdldFJhd1ZhbHVlKGRhdGFJbmRleCk7XG4gIHZhciBpc1ZhbHVlQXJyID0gaXNBcnJheSh2YWx1ZSk7XG4gIHZhciBtYXJrZXJDb2xvciA9IHJldHJpZXZlVmlzdWFsQ29sb3JGb3JUb29sdGlwTWFya2VyKHNlcmllcywgZGF0YUluZGV4KTtcbiAgLy8gQ29tcGxpY2F0ZWQgcnVsZSBmb3IgcHJldHR5IHRvb2x0aXAuXG4gIHZhciBpbmxpbmVWYWx1ZTtcbiAgdmFyIGlubGluZVZhbHVlVHlwZTtcbiAgdmFyIHN1YkJsb2NrcztcbiAgdmFyIHNvcnRQYXJhbTtcbiAgaWYgKHRvb2x0aXBEaW1MZW4gPiAxIHx8IGlzVmFsdWVBcnIgJiYgIXRvb2x0aXBEaW1MZW4pIHtcbiAgICB2YXIgZm9ybWF0QXJyUmVzdWx0ID0gZm9ybWF0VG9vbHRpcEFycmF5VmFsdWUodmFsdWUsIHNlcmllcywgZGF0YUluZGV4LCB0b29sdGlwRGltcywgbWFya2VyQ29sb3IpO1xuICAgIGlubGluZVZhbHVlID0gZm9ybWF0QXJyUmVzdWx0LmlubGluZVZhbHVlcztcbiAgICBpbmxpbmVWYWx1ZVR5cGUgPSBmb3JtYXRBcnJSZXN1bHQuaW5saW5lVmFsdWVUeXBlcztcbiAgICBzdWJCbG9ja3MgPSBmb3JtYXRBcnJSZXN1bHQuYmxvY2tzO1xuICAgIC8vIE9ubHkgc3VwcG9ydCB0b29sdGlwIHNvcnQgYnkgdGhlIGZpcnN0IGlubGluZSB2YWx1ZS4gSXQncyBlbm91Z2ggaW4gbW9zdCBjYXNlcy5cbiAgICBzb3J0UGFyYW0gPSBmb3JtYXRBcnJSZXN1bHQuaW5saW5lVmFsdWVzWzBdO1xuICB9IGVsc2UgaWYgKHRvb2x0aXBEaW1MZW4pIHtcbiAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyh0b29sdGlwRGltc1swXSk7XG4gICAgc29ydFBhcmFtID0gaW5saW5lVmFsdWUgPSByZXRyaWV2ZVJhd1ZhbHVlKGRhdGEsIGRhdGFJbmRleCwgdG9vbHRpcERpbXNbMF0pO1xuICAgIGlubGluZVZhbHVlVHlwZSA9IGRpbUluZm8udHlwZTtcbiAgfSBlbHNlIHtcbiAgICBzb3J0UGFyYW0gPSBpbmxpbmVWYWx1ZSA9IGlzVmFsdWVBcnIgPyB2YWx1ZVswXSA6IHZhbHVlO1xuICB9XG4gIC8vIERvIG5vdCBzaG93IGdlbmVyYXRlZCBzZXJpZXMgbmFtZS4gSXQgbWlnaHQgbm90IGJlIHJlYWRhYmxlLlxuICB2YXIgc2VyaWVzTmFtZVNwZWNpZmllZCA9IGlzTmFtZVNwZWNpZmllZChzZXJpZXMpO1xuICB2YXIgc2VyaWVzTmFtZSA9IHNlcmllc05hbWVTcGVjaWZpZWQgJiYgc2VyaWVzLm5hbWUgfHwgJyc7XG4gIHZhciBpdGVtTmFtZSA9IGRhdGEuZ2V0TmFtZShkYXRhSW5kZXgpO1xuICB2YXIgaW5saW5lTmFtZSA9IG11bHRpcGxlU2VyaWVzID8gc2VyaWVzTmFtZSA6IGl0ZW1OYW1lO1xuICByZXR1cm4gY3JlYXRlVG9vbHRpcE1hcmt1cCgnc2VjdGlvbicsIHtcbiAgICBoZWFkZXI6IHNlcmllc05hbWUsXG4gICAgLy8gV2hlbiBzZXJpZXMgbmFtZSBpcyBub3Qgc3BlY2lmaWVkLCBkbyBub3Qgc2hvdyBhIGhlYWRlciBsaW5lIHdpdGggb25seSAnLScuXG4gICAgLy8gVGhpcyBjYXNlIGFsd2F5cyBoYXBwZW5zIGluIHRvb2x0aXAudHJpZ2dlcjogJ2l0ZW0nLlxuICAgIG5vSGVhZGVyOiBtdWx0aXBsZVNlcmllcyB8fCAhc2VyaWVzTmFtZVNwZWNpZmllZCxcbiAgICBzb3J0UGFyYW06IHNvcnRQYXJhbSxcbiAgICBibG9ja3M6IFtjcmVhdGVUb29sdGlwTWFya3VwKCduYW1lVmFsdWUnLCB7XG4gICAgICBtYXJrZXJUeXBlOiAnaXRlbScsXG4gICAgICBtYXJrZXJDb2xvcjogbWFya2VyQ29sb3IsXG4gICAgICAvLyBEbyBub3QgbWl4IGRpc3BsYXkgc2VyaWVzTmFtZSBhbmQgaXRlbU5hbWUgaW4gb25lIHRvb2x0aXAsXG4gICAgICAvLyB3aGljaCBtaWdodCBjb25mdXNlcyB1c2Vycy5cbiAgICAgIG5hbWU6IGlubGluZU5hbWUsXG4gICAgICAvLyBuYW1lIGRpbWVuc2lvbiBtaWdodCBiZSBhdXRvIGFzc2lnbmVkLCB3aGVyZSB0aGUgbmFtZSBtaWdodFxuICAgICAgLy8gYmUgbm90IHJlYWRhYmxlLiBTbyB3ZSBjaGVjayB0cmltIGhlcmUuXG4gICAgICBub05hbWU6ICF0cmltKGlubGluZU5hbWUpLFxuICAgICAgdmFsdWU6IGlubGluZVZhbHVlLFxuICAgICAgdmFsdWVUeXBlOiBpbmxpbmVWYWx1ZVR5cGUsXG4gICAgICBkYXRhSW5kZXg6IGRhdGFJbmRleFxuICAgIH0pXS5jb25jYXQoc3ViQmxvY2tzIHx8IFtdKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRvb2x0aXBBcnJheVZhbHVlKHZhbHVlLCBzZXJpZXMsIGRhdGFJbmRleCwgdG9vbHRpcERpbXMsIGNvbG9yU3RyKSB7XG4gIC8vIGNoZWNrOiBjYXRlZ29yeS1uby1lbmNvZGUtaGFzLWF4aXMtZGF0YSBpbiBkYXRhc2V0Lmh0bWxcbiAgdmFyIGRhdGEgPSBzZXJpZXMuZ2V0RGF0YSgpO1xuICB2YXIgaXNWYWx1ZU11bHRpcGxlTGluZSA9IHJlZHVjZSh2YWx1ZSwgZnVuY3Rpb24gKGlzVmFsdWVNdWx0aXBsZUxpbmUsIHZhbCwgaWR4KSB7XG4gICAgdmFyIGRpbUl0ZW0gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oaWR4KTtcbiAgICByZXR1cm4gaXNWYWx1ZU11bHRpcGxlTGluZSA9IGlzVmFsdWVNdWx0aXBsZUxpbmUgfHwgZGltSXRlbSAmJiBkaW1JdGVtLnRvb2x0aXAgIT09IGZhbHNlICYmIGRpbUl0ZW0uZGlzcGxheU5hbWUgIT0gbnVsbDtcbiAgfSwgZmFsc2UpO1xuICB2YXIgaW5saW5lVmFsdWVzID0gW107XG4gIHZhciBpbmxpbmVWYWx1ZVR5cGVzID0gW107XG4gIHZhciBibG9ja3MgPSBbXTtcbiAgdG9vbHRpcERpbXMubGVuZ3RoID8gZWFjaCh0b29sdGlwRGltcywgZnVuY3Rpb24gKGRpbSkge1xuICAgIHNldEVhY2hJdGVtKHJldHJpZXZlUmF3VmFsdWUoZGF0YSwgZGF0YUluZGV4LCBkaW0pLCBkaW0pO1xuICB9KVxuICAvLyBCeSBkZWZhdWx0LCBhbGwgZGltcyBpcyB1c2VkIG9uIHRvb2x0aXAuXG4gIDogZWFjaCh2YWx1ZSwgc2V0RWFjaEl0ZW0pO1xuICBmdW5jdGlvbiBzZXRFYWNoSXRlbSh2YWwsIGRpbSkge1xuICAgIHZhciBkaW1JbmZvID0gZGF0YS5nZXREaW1lbnNpb25JbmZvKGRpbSk7XG4gICAgLy8gSWYgYGRpbUluZm8udG9vbHRpcGAgaXMgbm90IHNldCwgc2hvdyB0b29sdGlwLlxuICAgIGlmICghZGltSW5mbyB8fCBkaW1JbmZvLm90aGVyRGltcy50b29sdGlwID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNWYWx1ZU11bHRpcGxlTGluZSkge1xuICAgICAgYmxvY2tzLnB1c2goY3JlYXRlVG9vbHRpcE1hcmt1cCgnbmFtZVZhbHVlJywge1xuICAgICAgICBtYXJrZXJUeXBlOiAnc3ViSXRlbScsXG4gICAgICAgIG1hcmtlckNvbG9yOiBjb2xvclN0cixcbiAgICAgICAgbmFtZTogZGltSW5mby5kaXNwbGF5TmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbCxcbiAgICAgICAgdmFsdWVUeXBlOiBkaW1JbmZvLnR5cGVcbiAgICAgIH0pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5saW5lVmFsdWVzLnB1c2godmFsKTtcbiAgICAgIGlubGluZVZhbHVlVHlwZXMucHVzaChkaW1JbmZvLnR5cGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGlubGluZVZhbHVlczogaW5saW5lVmFsdWVzLFxuICAgIGlubGluZVZhbHVlVHlwZXM6IGlubGluZVZhbHVlVHlwZXMsXG4gICAgYmxvY2tzOiBibG9ja3NcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4235\n")},6641:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install_install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/install.js + 4 modules\nvar install = __webpack_require__(46524);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/extension.js\nvar extension = __webpack_require__(3087);\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Component.js\nvar Component = __webpack_require__(15915);\n;// ./node_modules/echarts/lib/component/tooltip/TooltipModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar TooltipModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TooltipModel, _super);\n  function TooltipModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TooltipModel.type;\n    return _this;\n  }\n  TooltipModel.type = 'tooltip';\n  TooltipModel.dependencies = ['axisPointer'];\n  TooltipModel.defaultOption = {\n    // zlevel: 0,\n    z: 60,\n    show: true,\n    // tooltip main content\n    showContent: true,\n    // 'trigger' only works on coordinate system.\n    // 'item' | 'axis' | 'none'\n    trigger: 'item',\n    // 'click' | 'mousemove' | 'none'\n    triggerOn: 'mousemove|click',\n    alwaysShowContent: false,\n    displayMode: 'single',\n    renderMode: 'auto',\n    // whether restraint content inside viewRect.\n    // If renderMode: 'richText', default true.\n    // If renderMode: 'html', defaut false (for backward compat).\n    confine: null,\n    showDelay: 0,\n    hideDelay: 100,\n    // Animation transition time, unit is second\n    transitionDuration: 0.4,\n    enterable: false,\n    backgroundColor: '#fff',\n    // box shadow\n    shadowBlur: 10,\n    shadowColor: 'rgba(0, 0, 0, .2)',\n    shadowOffsetX: 1,\n    shadowOffsetY: 2,\n    // tooltip border radius, unit is px, default is 4\n    borderRadius: 4,\n    // tooltip border width, unit is px, default is 0 (no border)\n    borderWidth: 1,\n    // Tooltip inside padding, default is 5 for all direction\n    // Array is allowed to set up, right, bottom, left, same with css\n    // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.\n    padding: null,\n    // Extra css text\n    extraCssText: '',\n    // axis indicator, trigger by axis\n    axisPointer: {\n      // default is line\n      // legal values: 'line' | 'shadow' | 'cross'\n      type: 'line',\n      // Valid when type is line, appoint tooltip line locate on which line. Optional\n      // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'\n      // default is 'auto', chose the axis which type is category.\n      // for multiply y axis, cartesian coord chose x axis, polar chose angle axis\n      axis: 'auto',\n      animation: 'auto',\n      animationDurationUpdate: 200,\n      animationEasingUpdate: 'exponentialOut',\n      crossStyle: {\n        color: '#999',\n        width: 1,\n        type: 'dashed',\n        // TODO formatter\n        textStyle: {}\n      }\n      // lineStyle and shadowStyle should not be specified here,\n      // otherwise it will always override those styles on option.axisPointer.\n    },\n    textStyle: {\n      color: '#666',\n      fontSize: 14\n    }\n  };\n  return TooltipModel;\n}(Component/* default */.A);\n/* harmony default export */ const tooltip_TooltipModel = (TooltipModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/env.js\nvar env = __webpack_require__(38123);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(35452);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/dom.js + 1 modules\nvar dom = __webpack_require__(29687);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/format.js\nvar format = __webpack_require__(83412);\n;// ./node_modules/echarts/lib/component/tooltip/helper.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n/* global document */\nfunction shouldTooltipConfine(tooltipModel) {\n  var confineOption = tooltipModel.get('confine');\n  return confineOption != null ? !!confineOption\n  // In richText mode, the outside part can not be visible.\n  : tooltipModel.get('renderMode') === 'richText';\n}\nfunction testStyle(styleProps) {\n  if (!env/* default */.A.domSupported) {\n    return;\n  }\n  var style = document.documentElement.style;\n  for (var i = 0, len = styleProps.length; i < len; i++) {\n    if (styleProps[i] in style) {\n      return styleProps[i];\n    }\n  }\n}\nvar TRANSFORM_VENDOR = testStyle(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform']);\nvar TRANSITION_VENDOR = testStyle(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);\nfunction toCSSVendorPrefix(styleVendor, styleProp) {\n  if (!styleVendor) {\n    return styleProp;\n  }\n  styleProp = (0,format/* toCamelCase */.Cb)(styleProp, true);\n  var idx = styleVendor.indexOf(styleProp);\n  styleVendor = idx === -1 ? styleProp : \"-\" + styleVendor.slice(0, idx) + \"-\" + styleProp;\n  return styleVendor.toLowerCase();\n}\nfunction getComputedStyle(el, style) {\n  var stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el);\n  return stl ? style ? stl[style] : stl : null;\n}\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/tooltip/tooltipMarkup.js\nvar tooltipMarkup = __webpack_require__(3961);\n;// ./node_modules/echarts/lib/component/tooltip/TooltipHTMLContent.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n/* global document, window */\nvar CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, 'transition');\nvar CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, 'transform');\n// eslint-disable-next-line\nvar gCssText = \"position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;\" + (env/* default */.A.transform3dSupported ? 'will-change:transform;' : '');\nfunction mirrorPos(pos) {\n  pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top';\n  return pos;\n}\nfunction assembleArrow(tooltipModel, borderColor, arrowPosition) {\n  if (!(0,util.isString)(arrowPosition) || arrowPosition === 'inside') {\n    return '';\n  }\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var borderWidth = tooltipModel.get('borderWidth');\n  borderColor = (0,format/* convertToColorString */.he)(borderColor);\n  var arrowPos = mirrorPos(arrowPosition);\n  var arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6);\n  var positionStyle = '';\n  var transformStyle = CSS_TRANSFORM_VENDOR + ':';\n  var rotateDeg;\n  if ((0,util.indexOf)(['left', 'right'], arrowPos) > -1) {\n    positionStyle += 'top:50%';\n    transformStyle += \"translateY(-50%) rotate(\" + (rotateDeg = arrowPos === 'left' ? -225 : -45) + \"deg)\";\n  } else {\n    positionStyle += 'left:50%';\n    transformStyle += \"translateX(-50%) rotate(\" + (rotateDeg = arrowPos === 'top' ? 225 : 45) + \"deg)\";\n  }\n  var rotateRadian = rotateDeg * Math.PI / 180;\n  var arrowWH = arrowSize + borderWidth;\n  var rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian));\n  var arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100;\n  positionStyle += \";\" + arrowPos + \":-\" + arrowOffset + \"px\";\n  var borderStyle = borderColor + \" solid \" + borderWidth + \"px;\";\n  var styleCss = [\"position:absolute;width:\" + arrowSize + \"px;height:\" + arrowSize + \"px;z-index:-1;\", positionStyle + \";\" + transformStyle + \";\", \"border-bottom:\" + borderStyle, \"border-right:\" + borderStyle, \"background-color:\" + backgroundColor + \";\"];\n  return \"<div style=\\\"\" + styleCss.join('') + \"\\\"></div>\";\n}\nfunction assembleTransition(duration, onlyFade) {\n  var transitionCurve = 'cubic-bezier(0.23,1,0.32,1)';\n  var transitionOption = \" \" + duration / 2 + \"s \" + transitionCurve;\n  var transitionText = \"opacity\" + transitionOption + \",visibility\" + transitionOption;\n  if (!onlyFade) {\n    transitionOption = \" \" + duration + \"s \" + transitionCurve;\n    transitionText += env/* default */.A.transformSupported ? \",\" + CSS_TRANSFORM_VENDOR + transitionOption : \",left\" + transitionOption + \",top\" + transitionOption;\n  }\n  return CSS_TRANSITION_VENDOR + ':' + transitionText;\n}\nfunction assembleTransform(x, y, toString) {\n  // If using float on style, the final width of the dom might\n  // keep changing slightly while mouse move. So `toFixed(0)` them.\n  var x0 = x.toFixed(0) + 'px';\n  var y0 = y.toFixed(0) + 'px';\n  // not support transform, use `left` and `top` instead.\n  if (!env/* default */.A.transformSupported) {\n    return toString ? \"top:\" + y0 + \";left:\" + x0 + \";\" : [['top', y0], ['left', x0]];\n  }\n  // support transform\n  var is3d = env/* default */.A.transform3dSupported;\n  var translate = \"translate\" + (is3d ? '3d' : '') + \"(\" + x0 + \",\" + y0 + (is3d ? ',0' : '') + \")\";\n  return toString ? 'top:0;left:0;' + CSS_TRANSFORM_VENDOR + ':' + translate + ';' : [['top', 0], ['left', 0], [TRANSFORM_VENDOR, translate]];\n}\n/**\r\n * @param {Object} textStyle\r\n * @return {string}\r\n * @inner\r\n */\nfunction assembleFont(textStyleModel) {\n  var cssText = [];\n  var fontSize = textStyleModel.get('fontSize');\n  var color = textStyleModel.getTextColor();\n  color && cssText.push('color:' + color);\n  cssText.push('font:' + textStyleModel.getFont());\n  // @ts-ignore, leave it to the tooltip refactor.\n  var lineHeight = (0,util.retrieve2)(textStyleModel.get('lineHeight'), Math.round(fontSize * 3 / 2));\n  fontSize && cssText.push('line-height:' + lineHeight + 'px');\n  var shadowColor = textStyleModel.get('textShadowColor');\n  var shadowBlur = textStyleModel.get('textShadowBlur') || 0;\n  var shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0;\n  var shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0;\n  shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor);\n  (0,util.each)(['decoration', 'align'], function (name) {\n    var val = textStyleModel.get(name);\n    val && cssText.push('text-' + name + ':' + val);\n  });\n  return cssText.join(';');\n}\nfunction assembleCssText(tooltipModel, enableTransition, onlyFade) {\n  var cssText = [];\n  var transitionDuration = tooltipModel.get('transitionDuration');\n  var backgroundColor = tooltipModel.get('backgroundColor');\n  var shadowBlur = tooltipModel.get('shadowBlur');\n  var shadowColor = tooltipModel.get('shadowColor');\n  var shadowOffsetX = tooltipModel.get('shadowOffsetX');\n  var shadowOffsetY = tooltipModel.get('shadowOffsetY');\n  var textStyleModel = tooltipModel.getModel('textStyle');\n  var padding = (0,tooltipMarkup/* getPaddingFromTooltipModel */.CO)(tooltipModel, 'html');\n  var boxShadow = shadowOffsetX + \"px \" + shadowOffsetY + \"px \" + shadowBlur + \"px \" + shadowColor;\n  cssText.push('box-shadow:' + boxShadow);\n  // Animation transition. Do not animate when transitionDuration is 0.\n  enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade));\n  if (backgroundColor) {\n    cssText.push('background-color:' + backgroundColor);\n  }\n  // Border style\n  (0,util.each)(['width', 'color', 'radius'], function (name) {\n    var borderName = 'border-' + name;\n    var camelCase = (0,format/* toCamelCase */.Cb)(borderName);\n    var val = tooltipModel.get(camelCase);\n    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));\n  });\n  // Text style\n  cssText.push(assembleFont(textStyleModel));\n  // Padding\n  if (padding != null) {\n    cssText.push('padding:' + (0,format/* normalizeCssArray */.QX)(padding).join('px ') + 'px');\n  }\n  return cssText.join(';') + ';';\n}\n// If not able to make, do not modify the input `out`.\nfunction makeStyleCoord(out, zr, container, zrX, zrY) {\n  var zrPainter = zr && zr.painter;\n  if (container) {\n    var zrViewportRoot = zrPainter && zrPainter.getViewportRoot();\n    if (zrViewportRoot) {\n      // Some APPs might use scale on body, so we support CSS transform here.\n      (0,dom/* transformLocalCoord */.lJ)(out, zrViewportRoot, container, zrX, zrY);\n    }\n  } else {\n    out[0] = zrX;\n    out[1] = zrY;\n    // xy should be based on canvas root. But tooltipContent is\n    // the sibling of canvas root. So padding of ec container\n    // should be considered here.\n    var viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset();\n    if (viewportRootOffset) {\n      out[0] += viewportRootOffset.offsetLeft;\n      out[1] += viewportRootOffset.offsetTop;\n    }\n  }\n  out[2] = out[0] / zr.getWidth();\n  out[3] = out[1] / zr.getHeight();\n}\nvar TooltipHTMLContent = /** @class */function () {\n  function TooltipHTMLContent(api, opt) {\n    this._show = false;\n    this._styleCoord = [0, 0, 0, 0];\n    this._enterable = true;\n    this._alwaysShowContent = false;\n    this._firstShow = true;\n    this._longHide = true;\n    if (env/* default */.A.wxa) {\n      return null;\n    }\n    var el = document.createElement('div');\n    // TODO: TYPE\n    el.domBelongToZr = true;\n    this.el = el;\n    var zr = this._zr = api.getZr();\n    var appendTo = opt.appendTo;\n    var container = appendTo && ((0,util.isString)(appendTo) ? document.querySelector(appendTo) : (0,util.isDom)(appendTo) ? appendTo : (0,util.isFunction)(appendTo) && appendTo(api.getDom()));\n    makeStyleCoord(this._styleCoord, zr, container, api.getWidth() / 2, api.getHeight() / 2);\n    (container || api.getDom()).appendChild(el);\n    this._api = api;\n    this._container = container;\n    // FIXME\n    // Is it needed to trigger zr event manually if\n    // the browser do not support `pointer-events: none`.\n    var self = this;\n    el.onmouseenter = function () {\n      // clear the timeout in hideLater and keep showing tooltip\n      if (self._enterable) {\n        clearTimeout(self._hideTimeout);\n        self._show = true;\n      }\n      self._inContent = true;\n    };\n    el.onmousemove = function (e) {\n      e = e || window.event;\n      if (!self._enterable) {\n        // `pointer-events: none` is set to tooltip content div\n        // if `enterable` is set as `false`, and `el.onmousemove`\n        // can not be triggered. But in browser that do not\n        // support `pointer-events`, we need to do this:\n        // Try trigger zrender event to avoid mouse\n        // in and out shape too frequently\n        var handler = zr.handler;\n        var zrViewportRoot = zr.painter.getViewportRoot();\n        (0,core_event/* normalizeEvent */.e0)(zrViewportRoot, e, true);\n        handler.dispatch('mousemove', e);\n      }\n    };\n    el.onmouseleave = function () {\n      // set `_inContent` to `false` before `hideLater`\n      self._inContent = false;\n      if (self._enterable) {\n        if (self._show) {\n          self.hideLater(self._hideDelay);\n        }\n      }\n    };\n  }\n  /**\r\n   * Update when tooltip is rendered\r\n   */\n  TooltipHTMLContent.prototype.update = function (tooltipModel) {\n    // FIXME\n    // Move this logic to ec main?\n    if (!this._container) {\n      var container = this._api.getDom();\n      var position = getComputedStyle(container, 'position');\n      var domStyle = container.style;\n      if (domStyle.position !== 'absolute' && position !== 'absolute') {\n        domStyle.position = 'relative';\n      }\n    }\n    // move tooltip if chart resized\n    var alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    alwaysShowContent && this._moveIfResized();\n    // update alwaysShowContent\n    this._alwaysShowContent = alwaysShowContent;\n    // update className\n    this.el.className = tooltipModel.get('className') || '';\n    // Hide the tooltip\n    // PENDING\n    // this.hide();\n  };\n  TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {\n    clearTimeout(this._hideTimeout);\n    clearTimeout(this._longHideTimeout);\n    var el = this.el;\n    var style = el.style;\n    var styleCoord = this._styleCoord;\n    if (!el.innerHTML) {\n      style.display = 'none';\n    } else {\n      style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide)\n      // initial transform\n      + assembleTransform(styleCoord[0], styleCoord[1], true) + (\"border-color:\" + (0,format/* convertToColorString */.he)(nearPointColor) + \";\") + (tooltipModel.get('extraCssText') || '')\n      // If mouse occasionally move over the tooltip, a mouseout event will be\n      // triggered by canvas, and cause some unexpectable result like dragging\n      // stop, \"unfocusAdjacency\". Here `pointer-events: none` is used to solve\n      // it. Although it is not supported by IE8~IE10, fortunately it is a rare\n      // scenario.\n      + (\";pointer-events:\" + (this._enterable ? 'auto' : 'none'));\n    }\n    this._show = true;\n    this._firstShow = false;\n    this._longHide = false;\n  };\n  TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {\n    var el = this.el;\n    if (content == null) {\n      el.innerHTML = '';\n      return;\n    }\n    var arrow = '';\n    if ((0,util.isString)(arrowPosition) && tooltipModel.get('trigger') === 'item' && !shouldTooltipConfine(tooltipModel)) {\n      arrow = assembleArrow(tooltipModel, borderColor, arrowPosition);\n    }\n    if ((0,util.isString)(content)) {\n      el.innerHTML = content + arrow;\n    } else if (content) {\n      // Clear previous\n      el.innerHTML = '';\n      if (!(0,util.isArray)(content)) {\n        content = [content];\n      }\n      for (var i = 0; i < content.length; i++) {\n        if ((0,util.isDom)(content[i]) && content[i].parentNode !== el) {\n          el.appendChild(content[i]);\n        }\n      }\n      // no arrow if empty\n      if (arrow && el.childNodes.length) {\n        // no need to create a new parent element, but it's not supported by IE 10 and older.\n        // const arrowEl = document.createRange().createContextualFragment(arrow);\n        var arrowEl = document.createElement('div');\n        arrowEl.innerHTML = arrow;\n        el.appendChild(arrowEl);\n      }\n    }\n  };\n  TooltipHTMLContent.prototype.setEnterable = function (enterable) {\n    this._enterable = enterable;\n  };\n  TooltipHTMLContent.prototype.getSize = function () {\n    var el = this.el;\n    return el ? [el.offsetWidth, el.offsetHeight] : [0, 0];\n  };\n  TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {\n    if (!this.el) {\n      return;\n    }\n    var styleCoord = this._styleCoord;\n    makeStyleCoord(styleCoord, this._zr, this._container, zrX, zrY);\n    if (styleCoord[0] != null && styleCoord[1] != null) {\n      var style_1 = this.el.style;\n      var transforms = assembleTransform(styleCoord[0], styleCoord[1]);\n      (0,util.each)(transforms, function (transform) {\n        style_1[transform[0]] = transform[1];\n      });\n    }\n  };\n  /**\r\n   * when `alwaysShowContent` is true,\r\n   * move the tooltip after chart resized\r\n   */\n  TooltipHTMLContent.prototype._moveIfResized = function () {\n    // The ratio of left to width\n    var ratioX = this._styleCoord[2];\n    // The ratio of top to height\n    var ratioY = this._styleCoord[3];\n    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());\n  };\n  TooltipHTMLContent.prototype.hide = function () {\n    var _this = this;\n    var style = this.el.style;\n    style.visibility = 'hidden';\n    style.opacity = '0';\n    env/* default */.A.transform3dSupported && (style.willChange = '');\n    this._show = false;\n    this._longHideTimeout = setTimeout(function () {\n      return _this._longHide = true;\n    }, 500);\n  };\n  TooltipHTMLContent.prototype.hideLater = function (time) {\n    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {\n      if (time) {\n        this._hideDelay = time;\n        // Set show false to avoid invoke hideLater multiple times\n        this._show = false;\n        this._hideTimeout = setTimeout((0,util.bind)(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  };\n  TooltipHTMLContent.prototype.isShow = function () {\n    return this._show;\n  };\n  TooltipHTMLContent.prototype.dispose = function () {\n    clearTimeout(this._hideTimeout);\n    clearTimeout(this._longHideTimeout);\n    var parentNode = this.el.parentNode;\n    parentNode && parentNode.removeChild(this.el);\n    this.el = this._container = null;\n  };\n  return TooltipHTMLContent;\n}();\n/* harmony default export */ const tooltip_TooltipHTMLContent = (TooltipHTMLContent);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n;// ./node_modules/echarts/lib/component/tooltip/TooltipRichContent.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar TooltipRichContent = /** @class */function () {\n  function TooltipRichContent(api) {\n    this._show = false;\n    this._styleCoord = [0, 0, 0, 0];\n    this._alwaysShowContent = false;\n    this._enterable = true;\n    this._zr = api.getZr();\n    TooltipRichContent_makeStyleCoord(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2);\n  }\n  /**\r\n   * Update when tooltip is rendered\r\n   */\n  TooltipRichContent.prototype.update = function (tooltipModel) {\n    var alwaysShowContent = tooltipModel.get('alwaysShowContent');\n    alwaysShowContent && this._moveIfResized();\n    // update alwaysShowContent\n    this._alwaysShowContent = alwaysShowContent;\n  };\n  TooltipRichContent.prototype.show = function () {\n    if (this._hideTimeout) {\n      clearTimeout(this._hideTimeout);\n    }\n    this.el.show();\n    this._show = true;\n  };\n  /**\r\n   * Set tooltip content\r\n   */\n  TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {\n    var _this = this;\n    if (util.isObject(content)) {\n      (0,log/* throwError */.$8)( false ? 0 : '');\n    }\n    if (this.el) {\n      this._zr.remove(this.el);\n    }\n    var textStyleModel = tooltipModel.getModel('textStyle');\n    this.el = new Text/* default */.Ay({\n      style: {\n        rich: markupStyleCreator.richTextStyles,\n        text: content,\n        lineHeight: 22,\n        borderWidth: 1,\n        borderColor: borderColor,\n        textShadowColor: textStyleModel.get('textShadowColor'),\n        fill: tooltipModel.get(['textStyle', 'color']),\n        padding: (0,tooltipMarkup/* getPaddingFromTooltipModel */.CO)(tooltipModel, 'richText'),\n        verticalAlign: 'top',\n        align: 'left'\n      },\n      z: tooltipModel.get('z')\n    });\n    util.each(['backgroundColor', 'borderRadius', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'], function (propName) {\n      _this.el.style[propName] = tooltipModel.get(propName);\n    });\n    util.each(['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'], function (propName) {\n      _this.el.style[propName] = textStyleModel.get(propName) || 0;\n    });\n    this._zr.add(this.el);\n    var self = this;\n    this.el.on('mouseover', function () {\n      // clear the timeout in hideLater and keep showing tooltip\n      if (self._enterable) {\n        clearTimeout(self._hideTimeout);\n        self._show = true;\n      }\n      self._inContent = true;\n    });\n    this.el.on('mouseout', function () {\n      if (self._enterable) {\n        if (self._show) {\n          self.hideLater(self._hideDelay);\n        }\n      }\n      self._inContent = false;\n    });\n  };\n  TooltipRichContent.prototype.setEnterable = function (enterable) {\n    this._enterable = enterable;\n  };\n  TooltipRichContent.prototype.getSize = function () {\n    var el = this.el;\n    var bounding = this.el.getBoundingRect();\n    // bounding rect does not include shadow. For renderMode richText,\n    // if overflow, it will be cut. So calculate them accurately.\n    var shadowOuterSize = calcShadowOuterSize(el.style);\n    return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom];\n  };\n  TooltipRichContent.prototype.moveTo = function (x, y) {\n    var el = this.el;\n    if (el) {\n      var styleCoord = this._styleCoord;\n      TooltipRichContent_makeStyleCoord(styleCoord, this._zr, x, y);\n      x = styleCoord[0];\n      y = styleCoord[1];\n      var style = el.style;\n      var borderWidth = mathMaxWith0(style.borderWidth || 0);\n      var shadowOuterSize = calcShadowOuterSize(style);\n      // rich text x, y do not include border.\n      el.x = x + borderWidth + shadowOuterSize.left;\n      el.y = y + borderWidth + shadowOuterSize.top;\n      el.markRedraw();\n    }\n  };\n  /**\r\n   * when `alwaysShowContent` is true,\r\n   * move the tooltip after chart resized\r\n   */\n  TooltipRichContent.prototype._moveIfResized = function () {\n    // The ratio of left to width\n    var ratioX = this._styleCoord[2];\n    // The ratio of top to height\n    var ratioY = this._styleCoord[3];\n    this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight());\n  };\n  TooltipRichContent.prototype.hide = function () {\n    if (this.el) {\n      this.el.hide();\n    }\n    this._show = false;\n  };\n  TooltipRichContent.prototype.hideLater = function (time) {\n    if (this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent) {\n      if (time) {\n        this._hideDelay = time;\n        // Set show false to avoid invoke hideLater multiple times\n        this._show = false;\n        this._hideTimeout = setTimeout(util.bind(this.hide, this), time);\n      } else {\n        this.hide();\n      }\n    }\n  };\n  TooltipRichContent.prototype.isShow = function () {\n    return this._show;\n  };\n  TooltipRichContent.prototype.dispose = function () {\n    this._zr.remove(this.el);\n  };\n  return TooltipRichContent;\n}();\nfunction mathMaxWith0(val) {\n  return Math.max(0, val);\n}\nfunction calcShadowOuterSize(style) {\n  var shadowBlur = mathMaxWith0(style.shadowBlur || 0);\n  var shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0);\n  var shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0);\n  return {\n    left: mathMaxWith0(shadowBlur - shadowOffsetX),\n    right: mathMaxWith0(shadowBlur + shadowOffsetX),\n    top: mathMaxWith0(shadowBlur - shadowOffsetY),\n    bottom: mathMaxWith0(shadowBlur + shadowOffsetY)\n  };\n}\nfunction TooltipRichContent_makeStyleCoord(out, zr, zrX, zrY) {\n  out[0] = zrX;\n  out[1] = zrY;\n  out[2] = out[0] / zr.getWidth();\n  out[3] = out[1] / zr.getHeight();\n}\n/* harmony default export */ const tooltip_TooltipRichContent = (TooltipRichContent);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/findPointFromSeries.js\nvar findPointFromSeries = __webpack_require__(26333);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/Model.js + 2 modules\nvar Model = __webpack_require__(43172);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/globalListener.js\nvar globalListener = __webpack_require__(44784);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/coord/axisHelper.js\nvar axisHelper = __webpack_require__(99031);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/axisPointer/viewHelper.js\nvar viewHelper = __webpack_require__(3686);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar util_model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/view/Component.js\nvar view_Component = __webpack_require__(59109);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/time.js\nvar time = __webpack_require__(55854);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/model/mixin/dataFormat.js\nvar dataFormat = __webpack_require__(9427);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/event.js\nvar util_event = __webpack_require__(47411);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/throttle.js\nvar throttle = __webpack_require__(24711);\n;// ./node_modules/echarts/lib/component/tooltip/TooltipView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar proxyRect = new Rect/* default */.A({\n  shape: {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  }\n});\nvar TooltipView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(TooltipView, _super);\n  function TooltipView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = TooltipView.type;\n    return _this;\n  }\n  TooltipView.prototype.init = function (ecModel, api) {\n    if (env/* default */.A.node || !api.getDom()) {\n      return;\n    }\n    var tooltipModel = ecModel.getComponent('tooltip');\n    var renderMode = this._renderMode = (0,util_model/* getTooltipRenderMode */.XJ)(tooltipModel.get('renderMode'));\n    this._tooltipContent = renderMode === 'richText' ? new tooltip_TooltipRichContent(api) : new tooltip_TooltipHTMLContent(api, {\n      appendTo: tooltipModel.get('appendToBody', true) ? 'body' : tooltipModel.get('appendTo', true)\n    });\n  };\n  TooltipView.prototype.render = function (tooltipModel, ecModel, api) {\n    if (env/* default */.A.node || !api.getDom()) {\n      return;\n    }\n    // Reset\n    this.group.removeAll();\n    this._tooltipModel = tooltipModel;\n    this._ecModel = ecModel;\n    this._api = api;\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.update(tooltipModel);\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n    this._initGlobalListener();\n    this._keepShow();\n    // PENDING\n    // `mousemove` event will be triggered very frequently when the mouse moves fast,\n    // which causes that the `updatePosition` function was also called frequently.\n    // In Chrome with devtools open and Firefox, tooltip looks laggy and shakes. See #14695 #16101\n    // To avoid frequent triggering,\n    // consider throttling it in 50ms when transition is enabled\n    if (this._renderMode !== 'richText' && tooltipModel.get('transitionDuration')) {\n      (0,throttle/* createOrUpdate */.N)(this, '_updatePosition', 50, 'fixRate');\n    } else {\n      (0,throttle/* clear */.IU)(this, '_updatePosition');\n    }\n  };\n  TooltipView.prototype._initGlobalListener = function () {\n    var tooltipModel = this._tooltipModel;\n    var triggerOn = tooltipModel.get('triggerOn');\n    globalListener/* register */.k('itemTooltip', this._api, (0,util.bind)(function (currTrigger, e, dispatchAction) {\n      // If 'none', it is not controlled by mouse totally.\n      if (triggerOn !== 'none') {\n        if (triggerOn.indexOf(currTrigger) >= 0) {\n          this._tryShow(e, dispatchAction);\n        } else if (currTrigger === 'leave') {\n          this._hide(dispatchAction);\n        }\n      }\n    }, this));\n  };\n  TooltipView.prototype._keepShow = function () {\n    var tooltipModel = this._tooltipModel;\n    var ecModel = this._ecModel;\n    var api = this._api;\n    var triggerOn = tooltipModel.get('triggerOn');\n    // Try to keep the tooltip show when refreshing\n    if (this._lastX != null && this._lastY != null\n    // When user is willing to control tooltip totally using API,\n    // self.manuallyShowTip({x, y}) might cause tooltip hide,\n    // which is not expected.\n    && triggerOn !== 'none' && triggerOn !== 'click') {\n      var self_1 = this;\n      clearTimeout(this._refreshUpdateTimeout);\n      this._refreshUpdateTimeout = setTimeout(function () {\n        // Show tip next tick after other charts are rendered\n        // In case highlight action has wrong result\n        // FIXME\n        !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {\n          x: self_1._lastX,\n          y: self_1._lastY,\n          dataByCoordSys: self_1._lastDataByCoordSys\n        });\n      });\n    }\n  };\n  /**\r\n   * Show tip manually by\r\n   * dispatchAction({\r\n   *     type: 'showTip',\r\n   *     x: 10,\r\n   *     y: 10\r\n   * });\r\n   * Or\r\n   * dispatchAction({\r\n   *      type: 'showTip',\r\n   *      seriesIndex: 0,\r\n   *      dataIndex or dataIndexInside or name\r\n   * });\r\n   *\r\n   *  TODO Batch\r\n   */\n  TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {\n    if (payload.from === this.uid || env/* default */.A.node || !api.getDom()) {\n      return;\n    }\n    var dispatchAction = makeDispatchAction(payload, api);\n    // Reset ticket\n    this._ticket = '';\n    // When triggered from axisPointer.\n    var dataByCoordSys = payload.dataByCoordSys;\n    var cmptRef = findComponentReference(payload, ecModel, api);\n    if (cmptRef) {\n      var rect = cmptRef.el.getBoundingRect().clone();\n      rect.applyTransform(cmptRef.el.transform);\n      this._tryShow({\n        offsetX: rect.x + rect.width / 2,\n        offsetY: rect.y + rect.height / 2,\n        target: cmptRef.el,\n        position: payload.position,\n        // When manully trigger, the mouse is not on the el, so we'd better to\n        // position tooltip on the bottom of the el and display arrow is possible.\n        positionDefault: 'bottom'\n      }, dispatchAction);\n    } else if (payload.tooltip && payload.x != null && payload.y != null) {\n      var el = proxyRect;\n      el.x = payload.x;\n      el.y = payload.y;\n      el.update();\n      (0,innerStore/* getECData */.z)(el).tooltipConfig = {\n        name: null,\n        option: payload.tooltip\n      };\n      // Manually show tooltip while view is not using zrender elements.\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        target: el\n      }, dispatchAction);\n    } else if (dataByCoordSys) {\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        dataByCoordSys: dataByCoordSys,\n        tooltipOption: payload.tooltipOption\n      }, dispatchAction);\n    } else if (payload.seriesIndex != null) {\n      if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {\n        return;\n      }\n      var pointInfo = (0,findPointFromSeries/* default */.A)(payload, ecModel);\n      var cx = pointInfo.point[0];\n      var cy = pointInfo.point[1];\n      if (cx != null && cy != null) {\n        this._tryShow({\n          offsetX: cx,\n          offsetY: cy,\n          target: pointInfo.el,\n          position: payload.position,\n          // When manully trigger, the mouse is not on the el, so we'd better to\n          // position tooltip on the bottom of the el and display arrow is possible.\n          positionDefault: 'bottom'\n        }, dispatchAction);\n      }\n    } else if (payload.x != null && payload.y != null) {\n      // FIXME\n      // should wrap dispatchAction like `axisPointer/globalListener` ?\n      api.dispatchAction({\n        type: 'updateAxisPointer',\n        x: payload.x,\n        y: payload.y\n      });\n      this._tryShow({\n        offsetX: payload.x,\n        offsetY: payload.y,\n        position: payload.position,\n        target: api.getZr().findHover(payload.x, payload.y).target\n      }, dispatchAction);\n    }\n  };\n  TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {\n    var tooltipContent = this._tooltipContent;\n    if (this._tooltipModel) {\n      tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));\n    }\n    this._lastX = this._lastY = this._lastDataByCoordSys = null;\n    if (payload.from !== this.uid) {\n      this._hide(makeDispatchAction(payload, api));\n    }\n  };\n  // Be compatible with previous design, that is, when tooltip.type is 'axis' and\n  // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer\n  // and tooltip.\n  TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {\n    var seriesIndex = payload.seriesIndex;\n    var dataIndex = payload.dataIndex;\n    // @ts-ignore\n    var coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo;\n    if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {\n      return;\n    }\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n    if (!seriesModel) {\n      return;\n    }\n    var data = seriesModel.getData();\n    var tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel);\n    if (tooltipCascadedModel.get('trigger') !== 'axis') {\n      return;\n    }\n    api.dispatchAction({\n      type: 'updateAxisPointer',\n      seriesIndex: seriesIndex,\n      dataIndex: dataIndex,\n      position: payload.position\n    });\n    return true;\n  };\n  TooltipView.prototype._tryShow = function (e, dispatchAction) {\n    var el = e.target;\n    var tooltipModel = this._tooltipModel;\n    if (!tooltipModel) {\n      return;\n    }\n    // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed\n    this._lastX = e.offsetX;\n    this._lastY = e.offsetY;\n    var dataByCoordSys = e.dataByCoordSys;\n    if (dataByCoordSys && dataByCoordSys.length) {\n      this._showAxisTooltip(dataByCoordSys, e);\n    } else if (el) {\n      var ecData = (0,innerStore/* getECData */.z)(el);\n      if (ecData.ssrType === 'legend') {\n        // Don't trigger tooltip for legend tooltip item\n        return;\n      }\n      this._lastDataByCoordSys = null;\n      var seriesDispatcher_1;\n      var cmptDispatcher_1;\n      (0,util_event/* findEventDispatcher */.R)(el, function (target) {\n        // Always show item tooltip if mouse is on the element with dataIndex\n        if ((0,innerStore/* getECData */.z)(target).dataIndex != null) {\n          seriesDispatcher_1 = target;\n          return true;\n        }\n        // Tooltip provided directly. Like legend.\n        if ((0,innerStore/* getECData */.z)(target).tooltipConfig != null) {\n          cmptDispatcher_1 = target;\n          return true;\n        }\n      }, true);\n      if (seriesDispatcher_1) {\n        this._showSeriesItemTooltip(e, seriesDispatcher_1, dispatchAction);\n      } else if (cmptDispatcher_1) {\n        this._showComponentItemTooltip(e, cmptDispatcher_1, dispatchAction);\n      } else {\n        this._hide(dispatchAction);\n      }\n    } else {\n      this._lastDataByCoordSys = null;\n      this._hide(dispatchAction);\n    }\n  };\n  TooltipView.prototype._showOrMove = function (tooltipModel, cb) {\n    // showDelay is used in this case: tooltip.enterable is set\n    // as true. User intent to move mouse into tooltip and click\n    // something. `showDelay` makes it easier to enter the content\n    // but tooltip do not move immediately.\n    var delay = tooltipModel.get('showDelay');\n    cb = (0,util.bind)(cb, this);\n    clearTimeout(this._showTimout);\n    delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb();\n  };\n  TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {\n    var ecModel = this._ecModel;\n    var globalTooltipModel = this._tooltipModel;\n    var point = [e.offsetX, e.offsetY];\n    var singleTooltipModel = buildTooltipModel([e.tooltipOption], globalTooltipModel);\n    var renderMode = this._renderMode;\n    var cbParamsList = [];\n    var articleMarkup = (0,tooltipMarkup/* createTooltipMarkup */.Qx)('section', {\n      blocks: [],\n      noHeader: true\n    });\n    // Only for legacy: `Serise['formatTooltip']` returns a string.\n    var markupTextArrLegacy = [];\n    var markupStyleCreator = new tooltipMarkup/* TooltipMarkupStyleCreator */.lb();\n    (0,util.each)(dataByCoordSys, function (itemCoordSys) {\n      (0,util.each)(itemCoordSys.dataByAxis, function (axisItem) {\n        var axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex);\n        var axisValue = axisItem.value;\n        if (!axisModel || axisValue == null) {\n          return;\n        }\n        var axisValueLabel = viewHelper/* getValueLabel */._F(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt);\n        var axisSectionMarkup = (0,tooltipMarkup/* createTooltipMarkup */.Qx)('section', {\n          header: axisValueLabel,\n          noHeader: !(0,util.trim)(axisValueLabel),\n          sortBlocks: true,\n          blocks: []\n        });\n        articleMarkup.blocks.push(axisSectionMarkup);\n        (0,util.each)(axisItem.seriesDataIndices, function (idxItem) {\n          var series = ecModel.getSeriesByIndex(idxItem.seriesIndex);\n          var dataIndex = idxItem.dataIndexInside;\n          var cbParams = series.getDataParams(dataIndex);\n          // Can't find data.\n          if (cbParams.dataIndex < 0) {\n            return;\n          }\n          cbParams.axisDim = axisItem.axisDim;\n          cbParams.axisIndex = axisItem.axisIndex;\n          cbParams.axisType = axisItem.axisType;\n          cbParams.axisId = axisItem.axisId;\n          cbParams.axisValue = axisHelper/* getAxisRawValue */.Dt(axisModel.axis, {\n            value: axisValue\n          });\n          cbParams.axisValueLabel = axisValueLabel;\n          // Pre-create marker style for makers. Users can assemble richText\n          // text in `formatter` callback and use those markers style.\n          cbParams.marker = markupStyleCreator.makeTooltipMarker('item', (0,format/* convertToColorString */.he)(cbParams.color), renderMode);\n          var seriesTooltipResult = (0,dataFormat/* normalizeTooltipFormatResult */.L)(series.formatTooltip(dataIndex, true, null));\n          var frag = seriesTooltipResult.frag;\n          if (frag) {\n            var valueFormatter = buildTooltipModel([series], globalTooltipModel).get('valueFormatter');\n            axisSectionMarkup.blocks.push(valueFormatter ? (0,util.extend)({\n              valueFormatter: valueFormatter\n            }, frag) : frag);\n          }\n          if (seriesTooltipResult.text) {\n            markupTextArrLegacy.push(seriesTooltipResult.text);\n          }\n          cbParamsList.push(cbParams);\n        });\n      });\n    });\n    // In most cases, the second axis is displays upper on the first one.\n    // So we reverse it to look better.\n    articleMarkup.blocks.reverse();\n    markupTextArrLegacy.reverse();\n    var positionExpr = e.position;\n    var orderMode = singleTooltipModel.get('order');\n    var builtMarkupText = (0,tooltipMarkup/* buildTooltipMarkup */.Yu)(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), singleTooltipModel.get('textStyle'));\n    builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText);\n    var blockBreak = renderMode === 'richText' ? '\\n\\n' : '<br/>';\n    var allMarkupText = markupTextArrLegacy.join(blockBreak);\n    this._showOrMove(singleTooltipModel, function () {\n      if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {\n        this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList);\n      } else {\n        this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator);\n      }\n    });\n    // Do not trigger events here, because this branch only be entered\n    // from dispatchAction.\n  };\n  TooltipView.prototype._showSeriesItemTooltip = function (e, dispatcher, dispatchAction) {\n    var ecModel = this._ecModel;\n    var ecData = (0,innerStore/* getECData */.z)(dispatcher);\n    // Use dataModel in element if possible\n    // Used when mouseover on a element like markPoint or edge\n    // In which case, the data is not main data in series.\n    var seriesIndex = ecData.seriesIndex;\n    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);\n    // For example, graph link.\n    var dataModel = ecData.dataModel || seriesModel;\n    var dataIndex = ecData.dataIndex;\n    var dataType = ecData.dataType;\n    var data = dataModel.getData(dataType);\n    var renderMode = this._renderMode;\n    var positionDefault = e.positionDefault;\n    var tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault ? {\n      position: positionDefault\n    } : null);\n    var tooltipTrigger = tooltipModel.get('trigger');\n    if (tooltipTrigger != null && tooltipTrigger !== 'item') {\n      return;\n    }\n    var params = dataModel.getDataParams(dataIndex, dataType);\n    var markupStyleCreator = new tooltipMarkup/* TooltipMarkupStyleCreator */.lb();\n    // Pre-create marker style for makers. Users can assemble richText\n    // text in `formatter` callback and use those markers style.\n    params.marker = markupStyleCreator.makeTooltipMarker('item', (0,format/* convertToColorString */.he)(params.color), renderMode);\n    var seriesTooltipResult = (0,dataFormat/* normalizeTooltipFormatResult */.L)(dataModel.formatTooltip(dataIndex, false, dataType));\n    var orderMode = tooltipModel.get('order');\n    var valueFormatter = tooltipModel.get('valueFormatter');\n    var frag = seriesTooltipResult.frag;\n    var markupText = frag ? (0,tooltipMarkup/* buildTooltipMarkup */.Yu)(valueFormatter ? (0,util.extend)({\n      valueFormatter: valueFormatter\n    }, frag) : frag, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), tooltipModel.get('textStyle')) : seriesTooltipResult.text;\n    var asyncTicket = 'item_' + dataModel.name + '_' + dataIndex;\n    this._showOrMove(tooltipModel, function () {\n      this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator);\n    });\n    // FIXME\n    // duplicated showtip if manuallyShowTip is called from dispatchAction.\n    dispatchAction({\n      type: 'showTip',\n      dataIndexInside: dataIndex,\n      dataIndex: data.getRawIndex(dataIndex),\n      seriesIndex: seriesIndex,\n      from: this.uid\n    });\n  };\n  TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {\n    var isHTMLRenderMode = this._renderMode === 'html';\n    var ecData = (0,innerStore/* getECData */.z)(el);\n    var tooltipConfig = ecData.tooltipConfig;\n    var tooltipOpt = tooltipConfig.option || {};\n    var encodeHTMLContent = tooltipOpt.encodeHTMLContent;\n    if ((0,util.isString)(tooltipOpt)) {\n      var content = tooltipOpt;\n      tooltipOpt = {\n        content: content,\n        // Fixed formatter\n        formatter: content\n      };\n      // when `tooltipConfig.option` is a string rather than an object,\n      // we can't know if the content needs to be encoded\n      // for the sake of security, encode it by default.\n      encodeHTMLContent = true;\n    }\n    if (encodeHTMLContent && isHTMLRenderMode && tooltipOpt.content) {\n      // clone might be unnecessary?\n      tooltipOpt = (0,util.clone)(tooltipOpt);\n      tooltipOpt.content = (0,dom/* encodeHTML */.Me)(tooltipOpt.content);\n    }\n    var tooltipModelCascade = [tooltipOpt];\n    var cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex);\n    if (cmpt) {\n      tooltipModelCascade.push(cmpt);\n    }\n    // In most cases, component tooltip formatter has different params with series tooltip formatter,\n    // so that they cannot share the same formatter. Since the global tooltip formatter is used for series\n    // by convention, we do not use it as the default formatter for component.\n    tooltipModelCascade.push({\n      formatter: tooltipOpt.content\n    });\n    var positionDefault = e.positionDefault;\n    var subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault ? {\n      position: positionDefault\n    } : null);\n    var defaultHtml = subTooltipModel.get('content');\n    var asyncTicket = Math.random() + '';\n    // PENDING: this case do not support richText style yet.\n    var markupStyleCreator = new tooltipMarkup/* TooltipMarkupStyleCreator */.lb();\n    // Do not check whether `trigger` is 'none' here, because `trigger`\n    // only works on coordinate system. In fact, we have not found case\n    // that requires setting `trigger` nothing on component yet.\n    this._showOrMove(subTooltipModel, function () {\n      // Use formatterParams from element defined in component\n      // Avoid users modify it.\n      var formatterParams = (0,util.clone)(subTooltipModel.get('formatterParams') || {});\n      this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator);\n    });\n    // If not dispatch showTip, tip may be hide triggered by axis.\n    dispatchAction({\n      type: 'showTip',\n      from: this.uid\n    });\n  };\n  TooltipView.prototype._showTooltipContent = function (\n  // Use Model<TooltipOption> insteadof TooltipModel because this model may be from series or other options.\n  // Instead of top level tooltip.\n  tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {\n    // Reset ticket\n    this._ticket = '';\n    if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {\n      return;\n    }\n    var tooltipContent = this._tooltipContent;\n    tooltipContent.setEnterable(tooltipModel.get('enterable'));\n    var formatter = tooltipModel.get('formatter');\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var html = defaultHtml;\n    var nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'), tooltipModel.get('borderColor'));\n    var nearPointColor = nearPoint.color;\n    if (formatter) {\n      if ((0,util.isString)(formatter)) {\n        var useUTC = tooltipModel.ecModel.get('useUTC');\n        var params0 = (0,util.isArray)(params) ? params[0] : params;\n        var isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0;\n        html = formatter;\n        if (isTimeAxis) {\n          html = (0,time/* format */.GP)(params0.axisValue, html, useUTC);\n        }\n        html = (0,format/* formatTpl */.YK)(html, params, true);\n      } else if ((0,util.isFunction)(formatter)) {\n        var callback = (0,util.bind)(function (cbTicket, html) {\n          if (cbTicket === this._ticket) {\n            tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);\n            this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n          }\n        }, this);\n        this._ticket = asyncTicket;\n        html = formatter(params, asyncTicket, callback);\n      } else {\n        html = formatter;\n      }\n    }\n    tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr);\n    tooltipContent.show(tooltipModel, nearPointColor);\n    this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el);\n  };\n  TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger, borderColor) {\n    if (trigger === 'axis' || (0,util.isArray)(tooltipDataParams)) {\n      return {\n        color: borderColor || (this._renderMode === 'html' ? '#fff' : 'none')\n      };\n    }\n    if (!(0,util.isArray)(tooltipDataParams)) {\n      return {\n        color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor\n      };\n    }\n  };\n  TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x,\n  // Mouse x\n  y,\n  // Mouse y\n  content, params, el) {\n    var viewWidth = this._api.getWidth();\n    var viewHeight = this._api.getHeight();\n    positionExpr = positionExpr || tooltipModel.get('position');\n    var contentSize = content.getSize();\n    var align = tooltipModel.get('align');\n    var vAlign = tooltipModel.get('verticalAlign');\n    var rect = el && el.getBoundingRect().clone();\n    el && rect.applyTransform(el.transform);\n    if ((0,util.isFunction)(positionExpr)) {\n      // Callback of position can be an array or a string specify the position\n      positionExpr = positionExpr([x, y], params, content.el, rect, {\n        viewSize: [viewWidth, viewHeight],\n        contentSize: contentSize.slice()\n      });\n    }\n    if ((0,util.isArray)(positionExpr)) {\n      x = (0,number/* parsePercent */.lo)(positionExpr[0], viewWidth);\n      y = (0,number/* parsePercent */.lo)(positionExpr[1], viewHeight);\n    } else if ((0,util.isObject)(positionExpr)) {\n      var boxLayoutPosition = positionExpr;\n      boxLayoutPosition.width = contentSize[0];\n      boxLayoutPosition.height = contentSize[1];\n      var layoutRect = (0,layout/* getLayoutRect */.dV)(boxLayoutPosition, {\n        width: viewWidth,\n        height: viewHeight\n      });\n      x = layoutRect.x;\n      y = layoutRect.y;\n      align = null;\n      // When positionExpr is left/top/right/bottom,\n      // align and verticalAlign will not work.\n      vAlign = null;\n    }\n    // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element\n    else if ((0,util.isString)(positionExpr) && el) {\n      var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get('borderWidth'));\n      x = pos[0];\n      y = pos[1];\n    } else {\n      var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20);\n      x = pos[0];\n      y = pos[1];\n    }\n    align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0);\n    vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0);\n    if (shouldTooltipConfine(tooltipModel)) {\n      var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight);\n      x = pos[0];\n      y = pos[1];\n    }\n    content.moveTo(x, y);\n  };\n  // FIXME\n  // Should we remove this but leave this to user?\n  TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys, cbParamsList) {\n    var lastCoordSys = this._lastDataByCoordSys;\n    var lastCbParamsList = this._cbParamsList;\n    var contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length;\n    contentNotChanged && (0,util.each)(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {\n      var lastDataByAxis = lastItemCoordSys.dataByAxis || [];\n      var thisItemCoordSys = dataByCoordSys[indexCoordSys] || {};\n      var thisDataByAxis = thisItemCoordSys.dataByAxis || [];\n      contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length;\n      contentNotChanged && (0,util.each)(lastDataByAxis, function (lastItem, indexAxis) {\n        var thisItem = thisDataByAxis[indexAxis] || {};\n        var lastIndices = lastItem.seriesDataIndices || [];\n        var newIndices = thisItem.seriesDataIndices || [];\n        contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length;\n        contentNotChanged && (0,util.each)(lastIndices, function (lastIdxItem, j) {\n          var newIdxItem = newIndices[j];\n          contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex;\n        });\n        // check is cbParams data value changed\n        lastCbParamsList && (0,util.each)(lastItem.seriesDataIndices, function (idxItem) {\n          var seriesIdx = idxItem.seriesIndex;\n          var cbParams = cbParamsList[seriesIdx];\n          var lastCbParams = lastCbParamsList[seriesIdx];\n          if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {\n            contentNotChanged = false;\n          }\n        });\n      });\n    });\n    this._lastDataByCoordSys = dataByCoordSys;\n    this._cbParamsList = cbParamsList;\n    return !!contentNotChanged;\n  };\n  TooltipView.prototype._hide = function (dispatchAction) {\n    // Do not directly hideLater here, because this behavior may be prevented\n    // in dispatchAction when showTip is dispatched.\n    // FIXME\n    // duplicated hideTip if manuallyHideTip is called from dispatchAction.\n    this._lastDataByCoordSys = null;\n    dispatchAction({\n      type: 'hideTip',\n      from: this.uid\n    });\n  };\n  TooltipView.prototype.dispose = function (ecModel, api) {\n    if (env/* default */.A.node || !api.getDom()) {\n      return;\n    }\n    (0,throttle/* clear */.IU)(this, '_updatePosition');\n    this._tooltipContent.dispose();\n    globalListener/* unregister */.h('itemTooltip', api);\n  };\n  TooltipView.type = 'tooltip';\n  return TooltipView;\n}(view_Component/* default */.A);\n/**\r\n * From top to bottom. (the last one should be globalTooltipModel);\r\n */\nfunction buildTooltipModel(modelCascade, globalTooltipModel, defaultTooltipOption) {\n  // Last is always tooltip model.\n  var ecModel = globalTooltipModel.ecModel;\n  var resultModel;\n  if (defaultTooltipOption) {\n    resultModel = new Model/* default */.A(defaultTooltipOption, ecModel, ecModel);\n    resultModel = new Model/* default */.A(globalTooltipModel.option, resultModel, ecModel);\n  } else {\n    resultModel = globalTooltipModel;\n  }\n  for (var i = modelCascade.length - 1; i >= 0; i--) {\n    var tooltipOpt = modelCascade[i];\n    if (tooltipOpt) {\n      if (tooltipOpt instanceof Model/* default */.A) {\n        tooltipOpt = tooltipOpt.get('tooltip', true);\n      }\n      // In each data item tooltip can be simply write:\n      // {\n      //  value: 10,\n      //  tooltip: 'Something you need to know'\n      // }\n      if ((0,util.isString)(tooltipOpt)) {\n        tooltipOpt = {\n          formatter: tooltipOpt\n        };\n      }\n      if (tooltipOpt) {\n        resultModel = new Model/* default */.A(tooltipOpt, resultModel, ecModel);\n      }\n    }\n  }\n  return resultModel;\n}\nfunction makeDispatchAction(payload, api) {\n  return payload.dispatchAction || (0,util.bind)(api.dispatchAction, api);\n}\nfunction refixTooltipPosition(x, y, content, viewWidth, viewHeight, gapH, gapV) {\n  var size = content.getSize();\n  var width = size[0];\n  var height = size[1];\n  if (gapH != null) {\n    // Add extra 2 pixels for this case:\n    // At present the \"values\" in default tooltip are using CSS `float: right`.\n    // When the right edge of the tooltip box is on the right side of the\n    // viewport, the `float` layout might push the \"values\" to the second line.\n    if (x + width + gapH + 2 > viewWidth) {\n      x -= width + gapH;\n    } else {\n      x += gapH;\n    }\n  }\n  if (gapV != null) {\n    if (y + height + gapV > viewHeight) {\n      y -= height + gapV;\n    } else {\n      y += gapV;\n    }\n  }\n  return [x, y];\n}\nfunction confineTooltipPosition(x, y, content, viewWidth, viewHeight) {\n  var size = content.getSize();\n  var width = size[0];\n  var height = size[1];\n  x = Math.min(x + width, viewWidth) - width;\n  y = Math.min(y + height, viewHeight) - height;\n  x = Math.max(x, 0);\n  y = Math.max(y, 0);\n  return [x, y];\n}\nfunction calcTooltipPosition(position, rect, contentSize, borderWidth) {\n  var domWidth = contentSize[0];\n  var domHeight = contentSize[1];\n  var offset = Math.ceil(Math.SQRT2 * borderWidth) + 8;\n  var x = 0;\n  var y = 0;\n  var rectWidth = rect.width;\n  var rectHeight = rect.height;\n  switch (position) {\n    case 'inside':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n    case 'top':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y - domHeight - offset;\n      break;\n    case 'bottom':\n      x = rect.x + rectWidth / 2 - domWidth / 2;\n      y = rect.y + rectHeight + offset;\n      break;\n    case 'left':\n      x = rect.x - domWidth - offset;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n      break;\n    case 'right':\n      x = rect.x + rectWidth + offset;\n      y = rect.y + rectHeight / 2 - domHeight / 2;\n  }\n  return [x, y];\n}\nfunction isCenterAlign(align) {\n  return align === 'center' || align === 'middle';\n}\n/**\r\n * Find target component by payload like:\r\n * ```js\r\n * { legendId: 'some_id', name: 'xxx' }\r\n * { toolboxIndex: 1, name: 'xxx' }\r\n * { geoName: 'some_name', name: 'xxx' }\r\n * ```\r\n * PENDING: at present only\r\n *\r\n * If not found, return null/undefined.\r\n */\nfunction findComponentReference(payload, ecModel, api) {\n  var queryOptionMap = (0,util_model/* preParseFinder */.HB)(payload).queryOptionMap;\n  var componentMainType = queryOptionMap.keys()[0];\n  if (!componentMainType || componentMainType === 'series') {\n    return;\n  }\n  var queryResult = (0,util_model/* queryReferringComponents */.JO)(ecModel, componentMainType, queryOptionMap.get(componentMainType), {\n    useDefault: false,\n    enableAll: false,\n    enableNone: false\n  });\n  var model = queryResult.models[0];\n  if (!model) {\n    return;\n  }\n  var view = api.getViewOfComponentModel(model);\n  var el;\n  view.group.traverse(function (subEl) {\n    var tooltipConfig = (0,innerStore/* getECData */.z)(subEl).tooltipConfig;\n    if (tooltipConfig && tooltipConfig.name === payload.name) {\n      el = subEl;\n      return true; // stop\n    }\n  });\n  if (el) {\n    return {\n      componentMainType: componentMainType,\n      componentIndex: model.componentIndex,\n      el: el\n    };\n  }\n}\n/* harmony default export */ const tooltip_TooltipView = (TooltipView);\n;// ./node_modules/echarts/lib/component/tooltip/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nfunction install_install(registers) {\n  (0,extension/* use */.Y)(install/* install */.a);\n  registers.registerComponentModel(tooltip_TooltipModel);\n  registers.registerComponentView(tooltip_TooltipView);\n  /**\r\n   * @action\r\n   * @property {string} type\r\n   * @property {number} seriesIndex\r\n   * @property {number} dataIndex\r\n   * @property {number} [x]\r\n   * @property {number} [y]\r\n   */\n  registers.registerAction({\n    type: 'showTip',\n    event: 'showTip',\n    update: 'tooltip:manuallyShowTip'\n  }, util.noop);\n  registers.registerAction({\n    type: 'hideTip',\n    event: 'hideTip',\n    update: 'tooltip:manuallyHideTip'\n  }, util.noop);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjY0MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FDL1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcE1vZGVsLmpzPzRkOWQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL2hlbHBlci5qcz9kMzY0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdG9vbHRpcC9Ub29sdGlwSFRNTENvbnRlbnQuanM/ZDhjYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Rvb2x0aXAvVG9vbHRpcFJpY2hDb250ZW50LmpzPzdlNzQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL1Rvb2x0aXBWaWV3LmpzPzljNzUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90b29sdGlwL2luc3RhbGwuanM/NmU2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG52YXIgVG9vbHRpcE1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRvb2x0aXBNb2RlbCwgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVG9vbHRpcE1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBUb29sdGlwTW9kZWwudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgVG9vbHRpcE1vZGVsLnR5cGUgPSAndG9vbHRpcCc7XG4gIFRvb2x0aXBNb2RlbC5kZXBlbmRlbmNpZXMgPSBbJ2F4aXNQb2ludGVyJ107XG4gIFRvb2x0aXBNb2RlbC5kZWZhdWx0T3B0aW9uID0ge1xuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiA2MCxcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIHRvb2x0aXAgbWFpbiBjb250ZW50XG4gICAgc2hvd0NvbnRlbnQ6IHRydWUsXG4gICAgLy8gJ3RyaWdnZXInIG9ubHkgd29ya3Mgb24gY29vcmRpbmF0ZSBzeXN0ZW0uXG4gICAgLy8gJ2l0ZW0nIHwgJ2F4aXMnIHwgJ25vbmUnXG4gICAgdHJpZ2dlcjogJ2l0ZW0nLFxuICAgIC8vICdjbGljaycgfCAnbW91c2Vtb3ZlJyB8ICdub25lJ1xuICAgIHRyaWdnZXJPbjogJ21vdXNlbW92ZXxjbGljaycsXG4gICAgYWx3YXlzU2hvd0NvbnRlbnQ6IGZhbHNlLFxuICAgIGRpc3BsYXlNb2RlOiAnc2luZ2xlJyxcbiAgICByZW5kZXJNb2RlOiAnYXV0bycsXG4gICAgLy8gd2hldGhlciByZXN0cmFpbnQgY29udGVudCBpbnNpZGUgdmlld1JlY3QuXG4gICAgLy8gSWYgcmVuZGVyTW9kZTogJ3JpY2hUZXh0JywgZGVmYXVsdCB0cnVlLlxuICAgIC8vIElmIHJlbmRlck1vZGU6ICdodG1sJywgZGVmYXV0IGZhbHNlIChmb3IgYmFja3dhcmQgY29tcGF0KS5cbiAgICBjb25maW5lOiBudWxsLFxuICAgIHNob3dEZWxheTogMCxcbiAgICBoaWRlRGVsYXk6IDEwMCxcbiAgICAvLyBBbmltYXRpb24gdHJhbnNpdGlvbiB0aW1lLCB1bml0IGlzIHNlY29uZFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogMC40LFxuICAgIGVudGVyYWJsZTogZmFsc2UsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnI2ZmZicsXG4gICAgLy8gYm94IHNoYWRvd1xuICAgIHNoYWRvd0JsdXI6IDEwLFxuICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLCAwLCAwLCAuMiknLFxuICAgIHNoYWRvd09mZnNldFg6IDEsXG4gICAgc2hhZG93T2Zmc2V0WTogMixcbiAgICAvLyB0b29sdGlwIGJvcmRlciByYWRpdXMsIHVuaXQgaXMgcHgsIGRlZmF1bHQgaXMgNFxuICAgIGJvcmRlclJhZGl1czogNCxcbiAgICAvLyB0b29sdGlwIGJvcmRlciB3aWR0aCwgdW5pdCBpcyBweCwgZGVmYXVsdCBpcyAwIChubyBib3JkZXIpXG4gICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgLy8gVG9vbHRpcCBpbnNpZGUgcGFkZGluZywgZGVmYXVsdCBpcyA1IGZvciBhbGwgZGlyZWN0aW9uXG4gICAgLy8gQXJyYXkgaXMgYWxsb3dlZCB0byBzZXQgdXAsIHJpZ2h0LCBib3R0b20sIGxlZnQsIHNhbWUgd2l0aCBjc3NcbiAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZTogU2VlIGB0b29sdGlwL3Rvb2x0aXBNYXJrdXAudHMjZ2V0UGFkZGluZ0Zyb21Ub29sdGlwTW9kZWxgLlxuICAgIHBhZGRpbmc6IG51bGwsXG4gICAgLy8gRXh0cmEgY3NzIHRleHRcbiAgICBleHRyYUNzc1RleHQ6ICcnLFxuICAgIC8vIGF4aXMgaW5kaWNhdG9yLCB0cmlnZ2VyIGJ5IGF4aXNcbiAgICBheGlzUG9pbnRlcjoge1xuICAgICAgLy8gZGVmYXVsdCBpcyBsaW5lXG4gICAgICAvLyBsZWdhbCB2YWx1ZXM6ICdsaW5lJyB8ICdzaGFkb3cnIHwgJ2Nyb3NzJ1xuICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgLy8gVmFsaWQgd2hlbiB0eXBlIGlzIGxpbmUsIGFwcG9pbnQgdG9vbHRpcCBsaW5lIGxvY2F0ZSBvbiB3aGljaCBsaW5lLiBPcHRpb25hbFxuICAgICAgLy8gbGVnYWwgdmFsdWVzOiAneCcgfCAneScgfCAnYW5nbGUnIHwgJ3JhZGl1cycgfCAnYXV0bydcbiAgICAgIC8vIGRlZmF1bHQgaXMgJ2F1dG8nLCBjaG9zZSB0aGUgYXhpcyB3aGljaCB0eXBlIGlzIGNhdGVnb3J5LlxuICAgICAgLy8gZm9yIG11bHRpcGx5IHkgYXhpcywgY2FydGVzaWFuIGNvb3JkIGNob3NlIHggYXhpcywgcG9sYXIgY2hvc2UgYW5nbGUgYXhpc1xuICAgICAgYXhpczogJ2F1dG8nLFxuICAgICAgYW5pbWF0aW9uOiAnYXV0bycsXG4gICAgICBhbmltYXRpb25EdXJhdGlvblVwZGF0ZTogMjAwLFxuICAgICAgYW5pbWF0aW9uRWFzaW5nVXBkYXRlOiAnZXhwb25lbnRpYWxPdXQnLFxuICAgICAgY3Jvc3NTdHlsZToge1xuICAgICAgICBjb2xvcjogJyM5OTknLFxuICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgdHlwZTogJ2Rhc2hlZCcsXG4gICAgICAgIC8vIFRPRE8gZm9ybWF0dGVyXG4gICAgICAgIHRleHRTdHlsZToge31cbiAgICAgIH1cbiAgICAgIC8vIGxpbmVTdHlsZSBhbmQgc2hhZG93U3R5bGUgc2hvdWxkIG5vdCBiZSBzcGVjaWZpZWQgaGVyZSxcbiAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGFsd2F5cyBvdmVycmlkZSB0aG9zZSBzdHlsZXMgb24gb3B0aW9uLmF4aXNQb2ludGVyLlxuICAgIH0sXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBjb2xvcjogJyM2NjYnLFxuICAgICAgZm9udFNpemU6IDE0XG4gICAgfVxuICB9O1xuICByZXR1cm4gVG9vbHRpcE1vZGVsO1xufShDb21wb25lbnRNb2RlbCk7XG5leHBvcnQgZGVmYXVsdCBUb29sdGlwTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyB0b0NhbWVsQ2FzZSB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LmpzJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuLyogZ2xvYmFsIGRvY3VtZW50ICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVG9vbHRpcENvbmZpbmUodG9vbHRpcE1vZGVsKSB7XG4gIHZhciBjb25maW5lT3B0aW9uID0gdG9vbHRpcE1vZGVsLmdldCgnY29uZmluZScpO1xuICByZXR1cm4gY29uZmluZU9wdGlvbiAhPSBudWxsID8gISFjb25maW5lT3B0aW9uXG4gIC8vIEluIHJpY2hUZXh0IG1vZGUsIHRoZSBvdXRzaWRlIHBhcnQgY2FuIG5vdCBiZSB2aXNpYmxlLlxuICA6IHRvb2x0aXBNb2RlbC5nZXQoJ3JlbmRlck1vZGUnKSA9PT0gJ3JpY2hUZXh0Jztcbn1cbmZ1bmN0aW9uIHRlc3RTdHlsZShzdHlsZVByb3BzKSB7XG4gIGlmICghZW52LmRvbVN1cHBvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHlsZVByb3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKHN0eWxlUHJvcHNbaV0gaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBzdHlsZVByb3BzW2ldO1xuICAgIH1cbiAgfVxufVxuZXhwb3J0IHZhciBUUkFOU0ZPUk1fVkVORE9SID0gdGVzdFN0eWxlKFsndHJhbnNmb3JtJywgJ3dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcbmV4cG9ydCB2YXIgVFJBTlNJVElPTl9WRU5ET1IgPSB0ZXN0U3R5bGUoWyd3ZWJraXRUcmFuc2l0aW9uJywgJ3RyYW5zaXRpb24nLCAnT1RyYW5zaXRpb24nLCAnTW96VHJhbnNpdGlvbicsICdtc1RyYW5zaXRpb24nXSk7XG5leHBvcnQgZnVuY3Rpb24gdG9DU1NWZW5kb3JQcmVmaXgoc3R5bGVWZW5kb3IsIHN0eWxlUHJvcCkge1xuICBpZiAoIXN0eWxlVmVuZG9yKSB7XG4gICAgcmV0dXJuIHN0eWxlUHJvcDtcbiAgfVxuICBzdHlsZVByb3AgPSB0b0NhbWVsQ2FzZShzdHlsZVByb3AsIHRydWUpO1xuICB2YXIgaWR4ID0gc3R5bGVWZW5kb3IuaW5kZXhPZihzdHlsZVByb3ApO1xuICBzdHlsZVZlbmRvciA9IGlkeCA9PT0gLTEgPyBzdHlsZVByb3AgOiBcIi1cIiArIHN0eWxlVmVuZG9yLnNsaWNlKDAsIGlkeCkgKyBcIi1cIiArIHN0eWxlUHJvcDtcbiAgcmV0dXJuIHN0eWxlVmVuZG9yLnRvTG93ZXJDYXNlKCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbCwgc3R5bGUpIHtcbiAgdmFyIHN0bCA9IGVsLmN1cnJlbnRTdHlsZSB8fCBkb2N1bWVudC5kZWZhdWx0VmlldyAmJiBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgcmV0dXJuIHN0bCA/IHN0eWxlID8gc3RsW3N0eWxlXSA6IHN0bCA6IG51bGw7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBpc1N0cmluZywgaW5kZXhPZiwgZWFjaCwgYmluZCwgaXNGdW5jdGlvbiwgaXNBcnJheSwgaXNEb20sIHJldHJpZXZlMiB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVFdmVudCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMnO1xuaW1wb3J0IHsgdHJhbnNmb3JtTG9jYWxDb29yZCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZG9tLmpzJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuaW1wb3J0IHsgY29udmVydFRvQ29sb3JTdHJpbmcsIHRvQ2FtZWxDYXNlLCBub3JtYWxpemVDc3NBcnJheSB9IGZyb20gJy4uLy4uL3V0aWwvZm9ybWF0LmpzJztcbmltcG9ydCB7IHNob3VsZFRvb2x0aXBDb25maW5lLCB0b0NTU1ZlbmRvclByZWZpeCwgZ2V0Q29tcHV0ZWRTdHlsZSwgVFJBTlNGT1JNX1ZFTkRPUiwgVFJBTlNJVElPTl9WRU5ET1IgfSBmcm9tICcuL2hlbHBlci5qcyc7XG5pbXBvcnQgeyBnZXRQYWRkaW5nRnJvbVRvb2x0aXBNb2RlbCB9IGZyb20gJy4vdG9vbHRpcE1hcmt1cC5qcyc7XG4vKiBnbG9iYWwgZG9jdW1lbnQsIHdpbmRvdyAqL1xudmFyIENTU19UUkFOU0lUSU9OX1ZFTkRPUiA9IHRvQ1NTVmVuZG9yUHJlZml4KFRSQU5TSVRJT05fVkVORE9SLCAndHJhbnNpdGlvbicpO1xudmFyIENTU19UUkFOU0ZPUk1fVkVORE9SID0gdG9DU1NWZW5kb3JQcmVmaXgoVFJBTlNGT1JNX1ZFTkRPUiwgJ3RyYW5zZm9ybScpO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG52YXIgZ0Nzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2Rpc3BsYXk6YmxvY2s7Ym9yZGVyLXN0eWxlOnNvbGlkO3doaXRlLXNwYWNlOm5vd3JhcDt6LWluZGV4Ojk5OTk5OTk7XCIgKyAoZW52LnRyYW5zZm9ybTNkU3VwcG9ydGVkID8gJ3dpbGwtY2hhbmdlOnRyYW5zZm9ybTsnIDogJycpO1xuZnVuY3Rpb24gbWlycm9yUG9zKHBvcykge1xuICBwb3MgPSBwb3MgPT09ICdsZWZ0JyA/ICdyaWdodCcgOiBwb3MgPT09ICdyaWdodCcgPyAnbGVmdCcgOiBwb3MgPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJztcbiAgcmV0dXJuIHBvcztcbn1cbmZ1bmN0aW9uIGFzc2VtYmxlQXJyb3codG9vbHRpcE1vZGVsLCBib3JkZXJDb2xvciwgYXJyb3dQb3NpdGlvbikge1xuICBpZiAoIWlzU3RyaW5nKGFycm93UG9zaXRpb24pIHx8IGFycm93UG9zaXRpb24gPT09ICdpbnNpZGUnKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdiYWNrZ3JvdW5kQ29sb3InKTtcbiAgdmFyIGJvcmRlcldpZHRoID0gdG9vbHRpcE1vZGVsLmdldCgnYm9yZGVyV2lkdGgnKTtcbiAgYm9yZGVyQ29sb3IgPSBjb252ZXJ0VG9Db2xvclN0cmluZyhib3JkZXJDb2xvcik7XG4gIHZhciBhcnJvd1BvcyA9IG1pcnJvclBvcyhhcnJvd1Bvc2l0aW9uKTtcbiAgdmFyIGFycm93U2l6ZSA9IE1hdGgubWF4KE1hdGgucm91bmQoYm9yZGVyV2lkdGgpICogMS41LCA2KTtcbiAgdmFyIHBvc2l0aW9uU3R5bGUgPSAnJztcbiAgdmFyIHRyYW5zZm9ybVN0eWxlID0gQ1NTX1RSQU5TRk9STV9WRU5ET1IgKyAnOic7XG4gIHZhciByb3RhdGVEZWc7XG4gIGlmIChpbmRleE9mKFsnbGVmdCcsICdyaWdodCddLCBhcnJvd1BvcykgPiAtMSkge1xuICAgIHBvc2l0aW9uU3R5bGUgKz0gJ3RvcDo1MCUnO1xuICAgIHRyYW5zZm9ybVN0eWxlICs9IFwidHJhbnNsYXRlWSgtNTAlKSByb3RhdGUoXCIgKyAocm90YXRlRGVnID0gYXJyb3dQb3MgPT09ICdsZWZ0JyA/IC0yMjUgOiAtNDUpICsgXCJkZWcpXCI7XG4gIH0gZWxzZSB7XG4gICAgcG9zaXRpb25TdHlsZSArPSAnbGVmdDo1MCUnO1xuICAgIHRyYW5zZm9ybVN0eWxlICs9IFwidHJhbnNsYXRlWCgtNTAlKSByb3RhdGUoXCIgKyAocm90YXRlRGVnID0gYXJyb3dQb3MgPT09ICd0b3AnID8gMjI1IDogNDUpICsgXCJkZWcpXCI7XG4gIH1cbiAgdmFyIHJvdGF0ZVJhZGlhbiA9IHJvdGF0ZURlZyAqIE1hdGguUEkgLyAxODA7XG4gIHZhciBhcnJvd1dIID0gYXJyb3dTaXplICsgYm9yZGVyV2lkdGg7XG4gIHZhciByb3RhdGVkV0ggPSBhcnJvd1dIICogTWF0aC5hYnMoTWF0aC5jb3Mocm90YXRlUmFkaWFuKSkgKyBhcnJvd1dIICogTWF0aC5hYnMoTWF0aC5zaW4ocm90YXRlUmFkaWFuKSk7XG4gIHZhciBhcnJvd09mZnNldCA9IE1hdGgucm91bmQoKChyb3RhdGVkV0ggLSBNYXRoLlNRUlQyICogYm9yZGVyV2lkdGgpIC8gMiArIE1hdGguU1FSVDIgKiBib3JkZXJXaWR0aCAtIChyb3RhdGVkV0ggLSBhcnJvd1dIKSAvIDIpICogMTAwKSAvIDEwMDtcbiAgcG9zaXRpb25TdHlsZSArPSBcIjtcIiArIGFycm93UG9zICsgXCI6LVwiICsgYXJyb3dPZmZzZXQgKyBcInB4XCI7XG4gIHZhciBib3JkZXJTdHlsZSA9IGJvcmRlckNvbG9yICsgXCIgc29saWQgXCIgKyBib3JkZXJXaWR0aCArIFwicHg7XCI7XG4gIHZhciBzdHlsZUNzcyA9IFtcInBvc2l0aW9uOmFic29sdXRlO3dpZHRoOlwiICsgYXJyb3dTaXplICsgXCJweDtoZWlnaHQ6XCIgKyBhcnJvd1NpemUgKyBcInB4O3otaW5kZXg6LTE7XCIsIHBvc2l0aW9uU3R5bGUgKyBcIjtcIiArIHRyYW5zZm9ybVN0eWxlICsgXCI7XCIsIFwiYm9yZGVyLWJvdHRvbTpcIiArIGJvcmRlclN0eWxlLCBcImJvcmRlci1yaWdodDpcIiArIGJvcmRlclN0eWxlLCBcImJhY2tncm91bmQtY29sb3I6XCIgKyBiYWNrZ3JvdW5kQ29sb3IgKyBcIjtcIl07XG4gIHJldHVybiBcIjxkaXYgc3R5bGU9XFxcIlwiICsgc3R5bGVDc3Muam9pbignJykgKyBcIlxcXCI+PC9kaXY+XCI7XG59XG5mdW5jdGlvbiBhc3NlbWJsZVRyYW5zaXRpb24oZHVyYXRpb24sIG9ubHlGYWRlKSB7XG4gIHZhciB0cmFuc2l0aW9uQ3VydmUgPSAnY3ViaWMtYmV6aWVyKDAuMjMsMSwwLjMyLDEpJztcbiAgdmFyIHRyYW5zaXRpb25PcHRpb24gPSBcIiBcIiArIGR1cmF0aW9uIC8gMiArIFwicyBcIiArIHRyYW5zaXRpb25DdXJ2ZTtcbiAgdmFyIHRyYW5zaXRpb25UZXh0ID0gXCJvcGFjaXR5XCIgKyB0cmFuc2l0aW9uT3B0aW9uICsgXCIsdmlzaWJpbGl0eVwiICsgdHJhbnNpdGlvbk9wdGlvbjtcbiAgaWYgKCFvbmx5RmFkZSkge1xuICAgIHRyYW5zaXRpb25PcHRpb24gPSBcIiBcIiArIGR1cmF0aW9uICsgXCJzIFwiICsgdHJhbnNpdGlvbkN1cnZlO1xuICAgIHRyYW5zaXRpb25UZXh0ICs9IGVudi50cmFuc2Zvcm1TdXBwb3J0ZWQgPyBcIixcIiArIENTU19UUkFOU0ZPUk1fVkVORE9SICsgdHJhbnNpdGlvbk9wdGlvbiA6IFwiLGxlZnRcIiArIHRyYW5zaXRpb25PcHRpb24gKyBcIix0b3BcIiArIHRyYW5zaXRpb25PcHRpb247XG4gIH1cbiAgcmV0dXJuIENTU19UUkFOU0lUSU9OX1ZFTkRPUiArICc6JyArIHRyYW5zaXRpb25UZXh0O1xufVxuZnVuY3Rpb24gYXNzZW1ibGVUcmFuc2Zvcm0oeCwgeSwgdG9TdHJpbmcpIHtcbiAgLy8gSWYgdXNpbmcgZmxvYXQgb24gc3R5bGUsIHRoZSBmaW5hbCB3aWR0aCBvZiB0aGUgZG9tIG1pZ2h0XG4gIC8vIGtlZXAgY2hhbmdpbmcgc2xpZ2h0bHkgd2hpbGUgbW91c2UgbW92ZS4gU28gYHRvRml4ZWQoMClgIHRoZW0uXG4gIHZhciB4MCA9IHgudG9GaXhlZCgwKSArICdweCc7XG4gIHZhciB5MCA9IHkudG9GaXhlZCgwKSArICdweCc7XG4gIC8vIG5vdCBzdXBwb3J0IHRyYW5zZm9ybSwgdXNlIGBsZWZ0YCBhbmQgYHRvcGAgaW5zdGVhZC5cbiAgaWYgKCFlbnYudHJhbnNmb3JtU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nID8gXCJ0b3A6XCIgKyB5MCArIFwiO2xlZnQ6XCIgKyB4MCArIFwiO1wiIDogW1sndG9wJywgeTBdLCBbJ2xlZnQnLCB4MF1dO1xuICB9XG4gIC8vIHN1cHBvcnQgdHJhbnNmb3JtXG4gIHZhciBpczNkID0gZW52LnRyYW5zZm9ybTNkU3VwcG9ydGVkO1xuICB2YXIgdHJhbnNsYXRlID0gXCJ0cmFuc2xhdGVcIiArIChpczNkID8gJzNkJyA6ICcnKSArIFwiKFwiICsgeDAgKyBcIixcIiArIHkwICsgKGlzM2QgPyAnLDAnIDogJycpICsgXCIpXCI7XG4gIHJldHVybiB0b1N0cmluZyA/ICd0b3A6MDtsZWZ0OjA7JyArIENTU19UUkFOU0ZPUk1fVkVORE9SICsgJzonICsgdHJhbnNsYXRlICsgJzsnIDogW1sndG9wJywgMF0sIFsnbGVmdCcsIDBdLCBbVFJBTlNGT1JNX1ZFTkRPUiwgdHJhbnNsYXRlXV07XG59XG4vKipcclxuICogQHBhcmFtIHtPYmplY3R9IHRleHRTdHlsZVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9XHJcbiAqIEBpbm5lclxyXG4gKi9cbmZ1bmN0aW9uIGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkge1xuICB2YXIgY3NzVGV4dCA9IFtdO1xuICB2YXIgZm9udFNpemUgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ2ZvbnRTaXplJyk7XG4gIHZhciBjb2xvciA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuICBjb2xvciAmJiBjc3NUZXh0LnB1c2goJ2NvbG9yOicgKyBjb2xvcik7XG4gIGNzc1RleHQucHVzaCgnZm9udDonICsgdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpKTtcbiAgLy8gQHRzLWlnbm9yZSwgbGVhdmUgaXQgdG8gdGhlIHRvb2x0aXAgcmVmYWN0b3IuXG4gIHZhciBsaW5lSGVpZ2h0ID0gcmV0cmlldmUyKHRleHRTdHlsZU1vZGVsLmdldCgnbGluZUhlaWdodCcpLCBNYXRoLnJvdW5kKGZvbnRTaXplICogMyAvIDIpKTtcbiAgZm9udFNpemUgJiYgY3NzVGV4dC5wdXNoKCdsaW5lLWhlaWdodDonICsgbGluZUhlaWdodCArICdweCcpO1xuICB2YXIgc2hhZG93Q29sb3IgPSB0ZXh0U3R5bGVNb2RlbC5nZXQoJ3RleHRTaGFkb3dDb2xvcicpO1xuICB2YXIgc2hhZG93Qmx1ciA9IHRleHRTdHlsZU1vZGVsLmdldCgndGV4dFNoYWRvd0JsdXInKSB8fCAwO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IHRleHRTdHlsZU1vZGVsLmdldCgndGV4dFNoYWRvd09mZnNldFgnKSB8fCAwO1xuICB2YXIgc2hhZG93T2Zmc2V0WSA9IHRleHRTdHlsZU1vZGVsLmdldCgndGV4dFNoYWRvd09mZnNldFknKSB8fCAwO1xuICBzaGFkb3dDb2xvciAmJiBzaGFkb3dCbHVyICYmIGNzc1RleHQucHVzaCgndGV4dC1zaGFkb3c6JyArIHNoYWRvd09mZnNldFggKyAncHggJyArIHNoYWRvd09mZnNldFkgKyAncHggJyArIHNoYWRvd0JsdXIgKyAncHggJyArIHNoYWRvd0NvbG9yKTtcbiAgZWFjaChbJ2RlY29yYXRpb24nLCAnYWxpZ24nXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgdmFsID0gdGV4dFN0eWxlTW9kZWwuZ2V0KG5hbWUpO1xuICAgIHZhbCAmJiBjc3NUZXh0LnB1c2goJ3RleHQtJyArIG5hbWUgKyAnOicgKyB2YWwpO1xuICB9KTtcbiAgcmV0dXJuIGNzc1RleHQuam9pbignOycpO1xufVxuZnVuY3Rpb24gYXNzZW1ibGVDc3NUZXh0KHRvb2x0aXBNb2RlbCwgZW5hYmxlVHJhbnNpdGlvbiwgb25seUZhZGUpIHtcbiAgdmFyIGNzc1RleHQgPSBbXTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyYW5zaXRpb25EdXJhdGlvbicpO1xuICB2YXIgYmFja2dyb3VuZENvbG9yID0gdG9vbHRpcE1vZGVsLmdldCgnYmFja2dyb3VuZENvbG9yJyk7XG4gIHZhciBzaGFkb3dCbHVyID0gdG9vbHRpcE1vZGVsLmdldCgnc2hhZG93Qmx1cicpO1xuICB2YXIgc2hhZG93Q29sb3IgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaGFkb3dDb2xvcicpO1xuICB2YXIgc2hhZG93T2Zmc2V0WCA9IHRvb2x0aXBNb2RlbC5nZXQoJ3NoYWRvd09mZnNldFgnKTtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSB0b29sdGlwTW9kZWwuZ2V0KCdzaGFkb3dPZmZzZXRZJyk7XG4gIHZhciB0ZXh0U3R5bGVNb2RlbCA9IHRvb2x0aXBNb2RlbC5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gIHZhciBwYWRkaW5nID0gZ2V0UGFkZGluZ0Zyb21Ub29sdGlwTW9kZWwodG9vbHRpcE1vZGVsLCAnaHRtbCcpO1xuICB2YXIgYm94U2hhZG93ID0gc2hhZG93T2Zmc2V0WCArIFwicHggXCIgKyBzaGFkb3dPZmZzZXRZICsgXCJweCBcIiArIHNoYWRvd0JsdXIgKyBcInB4IFwiICsgc2hhZG93Q29sb3I7XG4gIGNzc1RleHQucHVzaCgnYm94LXNoYWRvdzonICsgYm94U2hhZG93KTtcbiAgLy8gQW5pbWF0aW9uIHRyYW5zaXRpb24uIERvIG5vdCBhbmltYXRlIHdoZW4gdHJhbnNpdGlvbkR1cmF0aW9uIGlzIDAuXG4gIGVuYWJsZVRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbkR1cmF0aW9uICYmIGNzc1RleHQucHVzaChhc3NlbWJsZVRyYW5zaXRpb24odHJhbnNpdGlvbkR1cmF0aW9uLCBvbmx5RmFkZSkpO1xuICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgY3NzVGV4dC5wdXNoKCdiYWNrZ3JvdW5kLWNvbG9yOicgKyBiYWNrZ3JvdW5kQ29sb3IpO1xuICB9XG4gIC8vIEJvcmRlciBzdHlsZVxuICBlYWNoKFsnd2lkdGgnLCAnY29sb3InLCAncmFkaXVzJ10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGJvcmRlck5hbWUgPSAnYm9yZGVyLScgKyBuYW1lO1xuICAgIHZhciBjYW1lbENhc2UgPSB0b0NhbWVsQ2FzZShib3JkZXJOYW1lKTtcbiAgICB2YXIgdmFsID0gdG9vbHRpcE1vZGVsLmdldChjYW1lbENhc2UpO1xuICAgIHZhbCAhPSBudWxsICYmIGNzc1RleHQucHVzaChib3JkZXJOYW1lICsgJzonICsgdmFsICsgKG5hbWUgPT09ICdjb2xvcicgPyAnJyA6ICdweCcpKTtcbiAgfSk7XG4gIC8vIFRleHQgc3R5bGVcbiAgY3NzVGV4dC5wdXNoKGFzc2VtYmxlRm9udCh0ZXh0U3R5bGVNb2RlbCkpO1xuICAvLyBQYWRkaW5nXG4gIGlmIChwYWRkaW5nICE9IG51bGwpIHtcbiAgICBjc3NUZXh0LnB1c2goJ3BhZGRpbmc6JyArIG5vcm1hbGl6ZUNzc0FycmF5KHBhZGRpbmcpLmpvaW4oJ3B4ICcpICsgJ3B4Jyk7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQuam9pbignOycpICsgJzsnO1xufVxuLy8gSWYgbm90IGFibGUgdG8gbWFrZSwgZG8gbm90IG1vZGlmeSB0aGUgaW5wdXQgYG91dGAuXG5mdW5jdGlvbiBtYWtlU3R5bGVDb29yZChvdXQsIHpyLCBjb250YWluZXIsIHpyWCwgenJZKSB7XG4gIHZhciB6clBhaW50ZXIgPSB6ciAmJiB6ci5wYWludGVyO1xuICBpZiAoY29udGFpbmVyKSB7XG4gICAgdmFyIHpyVmlld3BvcnRSb290ID0genJQYWludGVyICYmIHpyUGFpbnRlci5nZXRWaWV3cG9ydFJvb3QoKTtcbiAgICBpZiAoenJWaWV3cG9ydFJvb3QpIHtcbiAgICAgIC8vIFNvbWUgQVBQcyBtaWdodCB1c2Ugc2NhbGUgb24gYm9keSwgc28gd2Ugc3VwcG9ydCBDU1MgdHJhbnNmb3JtIGhlcmUuXG4gICAgICB0cmFuc2Zvcm1Mb2NhbENvb3JkKG91dCwgenJWaWV3cG9ydFJvb3QsIGNvbnRhaW5lciwgenJYLCB6clkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBvdXRbMF0gPSB6clg7XG4gICAgb3V0WzFdID0genJZO1xuICAgIC8vIHh5IHNob3VsZCBiZSBiYXNlZCBvbiBjYW52YXMgcm9vdC4gQnV0IHRvb2x0aXBDb250ZW50IGlzXG4gICAgLy8gdGhlIHNpYmxpbmcgb2YgY2FudmFzIHJvb3QuIFNvIHBhZGRpbmcgb2YgZWMgY29udGFpbmVyXG4gICAgLy8gc2hvdWxkIGJlIGNvbnNpZGVyZWQgaGVyZS5cbiAgICB2YXIgdmlld3BvcnRSb290T2Zmc2V0ID0genJQYWludGVyICYmIHpyUGFpbnRlci5nZXRWaWV3cG9ydFJvb3RPZmZzZXQoKTtcbiAgICBpZiAodmlld3BvcnRSb290T2Zmc2V0KSB7XG4gICAgICBvdXRbMF0gKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldExlZnQ7XG4gICAgICBvdXRbMV0gKz0gdmlld3BvcnRSb290T2Zmc2V0Lm9mZnNldFRvcDtcbiAgICB9XG4gIH1cbiAgb3V0WzJdID0gb3V0WzBdIC8genIuZ2V0V2lkdGgoKTtcbiAgb3V0WzNdID0gb3V0WzFdIC8genIuZ2V0SGVpZ2h0KCk7XG59XG52YXIgVG9vbHRpcEhUTUxDb250ZW50ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVG9vbHRpcEhUTUxDb250ZW50KGFwaSwgb3B0KSB7XG4gICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgIHRoaXMuX3N0eWxlQ29vcmQgPSBbMCwgMCwgMCwgMF07XG4gICAgdGhpcy5fZW50ZXJhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpcnN0U2hvdyA9IHRydWU7XG4gICAgdGhpcy5fbG9uZ0hpZGUgPSB0cnVlO1xuICAgIGlmIChlbnYud3hhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgLy8gVE9ETzogVFlQRVxuICAgIGVsLmRvbUJlbG9uZ1RvWnIgPSB0cnVlO1xuICAgIHRoaXMuZWwgPSBlbDtcbiAgICB2YXIgenIgPSB0aGlzLl96ciA9IGFwaS5nZXRacigpO1xuICAgIHZhciBhcHBlbmRUbyA9IG9wdC5hcHBlbmRUbztcbiAgICB2YXIgY29udGFpbmVyID0gYXBwZW5kVG8gJiYgKGlzU3RyaW5nKGFwcGVuZFRvKSA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYXBwZW5kVG8pIDogaXNEb20oYXBwZW5kVG8pID8gYXBwZW5kVG8gOiBpc0Z1bmN0aW9uKGFwcGVuZFRvKSAmJiBhcHBlbmRUbyhhcGkuZ2V0RG9tKCkpKTtcbiAgICBtYWtlU3R5bGVDb29yZCh0aGlzLl9zdHlsZUNvb3JkLCB6ciwgY29udGFpbmVyLCBhcGkuZ2V0V2lkdGgoKSAvIDIsIGFwaS5nZXRIZWlnaHQoKSAvIDIpO1xuICAgIChjb250YWluZXIgfHwgYXBpLmdldERvbSgpKS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdGhpcy5fYXBpID0gYXBpO1xuICAgIHRoaXMuX2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAvLyBGSVhNRVxuICAgIC8vIElzIGl0IG5lZWRlZCB0byB0cmlnZ2VyIHpyIGV2ZW50IG1hbnVhbGx5IGlmXG4gICAgLy8gdGhlIGJyb3dzZXIgZG8gbm90IHN1cHBvcnQgYHBvaW50ZXItZXZlbnRzOiBub25lYC5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgZWwub25tb3VzZWVudGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgICBzZWxmLl9zaG93ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuX2luQ29udGVudCA9IHRydWU7XG4gICAgfTtcbiAgICBlbC5vbm1vdXNlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICBlID0gZSB8fCB3aW5kb3cuZXZlbnQ7XG4gICAgICBpZiAoIXNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICAvLyBgcG9pbnRlci1ldmVudHM6IG5vbmVgIGlzIHNldCB0byB0b29sdGlwIGNvbnRlbnQgZGl2XG4gICAgICAgIC8vIGlmIGBlbnRlcmFibGVgIGlzIHNldCBhcyBgZmFsc2VgLCBhbmQgYGVsLm9ubW91c2Vtb3ZlYFxuICAgICAgICAvLyBjYW4gbm90IGJlIHRyaWdnZXJlZC4gQnV0IGluIGJyb3dzZXIgdGhhdCBkbyBub3RcbiAgICAgICAgLy8gc3VwcG9ydCBgcG9pbnRlci1ldmVudHNgLCB3ZSBuZWVkIHRvIGRvIHRoaXM6XG4gICAgICAgIC8vIFRyeSB0cmlnZ2VyIHpyZW5kZXIgZXZlbnQgdG8gYXZvaWQgbW91c2VcbiAgICAgICAgLy8gaW4gYW5kIG91dCBzaGFwZSB0b28gZnJlcXVlbnRseVxuICAgICAgICB2YXIgaGFuZGxlciA9IHpyLmhhbmRsZXI7XG4gICAgICAgIHZhciB6clZpZXdwb3J0Um9vdCA9IHpyLnBhaW50ZXIuZ2V0Vmlld3BvcnRSb290KCk7XG4gICAgICAgIG5vcm1hbGl6ZUV2ZW50KHpyVmlld3BvcnRSb290LCBlLCB0cnVlKTtcbiAgICAgICAgaGFuZGxlci5kaXNwYXRjaCgnbW91c2Vtb3ZlJywgZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBlbC5vbm1vdXNlbGVhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBzZXQgYF9pbkNvbnRlbnRgIHRvIGBmYWxzZWAgYmVmb3JlIGBoaWRlTGF0ZXJgXG4gICAgICBzZWxmLl9pbkNvbnRlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChzZWxmLl9lbnRlcmFibGUpIHtcbiAgICAgICAgaWYgKHNlbGYuX3Nob3cpIHtcbiAgICAgICAgICBzZWxmLmhpZGVMYXRlcihzZWxmLl9oaWRlRGVsYXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXHJcbiAgICovXG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gTW92ZSB0aGlzIGxvZ2ljIHRvIGVjIG1haW4/XG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9hcGkuZ2V0RG9tKCk7XG4gICAgICB2YXIgcG9zaXRpb24gPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XG4gICAgICB2YXIgZG9tU3R5bGUgPSBjb250YWluZXIuc3R5bGU7XG4gICAgICBpZiAoZG9tU3R5bGUucG9zaXRpb24gIT09ICdhYnNvbHV0ZScgJiYgcG9zaXRpb24gIT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgZG9tU3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBtb3ZlIHRvb2x0aXAgaWYgY2hhcnQgcmVzaXplZFxuICAgIHZhciBhbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG4gICAgYWx3YXlzU2hvd0NvbnRlbnQgJiYgdGhpcy5fbW92ZUlmUmVzaXplZCgpO1xuICAgIC8vIHVwZGF0ZSBhbHdheXNTaG93Q29udGVudFxuICAgIHRoaXMuX2Fsd2F5c1Nob3dDb250ZW50ID0gYWx3YXlzU2hvd0NvbnRlbnQ7XG4gICAgLy8gdXBkYXRlIGNsYXNzTmFtZVxuICAgIHRoaXMuZWwuY2xhc3NOYW1lID0gdG9vbHRpcE1vZGVsLmdldCgnY2xhc3NOYW1lJykgfHwgJyc7XG4gICAgLy8gSGlkZSB0aGUgdG9vbHRpcFxuICAgIC8vIFBFTkRJTkdcbiAgICAvLyB0aGlzLmhpZGUoKTtcbiAgfTtcbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgbmVhclBvaW50Q29sb3IpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5faGlkZVRpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9sb25nSGlkZVRpbWVvdXQpO1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gICAgdmFyIHN0eWxlQ29vcmQgPSB0aGlzLl9zdHlsZUNvb3JkO1xuICAgIGlmICghZWwuaW5uZXJIVE1MKSB7XG4gICAgICBzdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZS5jc3NUZXh0ID0gZ0Nzc1RleHQgKyBhc3NlbWJsZUNzc1RleHQodG9vbHRpcE1vZGVsLCAhdGhpcy5fZmlyc3RTaG93LCB0aGlzLl9sb25nSGlkZSlcbiAgICAgIC8vIGluaXRpYWwgdHJhbnNmb3JtXG4gICAgICArIGFzc2VtYmxlVHJhbnNmb3JtKHN0eWxlQ29vcmRbMF0sIHN0eWxlQ29vcmRbMV0sIHRydWUpICsgKFwiYm9yZGVyLWNvbG9yOlwiICsgY29udmVydFRvQ29sb3JTdHJpbmcobmVhclBvaW50Q29sb3IpICsgXCI7XCIpICsgKHRvb2x0aXBNb2RlbC5nZXQoJ2V4dHJhQ3NzVGV4dCcpIHx8ICcnKVxuICAgICAgLy8gSWYgbW91c2Ugb2NjYXNpb25hbGx5IG1vdmUgb3ZlciB0aGUgdG9vbHRpcCwgYSBtb3VzZW91dCBldmVudCB3aWxsIGJlXG4gICAgICAvLyB0cmlnZ2VyZWQgYnkgY2FudmFzLCBhbmQgY2F1c2Ugc29tZSB1bmV4cGVjdGFibGUgcmVzdWx0IGxpa2UgZHJhZ2dpbmdcbiAgICAgIC8vIHN0b3AsIFwidW5mb2N1c0FkamFjZW5jeVwiLiBIZXJlIGBwb2ludGVyLWV2ZW50czogbm9uZWAgaXMgdXNlZCB0byBzb2x2ZVxuICAgICAgLy8gaXQuIEFsdGhvdWdoIGl0IGlzIG5vdCBzdXBwb3J0ZWQgYnkgSUU4fklFMTAsIGZvcnR1bmF0ZWx5IGl0IGlzIGEgcmFyZVxuICAgICAgLy8gc2NlbmFyaW8uXG4gICAgICArIChcIjtwb2ludGVyLWV2ZW50czpcIiArICh0aGlzLl9lbnRlcmFibGUgPyAnYXV0bycgOiAnbm9uZScpKTtcbiAgICB9XG4gICAgdGhpcy5fc2hvdyA9IHRydWU7XG4gICAgdGhpcy5fZmlyc3RTaG93ID0gZmFsc2U7XG4gICAgdGhpcy5fbG9uZ0hpZGUgPSBmYWxzZTtcbiAgfTtcbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5zZXRDb250ZW50ID0gZnVuY3Rpb24gKGNvbnRlbnQsIG1hcmtlcnMsIHRvb2x0aXBNb2RlbCwgYm9yZGVyQ29sb3IsIGFycm93UG9zaXRpb24pIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGlmIChjb250ZW50ID09IG51bGwpIHtcbiAgICAgIGVsLmlubmVySFRNTCA9ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgYXJyb3cgPSAnJztcbiAgICBpZiAoaXNTdHJpbmcoYXJyb3dQb3NpdGlvbikgJiYgdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlcicpID09PSAnaXRlbScgJiYgIXNob3VsZFRvb2x0aXBDb25maW5lKHRvb2x0aXBNb2RlbCkpIHtcbiAgICAgIGFycm93ID0gYXNzZW1ibGVBcnJvdyh0b29sdGlwTW9kZWwsIGJvcmRlckNvbG9yLCBhcnJvd1Bvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKGlzU3RyaW5nKGNvbnRlbnQpKSB7XG4gICAgICBlbC5pbm5lckhUTUwgPSBjb250ZW50ICsgYXJyb3c7XG4gICAgfSBlbHNlIGlmIChjb250ZW50KSB7XG4gICAgICAvLyBDbGVhciBwcmV2aW91c1xuICAgICAgZWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICBpZiAoIWlzQXJyYXkoY29udGVudCkpIHtcbiAgICAgICAgY29udGVudCA9IFtjb250ZW50XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNEb20oY29udGVudFtpXSkgJiYgY29udGVudFtpXS5wYXJlbnROb2RlICE9PSBlbCkge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGNvbnRlbnRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBubyBhcnJvdyBpZiBlbXB0eVxuICAgICAgaWYgKGFycm93ICYmIGVsLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gY3JlYXRlIGEgbmV3IHBhcmVudCBlbGVtZW50LCBidXQgaXQncyBub3Qgc3VwcG9ydGVkIGJ5IElFIDEwIGFuZCBvbGRlci5cbiAgICAgICAgLy8gY29uc3QgYXJyb3dFbCA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGFycm93KTtcbiAgICAgICAgdmFyIGFycm93RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYXJyb3dFbC5pbm5lckhUTUwgPSBhcnJvdztcbiAgICAgICAgZWwuYXBwZW5kQ2hpbGQoYXJyb3dFbCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLnNldEVudGVyYWJsZSA9IGZ1bmN0aW9uIChlbnRlcmFibGUpIHtcbiAgICB0aGlzLl9lbnRlcmFibGUgPSBlbnRlcmFibGU7XG4gIH07XG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIHJldHVybiBlbCA/IFtlbC5vZmZzZXRXaWR0aCwgZWwub2Zmc2V0SGVpZ2h0XSA6IFswLCAwXTtcbiAgfTtcbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbiAoenJYLCB6clkpIHtcbiAgICBpZiAoIXRoaXMuZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0eWxlQ29vcmQgPSB0aGlzLl9zdHlsZUNvb3JkO1xuICAgIG1ha2VTdHlsZUNvb3JkKHN0eWxlQ29vcmQsIHRoaXMuX3pyLCB0aGlzLl9jb250YWluZXIsIHpyWCwgenJZKTtcbiAgICBpZiAoc3R5bGVDb29yZFswXSAhPSBudWxsICYmIHN0eWxlQ29vcmRbMV0gIT0gbnVsbCkge1xuICAgICAgdmFyIHN0eWxlXzEgPSB0aGlzLmVsLnN0eWxlO1xuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBhc3NlbWJsZVRyYW5zZm9ybShzdHlsZUNvb3JkWzBdLCBzdHlsZUNvb3JkWzFdKTtcbiAgICAgIGVhY2godHJhbnNmb3JtcywgZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgICBzdHlsZV8xW3RyYW5zZm9ybVswXV0gPSB0cmFuc2Zvcm1bMV07XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIHdoZW4gYGFsd2F5c1Nob3dDb250ZW50YCBpcyB0cnVlLFxyXG4gICAqIG1vdmUgdGhlIHRvb2x0aXAgYWZ0ZXIgY2hhcnQgcmVzaXplZFxyXG4gICAqL1xuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLl9tb3ZlSWZSZXNpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSByYXRpbyBvZiBsZWZ0IHRvIHdpZHRoXG4gICAgdmFyIHJhdGlvWCA9IHRoaXMuX3N0eWxlQ29vcmRbMl07XG4gICAgLy8gVGhlIHJhdGlvIG9mIHRvcCB0byBoZWlnaHRcbiAgICB2YXIgcmF0aW9ZID0gdGhpcy5fc3R5bGVDb29yZFszXTtcbiAgICB0aGlzLm1vdmVUbyhyYXRpb1ggKiB0aGlzLl96ci5nZXRXaWR0aCgpLCByYXRpb1kgKiB0aGlzLl96ci5nZXRIZWlnaHQoKSk7XG4gIH07XG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuZWwuc3R5bGU7XG4gICAgc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgIHN0eWxlLm9wYWNpdHkgPSAnMCc7XG4gICAgZW52LnRyYW5zZm9ybTNkU3VwcG9ydGVkICYmIChzdHlsZS53aWxsQ2hhbmdlID0gJycpO1xuICAgIHRoaXMuX3Nob3cgPSBmYWxzZTtcbiAgICB0aGlzLl9sb25nSGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5fbG9uZ0hpZGUgPSB0cnVlO1xuICAgIH0sIDUwMCk7XG4gIH07XG4gIFRvb2x0aXBIVE1MQ29udGVudC5wcm90b3R5cGUuaGlkZUxhdGVyID0gZnVuY3Rpb24gKHRpbWUpIHtcbiAgICBpZiAodGhpcy5fc2hvdyAmJiAhKHRoaXMuX2luQ29udGVudCAmJiB0aGlzLl9lbnRlcmFibGUpICYmICF0aGlzLl9hbHdheXNTaG93Q29udGVudCkge1xuICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgdGhpcy5faGlkZURlbGF5ID0gdGltZTtcbiAgICAgICAgLy8gU2V0IHNob3cgZmFsc2UgdG8gYXZvaWQgaW52b2tlIGhpZGVMYXRlciBtdWx0aXBsZSB0aW1lc1xuICAgICAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2hpZGVUaW1lb3V0ID0gc2V0VGltZW91dChiaW5kKHRoaXMuaGlkZSwgdGhpcyksIHRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBUb29sdGlwSFRNTENvbnRlbnQucHJvdG90eXBlLmlzU2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2hvdztcbiAgfTtcbiAgVG9vbHRpcEhUTUxDb250ZW50LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2xvbmdIaWRlVGltZW91dCk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsLnBhcmVudE5vZGU7XG4gICAgcGFyZW50Tm9kZSAmJiBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWwpO1xuICAgIHRoaXMuZWwgPSB0aGlzLl9jb250YWluZXIgPSBudWxsO1xuICB9O1xuICByZXR1cm4gVG9vbHRpcEhUTUxDb250ZW50O1xufSgpO1xuZXhwb3J0IGRlZmF1bHQgVG9vbHRpcEhUTUxDb250ZW50OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgWlJUZXh0IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvVGV4dC5qcyc7XG5pbXBvcnQgeyBnZXRQYWRkaW5nRnJvbVRvb2x0aXBNb2RlbCB9IGZyb20gJy4vdG9vbHRpcE1hcmt1cC5qcyc7XG5pbXBvcnQgeyB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xudmFyIFRvb2x0aXBSaWNoQ29udGVudCA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXBSaWNoQ29udGVudChhcGkpIHtcbiAgICB0aGlzLl9zaG93ID0gZmFsc2U7XG4gICAgdGhpcy5fc3R5bGVDb29yZCA9IFswLCAwLCAwLCAwXTtcbiAgICB0aGlzLl9hbHdheXNTaG93Q29udGVudCA9IGZhbHNlO1xuICAgIHRoaXMuX2VudGVyYWJsZSA9IHRydWU7XG4gICAgdGhpcy5fenIgPSBhcGkuZ2V0WnIoKTtcbiAgICBtYWtlU3R5bGVDb29yZCh0aGlzLl9zdHlsZUNvb3JkLCB0aGlzLl96ciwgYXBpLmdldFdpZHRoKCkgLyAyLCBhcGkuZ2V0SGVpZ2h0KCkgLyAyKTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgd2hlbiB0b29sdGlwIGlzIHJlbmRlcmVkXHJcbiAgICovXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCkge1xuICAgIHZhciBhbHdheXNTaG93Q29udGVudCA9IHRvb2x0aXBNb2RlbC5nZXQoJ2Fsd2F5c1Nob3dDb250ZW50Jyk7XG4gICAgYWx3YXlzU2hvd0NvbnRlbnQgJiYgdGhpcy5fbW92ZUlmUmVzaXplZCgpO1xuICAgIC8vIHVwZGF0ZSBhbHdheXNTaG93Q29udGVudFxuICAgIHRoaXMuX2Fsd2F5c1Nob3dDb250ZW50ID0gYWx3YXlzU2hvd0NvbnRlbnQ7XG4gIH07XG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5faGlkZVRpbWVvdXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9oaWRlVGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuZWwuc2hvdygpO1xuICAgIHRoaXMuX3Nob3cgPSB0cnVlO1xuICB9O1xuICAvKipcclxuICAgKiBTZXQgdG9vbHRpcCBjb250ZW50XHJcbiAgICovXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIChjb250ZW50LCBtYXJrdXBTdHlsZUNyZWF0b3IsIHRvb2x0aXBNb2RlbCwgYm9yZGVyQ29sb3IsIGFycm93UG9zaXRpb24pIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIGlmICh6clV0aWwuaXNPYmplY3QoY29udGVudCkpIHtcbiAgICAgIHRocm93RXJyb3IocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICdQYXNzaW5nIERPTSBub2RlcyBhcyBjb250ZW50IGlzIG5vdCBzdXBwb3J0ZWQgaW4gcmljaFRleHQgdG9vbHRpcCEnIDogJycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5lbCkge1xuICAgICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZWwpO1xuICAgIH1cbiAgICB2YXIgdGV4dFN0eWxlTW9kZWwgPSB0b29sdGlwTW9kZWwuZ2V0TW9kZWwoJ3RleHRTdHlsZScpO1xuICAgIHRoaXMuZWwgPSBuZXcgWlJUZXh0KHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHJpY2g6IG1hcmt1cFN0eWxlQ3JlYXRvci5yaWNoVGV4dFN0eWxlcyxcbiAgICAgICAgdGV4dDogY29udGVudCxcbiAgICAgICAgbGluZUhlaWdodDogMjIsXG4gICAgICAgIGJvcmRlcldpZHRoOiAxLFxuICAgICAgICBib3JkZXJDb2xvcjogYm9yZGVyQ29sb3IsXG4gICAgICAgIHRleHRTaGFkb3dDb2xvcjogdGV4dFN0eWxlTW9kZWwuZ2V0KCd0ZXh0U2hhZG93Q29sb3InKSxcbiAgICAgICAgZmlsbDogdG9vbHRpcE1vZGVsLmdldChbJ3RleHRTdHlsZScsICdjb2xvciddKSxcbiAgICAgICAgcGFkZGluZzogZ2V0UGFkZGluZ0Zyb21Ub29sdGlwTW9kZWwodG9vbHRpcE1vZGVsLCAncmljaFRleHQnKSxcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICAgIGFsaWduOiAnbGVmdCdcbiAgICAgIH0sXG4gICAgICB6OiB0b29sdGlwTW9kZWwuZ2V0KCd6JylcbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaChbJ2JhY2tncm91bmRDb2xvcicsICdib3JkZXJSYWRpdXMnLCAnc2hhZG93Q29sb3InLCAnc2hhZG93Qmx1cicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknXSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICBfdGhpcy5lbC5zdHlsZVtwcm9wTmFtZV0gPSB0b29sdGlwTW9kZWwuZ2V0KHByb3BOYW1lKTtcbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaChbJ3RleHRTaGFkb3dCbHVyJywgJ3RleHRTaGFkb3dPZmZzZXRYJywgJ3RleHRTaGFkb3dPZmZzZXRZJ10sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgICAgX3RoaXMuZWwuc3R5bGVbcHJvcE5hbWVdID0gdGV4dFN0eWxlTW9kZWwuZ2V0KHByb3BOYW1lKSB8fCAwO1xuICAgIH0pO1xuICAgIHRoaXMuX3pyLmFkZCh0aGlzLmVsKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5lbC5vbignbW91c2VvdmVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gY2xlYXIgdGhlIHRpbWVvdXQgaW4gaGlkZUxhdGVyIGFuZCBrZWVwIHNob3dpbmcgdG9vbHRpcFxuICAgICAgaWYgKHNlbGYuX2VudGVyYWJsZSkge1xuICAgICAgICBjbGVhclRpbWVvdXQoc2VsZi5faGlkZVRpbWVvdXQpO1xuICAgICAgICBzZWxmLl9zaG93ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNlbGYuX2luQ29udGVudCA9IHRydWU7XG4gICAgfSk7XG4gICAgdGhpcy5lbC5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2VsZi5fZW50ZXJhYmxlKSB7XG4gICAgICAgIGlmIChzZWxmLl9zaG93KSB7XG4gICAgICAgICAgc2VsZi5oaWRlTGF0ZXIoc2VsZi5faGlkZURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2VsZi5faW5Db250ZW50ID0gZmFsc2U7XG4gICAgfSk7XG4gIH07XG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuc2V0RW50ZXJhYmxlID0gZnVuY3Rpb24gKGVudGVyYWJsZSkge1xuICAgIHRoaXMuX2VudGVyYWJsZSA9IGVudGVyYWJsZTtcbiAgfTtcbiAgVG9vbHRpcFJpY2hDb250ZW50LnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlbCA9IHRoaXMuZWw7XG4gICAgdmFyIGJvdW5kaW5nID0gdGhpcy5lbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAvLyBib3VuZGluZyByZWN0IGRvZXMgbm90IGluY2x1ZGUgc2hhZG93LiBGb3IgcmVuZGVyTW9kZSByaWNoVGV4dCxcbiAgICAvLyBpZiBvdmVyZmxvdywgaXQgd2lsbCBiZSBjdXQuIFNvIGNhbGN1bGF0ZSB0aGVtIGFjY3VyYXRlbHkuXG4gICAgdmFyIHNoYWRvd091dGVyU2l6ZSA9IGNhbGNTaGFkb3dPdXRlclNpemUoZWwuc3R5bGUpO1xuICAgIHJldHVybiBbYm91bmRpbmcud2lkdGggKyBzaGFkb3dPdXRlclNpemUubGVmdCArIHNoYWRvd091dGVyU2l6ZS5yaWdodCwgYm91bmRpbmcuaGVpZ2h0ICsgc2hhZG93T3V0ZXJTaXplLnRvcCArIHNoYWRvd091dGVyU2l6ZS5ib3R0b21dO1xuICB9O1xuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbDtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBzdHlsZUNvb3JkID0gdGhpcy5fc3R5bGVDb29yZDtcbiAgICAgIG1ha2VTdHlsZUNvb3JkKHN0eWxlQ29vcmQsIHRoaXMuX3pyLCB4LCB5KTtcbiAgICAgIHggPSBzdHlsZUNvb3JkWzBdO1xuICAgICAgeSA9IHN0eWxlQ29vcmRbMV07XG4gICAgICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IG1hdGhNYXhXaXRoMChzdHlsZS5ib3JkZXJXaWR0aCB8fCAwKTtcbiAgICAgIHZhciBzaGFkb3dPdXRlclNpemUgPSBjYWxjU2hhZG93T3V0ZXJTaXplKHN0eWxlKTtcbiAgICAgIC8vIHJpY2ggdGV4dCB4LCB5IGRvIG5vdCBpbmNsdWRlIGJvcmRlci5cbiAgICAgIGVsLnggPSB4ICsgYm9yZGVyV2lkdGggKyBzaGFkb3dPdXRlclNpemUubGVmdDtcbiAgICAgIGVsLnkgPSB5ICsgYm9yZGVyV2lkdGggKyBzaGFkb3dPdXRlclNpemUudG9wO1xuICAgICAgZWwubWFya1JlZHJhdygpO1xuICAgIH1cbiAgfTtcbiAgLyoqXHJcbiAgICogd2hlbiBgYWx3YXlzU2hvd0NvbnRlbnRgIGlzIHRydWUsXHJcbiAgICogbW92ZSB0aGUgdG9vbHRpcCBhZnRlciBjaGFydCByZXNpemVkXHJcbiAgICovXG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuX21vdmVJZlJlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHJhdGlvIG9mIGxlZnQgdG8gd2lkdGhcbiAgICB2YXIgcmF0aW9YID0gdGhpcy5fc3R5bGVDb29yZFsyXTtcbiAgICAvLyBUaGUgcmF0aW8gb2YgdG9wIHRvIGhlaWdodFxuICAgIHZhciByYXRpb1kgPSB0aGlzLl9zdHlsZUNvb3JkWzNdO1xuICAgIHRoaXMubW92ZVRvKHJhdGlvWCAqIHRoaXMuX3pyLmdldFdpZHRoKCksIHJhdGlvWSAqIHRoaXMuX3pyLmdldEhlaWdodCgpKTtcbiAgfTtcbiAgVG9vbHRpcFJpY2hDb250ZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmVsKSB7XG4gICAgICB0aGlzLmVsLmhpZGUoKTtcbiAgICB9XG4gICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICB9O1xuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLmhpZGVMYXRlciA9IGZ1bmN0aW9uICh0aW1lKSB7XG4gICAgaWYgKHRoaXMuX3Nob3cgJiYgISh0aGlzLl9pbkNvbnRlbnQgJiYgdGhpcy5fZW50ZXJhYmxlKSAmJiAhdGhpcy5fYWx3YXlzU2hvd0NvbnRlbnQpIHtcbiAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgIHRoaXMuX2hpZGVEZWxheSA9IHRpbWU7XG4gICAgICAgIC8vIFNldCBzaG93IGZhbHNlIHRvIGF2b2lkIGludm9rZSBoaWRlTGF0ZXIgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgdGhpcy5fc2hvdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9oaWRlVGltZW91dCA9IHNldFRpbWVvdXQoenJVdGlsLmJpbmQodGhpcy5oaWRlLCB0aGlzKSwgdGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFRvb2x0aXBSaWNoQ29udGVudC5wcm90b3R5cGUuaXNTaG93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93O1xuICB9O1xuICBUb29sdGlwUmljaENvbnRlbnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fenIucmVtb3ZlKHRoaXMuZWwpO1xuICB9O1xuICByZXR1cm4gVG9vbHRpcFJpY2hDb250ZW50O1xufSgpO1xuZnVuY3Rpb24gbWF0aE1heFdpdGgwKHZhbCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdmFsKTtcbn1cbmZ1bmN0aW9uIGNhbGNTaGFkb3dPdXRlclNpemUoc3R5bGUpIHtcbiAgdmFyIHNoYWRvd0JsdXIgPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93Qmx1ciB8fCAwKTtcbiAgdmFyIHNoYWRvd09mZnNldFggPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCAwKTtcbiAgdmFyIHNoYWRvd09mZnNldFkgPSBtYXRoTWF4V2l0aDAoc3R5bGUuc2hhZG93T2Zmc2V0WSB8fCAwKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBtYXRoTWF4V2l0aDAoc2hhZG93Qmx1ciAtIHNoYWRvd09mZnNldFgpLFxuICAgIHJpZ2h0OiBtYXRoTWF4V2l0aDAoc2hhZG93Qmx1ciArIHNoYWRvd09mZnNldFgpLFxuICAgIHRvcDogbWF0aE1heFdpdGgwKHNoYWRvd0JsdXIgLSBzaGFkb3dPZmZzZXRZKSxcbiAgICBib3R0b206IG1hdGhNYXhXaXRoMChzaGFkb3dCbHVyICsgc2hhZG93T2Zmc2V0WSlcbiAgfTtcbn1cbmZ1bmN0aW9uIG1ha2VTdHlsZUNvb3JkKG91dCwgenIsIHpyWCwgenJZKSB7XG4gIG91dFswXSA9IHpyWDtcbiAgb3V0WzFdID0genJZO1xuICBvdXRbMl0gPSBvdXRbMF0gLyB6ci5nZXRXaWR0aCgpO1xuICBvdXRbM10gPSBvdXRbMV0gLyB6ci5nZXRIZWlnaHQoKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBSaWNoQ29udGVudDsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgYmluZCwgZWFjaCwgY2xvbmUsIHRyaW0sIGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBpc0FycmF5LCBpc09iamVjdCwgZXh0ZW5kIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBlbnYgZnJvbSAnenJlbmRlci9saWIvY29yZS9lbnYuanMnO1xuaW1wb3J0IFRvb2x0aXBIVE1MQ29udGVudCBmcm9tICcuL1Rvb2x0aXBIVE1MQ29udGVudC5qcyc7XG5pbXBvcnQgVG9vbHRpcFJpY2hDb250ZW50IGZyb20gJy4vVG9vbHRpcFJpY2hDb250ZW50LmpzJztcbmltcG9ydCB7IGNvbnZlcnRUb0NvbG9yU3RyaW5nLCBlbmNvZGVIVE1MLCBmb3JtYXRUcGwgfSBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgeyBwYXJzZVBlcmNlbnQgfSBmcm9tICcuLi8uLi91dGlsL251bWJlci5qcyc7XG5pbXBvcnQgeyBSZWN0IH0gZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCBmaW5kUG9pbnRGcm9tU2VyaWVzIGZyb20gJy4uL2F4aXNQb2ludGVyL2ZpbmRQb2ludEZyb21TZXJpZXMuanMnO1xuaW1wb3J0IHsgZ2V0TGF5b3V0UmVjdCB9IGZyb20gJy4uLy4uL3V0aWwvbGF5b3V0LmpzJztcbmltcG9ydCBNb2RlbCBmcm9tICcuLi8uLi9tb2RlbC9Nb2RlbC5qcyc7XG5pbXBvcnQgKiBhcyBnbG9iYWxMaXN0ZW5lciBmcm9tICcuLi9heGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lci5qcyc7XG5pbXBvcnQgKiBhcyBheGlzSGVscGVyIGZyb20gJy4uLy4uL2Nvb3JkL2F4aXNIZWxwZXIuanMnO1xuaW1wb3J0ICogYXMgYXhpc1BvaW50ZXJWaWV3SGVscGVyIGZyb20gJy4uL2F4aXNQb2ludGVyL3ZpZXdIZWxwZXIuanMnO1xuaW1wb3J0IHsgZ2V0VG9vbHRpcFJlbmRlck1vZGUsIHByZVBhcnNlRmluZGVyLCBxdWVyeVJlZmVycmluZ0NvbXBvbmVudHMgfSBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCBDb21wb25lbnRWaWV3IGZyb20gJy4uLy4uL3ZpZXcvQ29tcG9uZW50LmpzJztcbmltcG9ydCB7IGZvcm1hdCBhcyB0aW1lRm9ybWF0IH0gZnJvbSAnLi4vLi4vdXRpbC90aW1lLmpzJztcbmltcG9ydCB7IGdldEVDRGF0YSB9IGZyb20gJy4uLy4uL3V0aWwvaW5uZXJTdG9yZS5qcyc7XG5pbXBvcnQgeyBzaG91bGRUb29sdGlwQ29uZmluZSB9IGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCB7IG5vcm1hbGl6ZVRvb2x0aXBGb3JtYXRSZXN1bHQgfSBmcm9tICcuLi8uLi9tb2RlbC9taXhpbi9kYXRhRm9ybWF0LmpzJztcbmltcG9ydCB7IGNyZWF0ZVRvb2x0aXBNYXJrdXAsIGJ1aWxkVG9vbHRpcE1hcmt1cCwgVG9vbHRpcE1hcmt1cFN0eWxlQ3JlYXRvciB9IGZyb20gJy4vdG9vbHRpcE1hcmt1cC5qcyc7XG5pbXBvcnQgeyBmaW5kRXZlbnREaXNwYXRjaGVyIH0gZnJvbSAnLi4vLi4vdXRpbC9ldmVudC5qcyc7XG5pbXBvcnQgeyBjbGVhciwgY3JlYXRlT3JVcGRhdGUgfSBmcm9tICcuLi8uLi91dGlsL3Rocm90dGxlLmpzJztcbnZhciBwcm94eVJlY3QgPSBuZXcgUmVjdCh7XG4gIHNoYXBlOiB7XG4gICAgeDogLTEsXG4gICAgeTogLTEsXG4gICAgd2lkdGg6IDIsXG4gICAgaGVpZ2h0OiAyXG4gIH1cbn0pO1xudmFyIFRvb2x0aXBWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFRvb2x0aXBWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBUb29sdGlwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVG9vbHRpcFZpZXcudHlwZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgaWYgKGVudi5ub2RlIHx8ICFhcGkuZ2V0RG9tKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KCd0b29sdGlwJyk7XG4gICAgdmFyIHJlbmRlck1vZGUgPSB0aGlzLl9yZW5kZXJNb2RlID0gZ2V0VG9vbHRpcFJlbmRlck1vZGUodG9vbHRpcE1vZGVsLmdldCgncmVuZGVyTW9kZScpKTtcbiAgICB0aGlzLl90b29sdGlwQ29udGVudCA9IHJlbmRlck1vZGUgPT09ICdyaWNoVGV4dCcgPyBuZXcgVG9vbHRpcFJpY2hDb250ZW50KGFwaSkgOiBuZXcgVG9vbHRpcEhUTUxDb250ZW50KGFwaSwge1xuICAgICAgYXBwZW5kVG86IHRvb2x0aXBNb2RlbC5nZXQoJ2FwcGVuZFRvQm9keScsIHRydWUpID8gJ2JvZHknIDogdG9vbHRpcE1vZGVsLmdldCgnYXBwZW5kVG8nLCB0cnVlKVxuICAgIH0pO1xuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpKSB7XG4gICAgaWYgKGVudi5ub2RlIHx8ICFhcGkuZ2V0RG9tKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVzZXRcbiAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMuX3Rvb2x0aXBNb2RlbCA9IHRvb2x0aXBNb2RlbDtcbiAgICB0aGlzLl9lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLl9hcGkgPSBhcGk7XG4gICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG4gICAgdG9vbHRpcENvbnRlbnQudXBkYXRlKHRvb2x0aXBNb2RlbCk7XG4gICAgdG9vbHRpcENvbnRlbnQuc2V0RW50ZXJhYmxlKHRvb2x0aXBNb2RlbC5nZXQoJ2VudGVyYWJsZScpKTtcbiAgICB0aGlzLl9pbml0R2xvYmFsTGlzdGVuZXIoKTtcbiAgICB0aGlzLl9rZWVwU2hvdygpO1xuICAgIC8vIFBFTkRJTkdcbiAgICAvLyBgbW91c2Vtb3ZlYCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCB2ZXJ5IGZyZXF1ZW50bHkgd2hlbiB0aGUgbW91c2UgbW92ZXMgZmFzdCxcbiAgICAvLyB3aGljaCBjYXVzZXMgdGhhdCB0aGUgYHVwZGF0ZVBvc2l0aW9uYCBmdW5jdGlvbiB3YXMgYWxzbyBjYWxsZWQgZnJlcXVlbnRseS5cbiAgICAvLyBJbiBDaHJvbWUgd2l0aCBkZXZ0b29scyBvcGVuIGFuZCBGaXJlZm94LCB0b29sdGlwIGxvb2tzIGxhZ2d5IGFuZCBzaGFrZXMuIFNlZSAjMTQ2OTUgIzE2MTAxXG4gICAgLy8gVG8gYXZvaWQgZnJlcXVlbnQgdHJpZ2dlcmluZyxcbiAgICAvLyBjb25zaWRlciB0aHJvdHRsaW5nIGl0IGluIDUwbXMgd2hlbiB0cmFuc2l0aW9uIGlzIGVuYWJsZWRcbiAgICBpZiAodGhpcy5fcmVuZGVyTW9kZSAhPT0gJ3JpY2hUZXh0JyAmJiB0b29sdGlwTW9kZWwuZ2V0KCd0cmFuc2l0aW9uRHVyYXRpb24nKSkge1xuICAgICAgY3JlYXRlT3JVcGRhdGUodGhpcywgJ191cGRhdGVQb3NpdGlvbicsIDUwLCAnZml4UmF0ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhcih0aGlzLCAnX3VwZGF0ZVBvc2l0aW9uJyk7XG4gICAgfVxuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX2luaXRHbG9iYWxMaXN0ZW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciB0cmlnZ2VyT24gPSB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyT24nKTtcbiAgICBnbG9iYWxMaXN0ZW5lci5yZWdpc3RlcignaXRlbVRvb2x0aXAnLCB0aGlzLl9hcGksIGJpbmQoZnVuY3Rpb24gKGN1cnJUcmlnZ2VyLCBlLCBkaXNwYXRjaEFjdGlvbikge1xuICAgICAgLy8gSWYgJ25vbmUnLCBpdCBpcyBub3QgY29udHJvbGxlZCBieSBtb3VzZSB0b3RhbGx5LlxuICAgICAgaWYgKHRyaWdnZXJPbiAhPT0gJ25vbmUnKSB7XG4gICAgICAgIGlmICh0cmlnZ2VyT24uaW5kZXhPZihjdXJyVHJpZ2dlcikgPj0gMCkge1xuICAgICAgICAgIHRoaXMuX3RyeVNob3coZSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJUcmlnZ2VyID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB0aGlzKSk7XG4gIH07XG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fa2VlcFNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRvb2x0aXBNb2RlbCA9IHRoaXMuX3Rvb2x0aXBNb2RlbDtcbiAgICB2YXIgZWNNb2RlbCA9IHRoaXMuX2VjTW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuX2FwaTtcbiAgICB2YXIgdHJpZ2dlck9uID0gdG9vbHRpcE1vZGVsLmdldCgndHJpZ2dlck9uJyk7XG4gICAgLy8gVHJ5IHRvIGtlZXAgdGhlIHRvb2x0aXAgc2hvdyB3aGVuIHJlZnJlc2hpbmdcbiAgICBpZiAodGhpcy5fbGFzdFggIT0gbnVsbCAmJiB0aGlzLl9sYXN0WSAhPSBudWxsXG4gICAgLy8gV2hlbiB1c2VyIGlzIHdpbGxpbmcgdG8gY29udHJvbCB0b29sdGlwIHRvdGFsbHkgdXNpbmcgQVBJLFxuICAgIC8vIHNlbGYubWFudWFsbHlTaG93VGlwKHt4LCB5fSkgbWlnaHQgY2F1c2UgdG9vbHRpcCBoaWRlLFxuICAgIC8vIHdoaWNoIGlzIG5vdCBleHBlY3RlZC5cbiAgICAmJiB0cmlnZ2VyT24gIT09ICdub25lJyAmJiB0cmlnZ2VyT24gIT09ICdjbGljaycpIHtcbiAgICAgIHZhciBzZWxmXzEgPSB0aGlzO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0KTtcbiAgICAgIHRoaXMuX3JlZnJlc2hVcGRhdGVUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFNob3cgdGlwIG5leHQgdGljayBhZnRlciBvdGhlciBjaGFydHMgYXJlIHJlbmRlcmVkXG4gICAgICAgIC8vIEluIGNhc2UgaGlnaGxpZ2h0IGFjdGlvbiBoYXMgd3JvbmcgcmVzdWx0XG4gICAgICAgIC8vIEZJWE1FXG4gICAgICAgICFhcGkuaXNEaXNwb3NlZCgpICYmIHNlbGZfMS5tYW51YWxseVNob3dUaXAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHtcbiAgICAgICAgICB4OiBzZWxmXzEuX2xhc3RYLFxuICAgICAgICAgIHk6IHNlbGZfMS5fbGFzdFksXG4gICAgICAgICAgZGF0YUJ5Q29vcmRTeXM6IHNlbGZfMS5fbGFzdERhdGFCeUNvb3JkU3lzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBTaG93IHRpcCBtYW51YWxseSBieVxyXG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcclxuICAgKiAgICAgdHlwZTogJ3Nob3dUaXAnLFxyXG4gICAqICAgICB4OiAxMCxcclxuICAgKiAgICAgeTogMTBcclxuICAgKiB9KTtcclxuICAgKiBPclxyXG4gICAqIGRpc3BhdGNoQWN0aW9uKHtcclxuICAgKiAgICAgIHR5cGU6ICdzaG93VGlwJyxcclxuICAgKiAgICAgIHNlcmllc0luZGV4OiAwLFxyXG4gICAqICAgICAgZGF0YUluZGV4IG9yIGRhdGFJbmRleEluc2lkZSBvciBuYW1lXHJcbiAgICogfSk7XHJcbiAgICpcclxuICAgKiAgVE9ETyBCYXRjaFxyXG4gICAqL1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUubWFudWFsbHlTaG93VGlwID0gZnVuY3Rpb24gKHRvb2x0aXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7XG4gICAgaWYgKHBheWxvYWQuZnJvbSA9PT0gdGhpcy51aWQgfHwgZW52Lm5vZGUgfHwgIWFwaS5nZXREb20oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGlzcGF0Y2hBY3Rpb24gPSBtYWtlRGlzcGF0Y2hBY3Rpb24ocGF5bG9hZCwgYXBpKTtcbiAgICAvLyBSZXNldCB0aWNrZXRcbiAgICB0aGlzLl90aWNrZXQgPSAnJztcbiAgICAvLyBXaGVuIHRyaWdnZXJlZCBmcm9tIGF4aXNQb2ludGVyLlxuICAgIHZhciBkYXRhQnlDb29yZFN5cyA9IHBheWxvYWQuZGF0YUJ5Q29vcmRTeXM7XG4gICAgdmFyIGNtcHRSZWYgPSBmaW5kQ29tcG9uZW50UmVmZXJlbmNlKHBheWxvYWQsIGVjTW9kZWwsIGFwaSk7XG4gICAgaWYgKGNtcHRSZWYpIHtcbiAgICAgIHZhciByZWN0ID0gY21wdFJlZi5lbC5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuICAgICAgcmVjdC5hcHBseVRyYW5zZm9ybShjbXB0UmVmLmVsLnRyYW5zZm9ybSk7XG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcmVjdC54ICsgcmVjdC53aWR0aCAvIDIsXG4gICAgICAgIG9mZnNldFk6IHJlY3QueSArIHJlY3QuaGVpZ2h0IC8gMixcbiAgICAgICAgdGFyZ2V0OiBjbXB0UmVmLmVsLFxuICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgLy8gV2hlbiBtYW51bGx5IHRyaWdnZXIsIHRoZSBtb3VzZSBpcyBub3Qgb24gdGhlIGVsLCBzbyB3ZSdkIGJldHRlciB0b1xuICAgICAgICAvLyBwb3NpdGlvbiB0b29sdGlwIG9uIHRoZSBib3R0b20gb2YgdGhlIGVsIGFuZCBkaXNwbGF5IGFycm93IGlzIHBvc3NpYmxlLlxuICAgICAgICBwb3NpdGlvbkRlZmF1bHQ6ICdib3R0b20nXG4gICAgICB9LCBkaXNwYXRjaEFjdGlvbik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkLnRvb2x0aXAgJiYgcGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIHZhciBlbCA9IHByb3h5UmVjdDtcbiAgICAgIGVsLnggPSBwYXlsb2FkLng7XG4gICAgICBlbC55ID0gcGF5bG9hZC55O1xuICAgICAgZWwudXBkYXRlKCk7XG4gICAgICBnZXRFQ0RhdGEoZWwpLnRvb2x0aXBDb25maWcgPSB7XG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIG9wdGlvbjogcGF5bG9hZC50b29sdGlwXG4gICAgICB9O1xuICAgICAgLy8gTWFudWFsbHkgc2hvdyB0b29sdGlwIHdoaWxlIHZpZXcgaXMgbm90IHVzaW5nIHpyZW5kZXIgZWxlbWVudHMuXG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHRhcmdldDogZWxcbiAgICAgIH0sIGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9IGVsc2UgaWYgKGRhdGFCeUNvb3JkU3lzKSB7XG4gICAgICB0aGlzLl90cnlTaG93KHtcbiAgICAgICAgb2Zmc2V0WDogcGF5bG9hZC54LFxuICAgICAgICBvZmZzZXRZOiBwYXlsb2FkLnksXG4gICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICBkYXRhQnlDb29yZFN5czogZGF0YUJ5Q29vcmRTeXMsXG4gICAgICAgIHRvb2x0aXBPcHRpb246IHBheWxvYWQudG9vbHRpcE9wdGlvblxuICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgIH0gZWxzZSBpZiAocGF5bG9hZC5zZXJpZXNJbmRleCAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5fbWFudWFsbHlBeGlzU2hvd1RpcCh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHBvaW50SW5mbyA9IGZpbmRQb2ludEZyb21TZXJpZXMocGF5bG9hZCwgZWNNb2RlbCk7XG4gICAgICB2YXIgY3ggPSBwb2ludEluZm8ucG9pbnRbMF07XG4gICAgICB2YXIgY3kgPSBwb2ludEluZm8ucG9pbnRbMV07XG4gICAgICBpZiAoY3ggIT0gbnVsbCAmJiBjeSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3RyeVNob3coe1xuICAgICAgICAgIG9mZnNldFg6IGN4LFxuICAgICAgICAgIG9mZnNldFk6IGN5LFxuICAgICAgICAgIHRhcmdldDogcG9pbnRJbmZvLmVsLFxuICAgICAgICAgIHBvc2l0aW9uOiBwYXlsb2FkLnBvc2l0aW9uLFxuICAgICAgICAgIC8vIFdoZW4gbWFudWxseSB0cmlnZ2VyLCB0aGUgbW91c2UgaXMgbm90IG9uIHRoZSBlbCwgc28gd2UnZCBiZXR0ZXIgdG9cbiAgICAgICAgICAvLyBwb3NpdGlvbiB0b29sdGlwIG9uIHRoZSBib3R0b20gb2YgdGhlIGVsIGFuZCBkaXNwbGF5IGFycm93IGlzIHBvc3NpYmxlLlxuICAgICAgICAgIHBvc2l0aW9uRGVmYXVsdDogJ2JvdHRvbSdcbiAgICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGF5bG9hZC54ICE9IG51bGwgJiYgcGF5bG9hZC55ICE9IG51bGwpIHtcbiAgICAgIC8vIEZJWE1FXG4gICAgICAvLyBzaG91bGQgd3JhcCBkaXNwYXRjaEFjdGlvbiBsaWtlIGBheGlzUG9pbnRlci9nbG9iYWxMaXN0ZW5lcmAgP1xuICAgICAgYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3VwZGF0ZUF4aXNQb2ludGVyJyxcbiAgICAgICAgeDogcGF5bG9hZC54LFxuICAgICAgICB5OiBwYXlsb2FkLnlcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdHJ5U2hvdyh7XG4gICAgICAgIG9mZnNldFg6IHBheWxvYWQueCxcbiAgICAgICAgb2Zmc2V0WTogcGF5bG9hZC55LFxuICAgICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvbixcbiAgICAgICAgdGFyZ2V0OiBhcGkuZ2V0WnIoKS5maW5kSG92ZXIocGF5bG9hZC54LCBwYXlsb2FkLnkpLnRhcmdldFxuICAgICAgfSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgIH1cbiAgfTtcbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLm1hbnVhbGx5SGlkZVRpcCA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCkge1xuICAgIHZhciB0b29sdGlwQ29udGVudCA9IHRoaXMuX3Rvb2x0aXBDb250ZW50O1xuICAgIGlmICh0aGlzLl90b29sdGlwTW9kZWwpIHtcbiAgICAgIHRvb2x0aXBDb250ZW50LmhpZGVMYXRlcih0aGlzLl90b29sdGlwTW9kZWwuZ2V0KCdoaWRlRGVsYXknKSk7XG4gICAgfVxuICAgIHRoaXMuX2xhc3RYID0gdGhpcy5fbGFzdFkgPSB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgIGlmIChwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9oaWRlKG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpKTtcbiAgICB9XG4gIH07XG4gIC8vIEJlIGNvbXBhdGlibGUgd2l0aCBwcmV2aW91cyBkZXNpZ24sIHRoYXQgaXMsIHdoZW4gdG9vbHRpcC50eXBlIGlzICdheGlzJyBhbmRcbiAgLy8gZGlzcGF0Y2hBY3Rpb24gJ3Nob3dUaXAnIHdpdGggc2VyaWVzSW5kZXggYW5kIGRhdGFJbmRleCB3aWxsIHRyaWdnZXIgYXhpcyBwb2ludGVyXG4gIC8vIGFuZCB0b29sdGlwLlxuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX21hbnVhbGx5QXhpc1Nob3dUaXAgPSBmdW5jdGlvbiAodG9vbHRpcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICB2YXIgc2VyaWVzSW5kZXggPSBwYXlsb2FkLnNlcmllc0luZGV4O1xuICAgIHZhciBkYXRhSW5kZXggPSBwYXlsb2FkLmRhdGFJbmRleDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgdmFyIGNvb3JkU3lzQXhlc0luZm8gPSBlY01vZGVsLmdldENvbXBvbmVudCgnYXhpc1BvaW50ZXInKS5jb29yZFN5c0F4ZXNJbmZvO1xuICAgIGlmIChzZXJpZXNJbmRleCA9PSBudWxsIHx8IGRhdGFJbmRleCA9PSBudWxsIHx8IGNvb3JkU3lzQXhlc0luZm8gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VyaWVzTW9kZWwgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoc2VyaWVzSW5kZXgpO1xuICAgIGlmICghc2VyaWVzTW9kZWwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBzZXJpZXNNb2RlbC5nZXREYXRhKCk7XG4gICAgdmFyIHRvb2x0aXBDYXNjYWRlZE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2RhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksIHNlcmllc01vZGVsLCAoc2VyaWVzTW9kZWwuY29vcmRpbmF0ZVN5c3RlbSB8fCB7fSkubW9kZWxdLCB0aGlzLl90b29sdGlwTW9kZWwpO1xuICAgIGlmICh0b29sdGlwQ2FzY2FkZWRNb2RlbC5nZXQoJ3RyaWdnZXInKSAhPT0gJ2F4aXMnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwaS5kaXNwYXRjaEFjdGlvbih7XG4gICAgICB0eXBlOiAndXBkYXRlQXhpc1BvaW50ZXInLFxuICAgICAgc2VyaWVzSW5kZXg6IHNlcmllc0luZGV4LFxuICAgICAgZGF0YUluZGV4OiBkYXRhSW5kZXgsXG4gICAgICBwb3NpdGlvbjogcGF5bG9hZC5wb3NpdGlvblxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3RyeVNob3cgPSBmdW5jdGlvbiAoZSwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgZWwgPSBlLnRhcmdldDtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIGlmICghdG9vbHRpcE1vZGVsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhdmUgbW91c2UgeCwgbW91c2UgeS4gU28gd2UgY2FuIHRyeSB0byBrZWVwIHNob3dpbmcgdGhlIHRpcCBpZiBjaGFydCBpcyByZWZyZXNoZWRcbiAgICB0aGlzLl9sYXN0WCA9IGUub2Zmc2V0WDtcbiAgICB0aGlzLl9sYXN0WSA9IGUub2Zmc2V0WTtcbiAgICB2YXIgZGF0YUJ5Q29vcmRTeXMgPSBlLmRhdGFCeUNvb3JkU3lzO1xuICAgIGlmIChkYXRhQnlDb29yZFN5cyAmJiBkYXRhQnlDb29yZFN5cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3Nob3dBeGlzVG9vbHRpcChkYXRhQnlDb29yZFN5cywgZSk7XG4gICAgfSBlbHNlIGlmIChlbCkge1xuICAgICAgdmFyIGVjRGF0YSA9IGdldEVDRGF0YShlbCk7XG4gICAgICBpZiAoZWNEYXRhLnNzclR5cGUgPT09ICdsZWdlbmQnKSB7XG4gICAgICAgIC8vIERvbid0IHRyaWdnZXIgdG9vbHRpcCBmb3IgbGVnZW5kIHRvb2x0aXAgaXRlbVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgICAgdmFyIHNlcmllc0Rpc3BhdGNoZXJfMTtcbiAgICAgIHZhciBjbXB0RGlzcGF0Y2hlcl8xO1xuICAgICAgZmluZEV2ZW50RGlzcGF0Y2hlcihlbCwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBBbHdheXMgc2hvdyBpdGVtIHRvb2x0aXAgaWYgbW91c2UgaXMgb24gdGhlIGVsZW1lbnQgd2l0aCBkYXRhSW5kZXhcbiAgICAgICAgaWYgKGdldEVDRGF0YSh0YXJnZXQpLmRhdGFJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgc2VyaWVzRGlzcGF0Y2hlcl8xID0gdGFyZ2V0O1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRvb2x0aXAgcHJvdmlkZWQgZGlyZWN0bHkuIExpa2UgbGVnZW5kLlxuICAgICAgICBpZiAoZ2V0RUNEYXRhKHRhcmdldCkudG9vbHRpcENvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgY21wdERpc3BhdGNoZXJfMSA9IHRhcmdldDtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSwgdHJ1ZSk7XG4gICAgICBpZiAoc2VyaWVzRGlzcGF0Y2hlcl8xKSB7XG4gICAgICAgIHRoaXMuX3Nob3dTZXJpZXNJdGVtVG9vbHRpcChlLCBzZXJpZXNEaXNwYXRjaGVyXzEsIGRpc3BhdGNoQWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoY21wdERpc3BhdGNoZXJfMSkge1xuICAgICAgICB0aGlzLl9zaG93Q29tcG9uZW50SXRlbVRvb2x0aXAoZSwgY21wdERpc3BhdGNoZXJfMSwgZGlzcGF0Y2hBY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faGlkZShkaXNwYXRjaEFjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IG51bGw7XG4gICAgICB0aGlzLl9oaWRlKGRpc3BhdGNoQWN0aW9uKTtcbiAgICB9XG4gIH07XG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5fc2hvd09yTW92ZSA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIGNiKSB7XG4gICAgLy8gc2hvd0RlbGF5IGlzIHVzZWQgaW4gdGhpcyBjYXNlOiB0b29sdGlwLmVudGVyYWJsZSBpcyBzZXRcbiAgICAvLyBhcyB0cnVlLiBVc2VyIGludGVudCB0byBtb3ZlIG1vdXNlIGludG8gdG9vbHRpcCBhbmQgY2xpY2tcbiAgICAvLyBzb21ldGhpbmcuIGBzaG93RGVsYXlgIG1ha2VzIGl0IGVhc2llciB0byBlbnRlciB0aGUgY29udGVudFxuICAgIC8vIGJ1dCB0b29sdGlwIGRvIG5vdCBtb3ZlIGltbWVkaWF0ZWx5LlxuICAgIHZhciBkZWxheSA9IHRvb2x0aXBNb2RlbC5nZXQoJ3Nob3dEZWxheScpO1xuICAgIGNiID0gYmluZChjYiwgdGhpcyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3Nob3dUaW1vdXQpO1xuICAgIGRlbGF5ID4gMCA/IHRoaXMuX3Nob3dUaW1vdXQgPSBzZXRUaW1lb3V0KGNiLCBkZWxheSkgOiBjYigpO1xuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dBeGlzVG9vbHRpcCA9IGZ1bmN0aW9uIChkYXRhQnlDb29yZFN5cywgZSkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgZ2xvYmFsVG9vbHRpcE1vZGVsID0gdGhpcy5fdG9vbHRpcE1vZGVsO1xuICAgIHZhciBwb2ludCA9IFtlLm9mZnNldFgsIGUub2Zmc2V0WV07XG4gICAgdmFyIHNpbmdsZVRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtlLnRvb2x0aXBPcHRpb25dLCBnbG9iYWxUb29sdGlwTW9kZWwpO1xuICAgIHZhciByZW5kZXJNb2RlID0gdGhpcy5fcmVuZGVyTW9kZTtcbiAgICB2YXIgY2JQYXJhbXNMaXN0ID0gW107XG4gICAgdmFyIGFydGljbGVNYXJrdXAgPSBjcmVhdGVUb29sdGlwTWFya3VwKCdzZWN0aW9uJywge1xuICAgICAgYmxvY2tzOiBbXSxcbiAgICAgIG5vSGVhZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgLy8gT25seSBmb3IgbGVnYWN5OiBgU2VyaXNlWydmb3JtYXRUb29sdGlwJ11gIHJldHVybnMgYSBzdHJpbmcuXG4gICAgdmFyIG1hcmt1cFRleHRBcnJMZWdhY3kgPSBbXTtcbiAgICB2YXIgbWFya3VwU3R5bGVDcmVhdG9yID0gbmV3IFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IoKTtcbiAgICBlYWNoKGRhdGFCeUNvb3JkU3lzLCBmdW5jdGlvbiAoaXRlbUNvb3JkU3lzKSB7XG4gICAgICBlYWNoKGl0ZW1Db29yZFN5cy5kYXRhQnlBeGlzLCBmdW5jdGlvbiAoYXhpc0l0ZW0pIHtcbiAgICAgICAgdmFyIGF4aXNNb2RlbCA9IGVjTW9kZWwuZ2V0Q29tcG9uZW50KGF4aXNJdGVtLmF4aXNEaW0gKyAnQXhpcycsIGF4aXNJdGVtLmF4aXNJbmRleCk7XG4gICAgICAgIHZhciBheGlzVmFsdWUgPSBheGlzSXRlbS52YWx1ZTtcbiAgICAgICAgaWYgKCFheGlzTW9kZWwgfHwgYXhpc1ZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4aXNWYWx1ZUxhYmVsID0gYXhpc1BvaW50ZXJWaWV3SGVscGVyLmdldFZhbHVlTGFiZWwoYXhpc1ZhbHVlLCBheGlzTW9kZWwuYXhpcywgZWNNb2RlbCwgYXhpc0l0ZW0uc2VyaWVzRGF0YUluZGljZXMsIGF4aXNJdGVtLnZhbHVlTGFiZWxPcHQpO1xuICAgICAgICB2YXIgYXhpc1NlY3Rpb25NYXJrdXAgPSBjcmVhdGVUb29sdGlwTWFya3VwKCdzZWN0aW9uJywge1xuICAgICAgICAgIGhlYWRlcjogYXhpc1ZhbHVlTGFiZWwsXG4gICAgICAgICAgbm9IZWFkZXI6ICF0cmltKGF4aXNWYWx1ZUxhYmVsKSxcbiAgICAgICAgICBzb3J0QmxvY2tzOiB0cnVlLFxuICAgICAgICAgIGJsb2NrczogW11cbiAgICAgICAgfSk7XG4gICAgICAgIGFydGljbGVNYXJrdXAuYmxvY2tzLnB1c2goYXhpc1NlY3Rpb25NYXJrdXApO1xuICAgICAgICBlYWNoKGF4aXNJdGVtLnNlcmllc0RhdGFJbmRpY2VzLCBmdW5jdGlvbiAoaWR4SXRlbSkge1xuICAgICAgICAgIHZhciBzZXJpZXMgPSBlY01vZGVsLmdldFNlcmllc0J5SW5kZXgoaWR4SXRlbS5zZXJpZXNJbmRleCk7XG4gICAgICAgICAgdmFyIGRhdGFJbmRleCA9IGlkeEl0ZW0uZGF0YUluZGV4SW5zaWRlO1xuICAgICAgICAgIHZhciBjYlBhcmFtcyA9IHNlcmllcy5nZXREYXRhUGFyYW1zKGRhdGFJbmRleCk7XG4gICAgICAgICAgLy8gQ2FuJ3QgZmluZCBkYXRhLlxuICAgICAgICAgIGlmIChjYlBhcmFtcy5kYXRhSW5kZXggPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNiUGFyYW1zLmF4aXNEaW0gPSBheGlzSXRlbS5heGlzRGltO1xuICAgICAgICAgIGNiUGFyYW1zLmF4aXNJbmRleCA9IGF4aXNJdGVtLmF4aXNJbmRleDtcbiAgICAgICAgICBjYlBhcmFtcy5heGlzVHlwZSA9IGF4aXNJdGVtLmF4aXNUeXBlO1xuICAgICAgICAgIGNiUGFyYW1zLmF4aXNJZCA9IGF4aXNJdGVtLmF4aXNJZDtcbiAgICAgICAgICBjYlBhcmFtcy5heGlzVmFsdWUgPSBheGlzSGVscGVyLmdldEF4aXNSYXdWYWx1ZShheGlzTW9kZWwuYXhpcywge1xuICAgICAgICAgICAgdmFsdWU6IGF4aXNWYWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNiUGFyYW1zLmF4aXNWYWx1ZUxhYmVsID0gYXhpc1ZhbHVlTGFiZWw7XG4gICAgICAgICAgLy8gUHJlLWNyZWF0ZSBtYXJrZXIgc3R5bGUgZm9yIG1ha2Vycy4gVXNlcnMgY2FuIGFzc2VtYmxlIHJpY2hUZXh0XG4gICAgICAgICAgLy8gdGV4dCBpbiBgZm9ybWF0dGVyYCBjYWxsYmFjayBhbmQgdXNlIHRob3NlIG1hcmtlcnMgc3R5bGUuXG4gICAgICAgICAgY2JQYXJhbXMubWFya2VyID0gbWFya3VwU3R5bGVDcmVhdG9yLm1ha2VUb29sdGlwTWFya2VyKCdpdGVtJywgY29udmVydFRvQ29sb3JTdHJpbmcoY2JQYXJhbXMuY29sb3IpLCByZW5kZXJNb2RlKTtcbiAgICAgICAgICB2YXIgc2VyaWVzVG9vbHRpcFJlc3VsdCA9IG5vcm1hbGl6ZVRvb2x0aXBGb3JtYXRSZXN1bHQoc2VyaWVzLmZvcm1hdFRvb2x0aXAoZGF0YUluZGV4LCB0cnVlLCBudWxsKSk7XG4gICAgICAgICAgdmFyIGZyYWcgPSBzZXJpZXNUb29sdGlwUmVzdWx0LmZyYWc7XG4gICAgICAgICAgaWYgKGZyYWcpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZUZvcm1hdHRlciA9IGJ1aWxkVG9vbHRpcE1vZGVsKFtzZXJpZXNdLCBnbG9iYWxUb29sdGlwTW9kZWwpLmdldCgndmFsdWVGb3JtYXR0ZXInKTtcbiAgICAgICAgICAgIGF4aXNTZWN0aW9uTWFya3VwLmJsb2Nrcy5wdXNoKHZhbHVlRm9ybWF0dGVyID8gZXh0ZW5kKHtcbiAgICAgICAgICAgICAgdmFsdWVGb3JtYXR0ZXI6IHZhbHVlRm9ybWF0dGVyXG4gICAgICAgICAgICB9LCBmcmFnKSA6IGZyYWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VyaWVzVG9vbHRpcFJlc3VsdC50ZXh0KSB7XG4gICAgICAgICAgICBtYXJrdXBUZXh0QXJyTGVnYWN5LnB1c2goc2VyaWVzVG9vbHRpcFJlc3VsdC50ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2JQYXJhbXNMaXN0LnB1c2goY2JQYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIEluIG1vc3QgY2FzZXMsIHRoZSBzZWNvbmQgYXhpcyBpcyBkaXNwbGF5cyB1cHBlciBvbiB0aGUgZmlyc3Qgb25lLlxuICAgIC8vIFNvIHdlIHJldmVyc2UgaXQgdG8gbG9vayBiZXR0ZXIuXG4gICAgYXJ0aWNsZU1hcmt1cC5ibG9ja3MucmV2ZXJzZSgpO1xuICAgIG1hcmt1cFRleHRBcnJMZWdhY3kucmV2ZXJzZSgpO1xuICAgIHZhciBwb3NpdGlvbkV4cHIgPSBlLnBvc2l0aW9uO1xuICAgIHZhciBvcmRlck1vZGUgPSBzaW5nbGVUb29sdGlwTW9kZWwuZ2V0KCdvcmRlcicpO1xuICAgIHZhciBidWlsdE1hcmt1cFRleHQgPSBidWlsZFRvb2x0aXBNYXJrdXAoYXJ0aWNsZU1hcmt1cCwgbWFya3VwU3R5bGVDcmVhdG9yLCByZW5kZXJNb2RlLCBvcmRlck1vZGUsIGVjTW9kZWwuZ2V0KCd1c2VVVEMnKSwgc2luZ2xlVG9vbHRpcE1vZGVsLmdldCgndGV4dFN0eWxlJykpO1xuICAgIGJ1aWx0TWFya3VwVGV4dCAmJiBtYXJrdXBUZXh0QXJyTGVnYWN5LnVuc2hpZnQoYnVpbHRNYXJrdXBUZXh0KTtcbiAgICB2YXIgYmxvY2tCcmVhayA9IHJlbmRlck1vZGUgPT09ICdyaWNoVGV4dCcgPyAnXFxuXFxuJyA6ICc8YnIvPic7XG4gICAgdmFyIGFsbE1hcmt1cFRleHQgPSBtYXJrdXBUZXh0QXJyTGVnYWN5LmpvaW4oYmxvY2tCcmVhayk7XG4gICAgdGhpcy5fc2hvd09yTW92ZShzaW5nbGVUb29sdGlwTW9kZWwsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0aGlzLl91cGRhdGVDb250ZW50Tm90Q2hhbmdlZE9uQXhpcyhkYXRhQnlDb29yZFN5cywgY2JQYXJhbXNMaXN0KSkge1xuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbihzaW5nbGVUb29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgcG9pbnRbMF0sIHBvaW50WzFdLCB0aGlzLl90b29sdGlwQ29udGVudCwgY2JQYXJhbXNMaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Nob3dUb29sdGlwQ29udGVudChzaW5nbGVUb29sdGlwTW9kZWwsIGFsbE1hcmt1cFRleHQsIGNiUGFyYW1zTGlzdCwgTWF0aC5yYW5kb20oKSArICcnLCBwb2ludFswXSwgcG9pbnRbMV0sIHBvc2l0aW9uRXhwciwgbnVsbCwgbWFya3VwU3R5bGVDcmVhdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBEbyBub3QgdHJpZ2dlciBldmVudHMgaGVyZSwgYmVjYXVzZSB0aGlzIGJyYW5jaCBvbmx5IGJlIGVudGVyZWRcbiAgICAvLyBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dTZXJpZXNJdGVtVG9vbHRpcCA9IGZ1bmN0aW9uIChlLCBkaXNwYXRjaGVyLCBkaXNwYXRjaEFjdGlvbikge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5fZWNNb2RlbDtcbiAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGRpc3BhdGNoZXIpO1xuICAgIC8vIFVzZSBkYXRhTW9kZWwgaW4gZWxlbWVudCBpZiBwb3NzaWJsZVxuICAgIC8vIFVzZWQgd2hlbiBtb3VzZW92ZXIgb24gYSBlbGVtZW50IGxpa2UgbWFya1BvaW50IG9yIGVkZ2VcbiAgICAvLyBJbiB3aGljaCBjYXNlLCB0aGUgZGF0YSBpcyBub3QgbWFpbiBkYXRhIGluIHNlcmllcy5cbiAgICB2YXIgc2VyaWVzSW5kZXggPSBlY0RhdGEuc2VyaWVzSW5kZXg7XG4gICAgdmFyIHNlcmllc01vZGVsID0gZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KHNlcmllc0luZGV4KTtcbiAgICAvLyBGb3IgZXhhbXBsZSwgZ3JhcGggbGluay5cbiAgICB2YXIgZGF0YU1vZGVsID0gZWNEYXRhLmRhdGFNb2RlbCB8fCBzZXJpZXNNb2RlbDtcbiAgICB2YXIgZGF0YUluZGV4ID0gZWNEYXRhLmRhdGFJbmRleDtcbiAgICB2YXIgZGF0YVR5cGUgPSBlY0RhdGEuZGF0YVR5cGU7XG4gICAgdmFyIGRhdGEgPSBkYXRhTW9kZWwuZ2V0RGF0YShkYXRhVHlwZSk7XG4gICAgdmFyIHJlbmRlck1vZGUgPSB0aGlzLl9yZW5kZXJNb2RlO1xuICAgIHZhciBwb3NpdGlvbkRlZmF1bHQgPSBlLnBvc2l0aW9uRGVmYXVsdDtcbiAgICB2YXIgdG9vbHRpcE1vZGVsID0gYnVpbGRUb29sdGlwTW9kZWwoW2RhdGEuZ2V0SXRlbU1vZGVsKGRhdGFJbmRleCksIGRhdGFNb2RlbCwgc2VyaWVzTW9kZWwgJiYgKHNlcmllc01vZGVsLmNvb3JkaW5hdGVTeXN0ZW0gfHwge30pLm1vZGVsXSwgdGhpcy5fdG9vbHRpcE1vZGVsLCBwb3NpdGlvbkRlZmF1bHQgPyB7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25EZWZhdWx0XG4gICAgfSA6IG51bGwpO1xuICAgIHZhciB0b29sdGlwVHJpZ2dlciA9IHRvb2x0aXBNb2RlbC5nZXQoJ3RyaWdnZXInKTtcbiAgICBpZiAodG9vbHRpcFRyaWdnZXIgIT0gbnVsbCAmJiB0b29sdGlwVHJpZ2dlciAhPT0gJ2l0ZW0nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXJhbXMgPSBkYXRhTW9kZWwuZ2V0RGF0YVBhcmFtcyhkYXRhSW5kZXgsIGRhdGFUeXBlKTtcbiAgICB2YXIgbWFya3VwU3R5bGVDcmVhdG9yID0gbmV3IFRvb2x0aXBNYXJrdXBTdHlsZUNyZWF0b3IoKTtcbiAgICAvLyBQcmUtY3JlYXRlIG1hcmtlciBzdHlsZSBmb3IgbWFrZXJzLiBVc2VycyBjYW4gYXNzZW1ibGUgcmljaFRleHRcbiAgICAvLyB0ZXh0IGluIGBmb3JtYXR0ZXJgIGNhbGxiYWNrIGFuZCB1c2UgdGhvc2UgbWFya2VycyBzdHlsZS5cbiAgICBwYXJhbXMubWFya2VyID0gbWFya3VwU3R5bGVDcmVhdG9yLm1ha2VUb29sdGlwTWFya2VyKCdpdGVtJywgY29udmVydFRvQ29sb3JTdHJpbmcocGFyYW1zLmNvbG9yKSwgcmVuZGVyTW9kZSk7XG4gICAgdmFyIHNlcmllc1Rvb2x0aXBSZXN1bHQgPSBub3JtYWxpemVUb29sdGlwRm9ybWF0UmVzdWx0KGRhdGFNb2RlbC5mb3JtYXRUb29sdGlwKGRhdGFJbmRleCwgZmFsc2UsIGRhdGFUeXBlKSk7XG4gICAgdmFyIG9yZGVyTW9kZSA9IHRvb2x0aXBNb2RlbC5nZXQoJ29yZGVyJyk7XG4gICAgdmFyIHZhbHVlRm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgndmFsdWVGb3JtYXR0ZXInKTtcbiAgICB2YXIgZnJhZyA9IHNlcmllc1Rvb2x0aXBSZXN1bHQuZnJhZztcbiAgICB2YXIgbWFya3VwVGV4dCA9IGZyYWcgPyBidWlsZFRvb2x0aXBNYXJrdXAodmFsdWVGb3JtYXR0ZXIgPyBleHRlbmQoe1xuICAgICAgdmFsdWVGb3JtYXR0ZXI6IHZhbHVlRm9ybWF0dGVyXG4gICAgfSwgZnJhZykgOiBmcmFnLCBtYXJrdXBTdHlsZUNyZWF0b3IsIHJlbmRlck1vZGUsIG9yZGVyTW9kZSwgZWNNb2RlbC5nZXQoJ3VzZVVUQycpLCB0b29sdGlwTW9kZWwuZ2V0KCd0ZXh0U3R5bGUnKSkgOiBzZXJpZXNUb29sdGlwUmVzdWx0LnRleHQ7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gJ2l0ZW1fJyArIGRhdGFNb2RlbC5uYW1lICsgJ18nICsgZGF0YUluZGV4O1xuICAgIHRoaXMuX3Nob3dPck1vdmUodG9vbHRpcE1vZGVsLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQodG9vbHRpcE1vZGVsLCBtYXJrdXBUZXh0LCBwYXJhbXMsIGFzeW5jVGlja2V0LCBlLm9mZnNldFgsIGUub2Zmc2V0WSwgZS5wb3NpdGlvbiwgZS50YXJnZXQsIG1hcmt1cFN0eWxlQ3JlYXRvcik7XG4gICAgfSk7XG4gICAgLy8gRklYTUVcbiAgICAvLyBkdXBsaWNhdGVkIHNob3d0aXAgaWYgbWFudWFsbHlTaG93VGlwIGlzIGNhbGxlZCBmcm9tIGRpc3BhdGNoQWN0aW9uLlxuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdzaG93VGlwJyxcbiAgICAgIGRhdGFJbmRleEluc2lkZTogZGF0YUluZGV4LFxuICAgICAgZGF0YUluZGV4OiBkYXRhLmdldFJhd0luZGV4KGRhdGFJbmRleCksXG4gICAgICBzZXJpZXNJbmRleDogc2VyaWVzSW5kZXgsXG4gICAgICBmcm9tOiB0aGlzLnVpZFxuICAgIH0pO1xuICB9O1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3Nob3dDb21wb25lbnRJdGVtVG9vbHRpcCA9IGZ1bmN0aW9uIChlLCBlbCwgZGlzcGF0Y2hBY3Rpb24pIHtcbiAgICB2YXIgaXNIVE1MUmVuZGVyTW9kZSA9IHRoaXMuX3JlbmRlck1vZGUgPT09ICdodG1sJztcbiAgICB2YXIgZWNEYXRhID0gZ2V0RUNEYXRhKGVsKTtcbiAgICB2YXIgdG9vbHRpcENvbmZpZyA9IGVjRGF0YS50b29sdGlwQ29uZmlnO1xuICAgIHZhciB0b29sdGlwT3B0ID0gdG9vbHRpcENvbmZpZy5vcHRpb24gfHwge307XG4gICAgdmFyIGVuY29kZUhUTUxDb250ZW50ID0gdG9vbHRpcE9wdC5lbmNvZGVIVE1MQ29udGVudDtcbiAgICBpZiAoaXNTdHJpbmcodG9vbHRpcE9wdCkpIHtcbiAgICAgIHZhciBjb250ZW50ID0gdG9vbHRpcE9wdDtcbiAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgIC8vIEZpeGVkIGZvcm1hdHRlclxuICAgICAgICBmb3JtYXR0ZXI6IGNvbnRlbnRcbiAgICAgIH07XG4gICAgICAvLyB3aGVuIGB0b29sdGlwQ29uZmlnLm9wdGlvbmAgaXMgYSBzdHJpbmcgcmF0aGVyIHRoYW4gYW4gb2JqZWN0LFxuICAgICAgLy8gd2UgY2FuJ3Qga25vdyBpZiB0aGUgY29udGVudCBuZWVkcyB0byBiZSBlbmNvZGVkXG4gICAgICAvLyBmb3IgdGhlIHNha2Ugb2Ygc2VjdXJpdHksIGVuY29kZSBpdCBieSBkZWZhdWx0LlxuICAgICAgZW5jb2RlSFRNTENvbnRlbnQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoZW5jb2RlSFRNTENvbnRlbnQgJiYgaXNIVE1MUmVuZGVyTW9kZSAmJiB0b29sdGlwT3B0LmNvbnRlbnQpIHtcbiAgICAgIC8vIGNsb25lIG1pZ2h0IGJlIHVubmVjZXNzYXJ5P1xuICAgICAgdG9vbHRpcE9wdCA9IGNsb25lKHRvb2x0aXBPcHQpO1xuICAgICAgdG9vbHRpcE9wdC5jb250ZW50ID0gZW5jb2RlSFRNTCh0b29sdGlwT3B0LmNvbnRlbnQpO1xuICAgIH1cbiAgICB2YXIgdG9vbHRpcE1vZGVsQ2FzY2FkZSA9IFt0b29sdGlwT3B0XTtcbiAgICB2YXIgY21wdCA9IHRoaXMuX2VjTW9kZWwuZ2V0Q29tcG9uZW50KGVjRGF0YS5jb21wb25lbnRNYWluVHlwZSwgZWNEYXRhLmNvbXBvbmVudEluZGV4KTtcbiAgICBpZiAoY21wdCkge1xuICAgICAgdG9vbHRpcE1vZGVsQ2FzY2FkZS5wdXNoKGNtcHQpO1xuICAgIH1cbiAgICAvLyBJbiBtb3N0IGNhc2VzLCBjb21wb25lbnQgdG9vbHRpcCBmb3JtYXR0ZXIgaGFzIGRpZmZlcmVudCBwYXJhbXMgd2l0aCBzZXJpZXMgdG9vbHRpcCBmb3JtYXR0ZXIsXG4gICAgLy8gc28gdGhhdCB0aGV5IGNhbm5vdCBzaGFyZSB0aGUgc2FtZSBmb3JtYXR0ZXIuIFNpbmNlIHRoZSBnbG9iYWwgdG9vbHRpcCBmb3JtYXR0ZXIgaXMgdXNlZCBmb3Igc2VyaWVzXG4gICAgLy8gYnkgY29udmVudGlvbiwgd2UgZG8gbm90IHVzZSBpdCBhcyB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgZm9yIGNvbXBvbmVudC5cbiAgICB0b29sdGlwTW9kZWxDYXNjYWRlLnB1c2goe1xuICAgICAgZm9ybWF0dGVyOiB0b29sdGlwT3B0LmNvbnRlbnRcbiAgICB9KTtcbiAgICB2YXIgcG9zaXRpb25EZWZhdWx0ID0gZS5wb3NpdGlvbkRlZmF1bHQ7XG4gICAgdmFyIHN1YlRvb2x0aXBNb2RlbCA9IGJ1aWxkVG9vbHRpcE1vZGVsKHRvb2x0aXBNb2RlbENhc2NhZGUsIHRoaXMuX3Rvb2x0aXBNb2RlbCwgcG9zaXRpb25EZWZhdWx0ID8ge1xuICAgICAgcG9zaXRpb246IHBvc2l0aW9uRGVmYXVsdFxuICAgIH0gOiBudWxsKTtcbiAgICB2YXIgZGVmYXVsdEh0bWwgPSBzdWJUb29sdGlwTW9kZWwuZ2V0KCdjb250ZW50Jyk7XG4gICAgdmFyIGFzeW5jVGlja2V0ID0gTWF0aC5yYW5kb20oKSArICcnO1xuICAgIC8vIFBFTkRJTkc6IHRoaXMgY2FzZSBkbyBub3Qgc3VwcG9ydCByaWNoVGV4dCBzdHlsZSB5ZXQuXG4gICAgdmFyIG1hcmt1cFN0eWxlQ3JlYXRvciA9IG5ldyBUb29sdGlwTWFya3VwU3R5bGVDcmVhdG9yKCk7XG4gICAgLy8gRG8gbm90IGNoZWNrIHdoZXRoZXIgYHRyaWdnZXJgIGlzICdub25lJyBoZXJlLCBiZWNhdXNlIGB0cmlnZ2VyYFxuICAgIC8vIG9ubHkgd29ya3Mgb24gY29vcmRpbmF0ZSBzeXN0ZW0uIEluIGZhY3QsIHdlIGhhdmUgbm90IGZvdW5kIGNhc2VcbiAgICAvLyB0aGF0IHJlcXVpcmVzIHNldHRpbmcgYHRyaWdnZXJgIG5vdGhpbmcgb24gY29tcG9uZW50IHlldC5cbiAgICB0aGlzLl9zaG93T3JNb3ZlKHN1YlRvb2x0aXBNb2RlbCwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVXNlIGZvcm1hdHRlclBhcmFtcyBmcm9tIGVsZW1lbnQgZGVmaW5lZCBpbiBjb21wb25lbnRcbiAgICAgIC8vIEF2b2lkIHVzZXJzIG1vZGlmeSBpdC5cbiAgICAgIHZhciBmb3JtYXR0ZXJQYXJhbXMgPSBjbG9uZShzdWJUb29sdGlwTW9kZWwuZ2V0KCdmb3JtYXR0ZXJQYXJhbXMnKSB8fCB7fSk7XG4gICAgICB0aGlzLl9zaG93VG9vbHRpcENvbnRlbnQoc3ViVG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgZm9ybWF0dGVyUGFyYW1zLCBhc3luY1RpY2tldCwgZS5vZmZzZXRYLCBlLm9mZnNldFksIGUucG9zaXRpb24sIGVsLCBtYXJrdXBTdHlsZUNyZWF0b3IpO1xuICAgIH0pO1xuICAgIC8vIElmIG5vdCBkaXNwYXRjaCBzaG93VGlwLCB0aXAgbWF5IGJlIGhpZGUgdHJpZ2dlcmVkIGJ5IGF4aXMuXG4gICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgICAgZnJvbTogdGhpcy51aWRcbiAgICB9KTtcbiAgfTtcbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9zaG93VG9vbHRpcENvbnRlbnQgPSBmdW5jdGlvbiAoXG4gIC8vIFVzZSBNb2RlbDxUb29sdGlwT3B0aW9uPiBpbnN0ZWFkb2YgVG9vbHRpcE1vZGVsIGJlY2F1c2UgdGhpcyBtb2RlbCBtYXkgYmUgZnJvbSBzZXJpZXMgb3Igb3RoZXIgb3B0aW9ucy5cbiAgLy8gSW5zdGVhZCBvZiB0b3AgbGV2ZWwgdG9vbHRpcC5cbiAgdG9vbHRpcE1vZGVsLCBkZWZhdWx0SHRtbCwgcGFyYW1zLCBhc3luY1RpY2tldCwgeCwgeSwgcG9zaXRpb25FeHByLCBlbCwgbWFya3VwU3R5bGVDcmVhdG9yKSB7XG4gICAgLy8gUmVzZXQgdGlja2V0XG4gICAgdGhpcy5fdGlja2V0ID0gJyc7XG4gICAgaWYgKCF0b29sdGlwTW9kZWwuZ2V0KCdzaG93Q29udGVudCcpIHx8ICF0b29sdGlwTW9kZWwuZ2V0KCdzaG93JykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRvb2x0aXBDb250ZW50ID0gdGhpcy5fdG9vbHRpcENvbnRlbnQ7XG4gICAgdG9vbHRpcENvbnRlbnQuc2V0RW50ZXJhYmxlKHRvb2x0aXBNb2RlbC5nZXQoJ2VudGVyYWJsZScpKTtcbiAgICB2YXIgZm9ybWF0dGVyID0gdG9vbHRpcE1vZGVsLmdldCgnZm9ybWF0dGVyJyk7XG4gICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIGh0bWwgPSBkZWZhdWx0SHRtbDtcbiAgICB2YXIgbmVhclBvaW50ID0gdGhpcy5fZ2V0TmVhcmVzdFBvaW50KFt4LCB5XSwgcGFyYW1zLCB0b29sdGlwTW9kZWwuZ2V0KCd0cmlnZ2VyJyksIHRvb2x0aXBNb2RlbC5nZXQoJ2JvcmRlckNvbG9yJykpO1xuICAgIHZhciBuZWFyUG9pbnRDb2xvciA9IG5lYXJQb2ludC5jb2xvcjtcbiAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICBpZiAoaXNTdHJpbmcoZm9ybWF0dGVyKSkge1xuICAgICAgICB2YXIgdXNlVVRDID0gdG9vbHRpcE1vZGVsLmVjTW9kZWwuZ2V0KCd1c2VVVEMnKTtcbiAgICAgICAgdmFyIHBhcmFtczAgPSBpc0FycmF5KHBhcmFtcykgPyBwYXJhbXNbMF0gOiBwYXJhbXM7XG4gICAgICAgIHZhciBpc1RpbWVBeGlzID0gcGFyYW1zMCAmJiBwYXJhbXMwLmF4aXNUeXBlICYmIHBhcmFtczAuYXhpc1R5cGUuaW5kZXhPZigndGltZScpID49IDA7XG4gICAgICAgIGh0bWwgPSBmb3JtYXR0ZXI7XG4gICAgICAgIGlmIChpc1RpbWVBeGlzKSB7XG4gICAgICAgICAgaHRtbCA9IHRpbWVGb3JtYXQocGFyYW1zMC5heGlzVmFsdWUsIGh0bWwsIHVzZVVUQyk7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCA9IGZvcm1hdFRwbChodG1sLCBwYXJhbXMsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYmluZChmdW5jdGlvbiAoY2JUaWNrZXQsIGh0bWwpIHtcbiAgICAgICAgICBpZiAoY2JUaWNrZXQgPT09IHRoaXMuX3RpY2tldCkge1xuICAgICAgICAgICAgdG9vbHRpcENvbnRlbnQuc2V0Q29udGVudChodG1sLCBtYXJrdXBTdHlsZUNyZWF0b3IsIHRvb2x0aXBNb2RlbCwgbmVhclBvaW50Q29sb3IsIHBvc2l0aW9uRXhwcik7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbih0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCwgeSwgdG9vbHRpcENvbnRlbnQsIHBhcmFtcywgZWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3RpY2tldCA9IGFzeW5jVGlja2V0O1xuICAgICAgICBodG1sID0gZm9ybWF0dGVyKHBhcmFtcywgYXN5bmNUaWNrZXQsIGNhbGxiYWNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGh0bWwgPSBmb3JtYXR0ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHRvb2x0aXBDb250ZW50LnNldENvbnRlbnQoaHRtbCwgbWFya3VwU3R5bGVDcmVhdG9yLCB0b29sdGlwTW9kZWwsIG5lYXJQb2ludENvbG9yLCBwb3NpdGlvbkV4cHIpO1xuICAgIHRvb2x0aXBDb250ZW50LnNob3codG9vbHRpcE1vZGVsLCBuZWFyUG9pbnRDb2xvcik7XG4gICAgdGhpcy5fdXBkYXRlUG9zaXRpb24odG9vbHRpcE1vZGVsLCBwb3NpdGlvbkV4cHIsIHgsIHksIHRvb2x0aXBDb250ZW50LCBwYXJhbXMsIGVsKTtcbiAgfTtcbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9nZXROZWFyZXN0UG9pbnQgPSBmdW5jdGlvbiAocG9pbnQsIHRvb2x0aXBEYXRhUGFyYW1zLCB0cmlnZ2VyLCBib3JkZXJDb2xvcikge1xuICAgIGlmICh0cmlnZ2VyID09PSAnYXhpcycgfHwgaXNBcnJheSh0b29sdGlwRGF0YVBhcmFtcykpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbG9yOiBib3JkZXJDb2xvciB8fCAodGhpcy5fcmVuZGVyTW9kZSA9PT0gJ2h0bWwnID8gJyNmZmYnIDogJ25vbmUnKVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFpc0FycmF5KHRvb2x0aXBEYXRhUGFyYW1zKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29sb3I6IGJvcmRlckNvbG9yIHx8IHRvb2x0aXBEYXRhUGFyYW1zLmNvbG9yIHx8IHRvb2x0aXBEYXRhUGFyYW1zLmJvcmRlckNvbG9yXG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl91cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICh0b29sdGlwTW9kZWwsIHBvc2l0aW9uRXhwciwgeCxcbiAgLy8gTW91c2UgeFxuICB5LFxuICAvLyBNb3VzZSB5XG4gIGNvbnRlbnQsIHBhcmFtcywgZWwpIHtcbiAgICB2YXIgdmlld1dpZHRoID0gdGhpcy5fYXBpLmdldFdpZHRoKCk7XG4gICAgdmFyIHZpZXdIZWlnaHQgPSB0aGlzLl9hcGkuZ2V0SGVpZ2h0KCk7XG4gICAgcG9zaXRpb25FeHByID0gcG9zaXRpb25FeHByIHx8IHRvb2x0aXBNb2RlbC5nZXQoJ3Bvc2l0aW9uJyk7XG4gICAgdmFyIGNvbnRlbnRTaXplID0gY29udGVudC5nZXRTaXplKCk7XG4gICAgdmFyIGFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgnYWxpZ24nKTtcbiAgICB2YXIgdkFsaWduID0gdG9vbHRpcE1vZGVsLmdldCgndmVydGljYWxBbGlnbicpO1xuICAgIHZhciByZWN0ID0gZWwgJiYgZWwuZ2V0Qm91bmRpbmdSZWN0KCkuY2xvbmUoKTtcbiAgICBlbCAmJiByZWN0LmFwcGx5VHJhbnNmb3JtKGVsLnRyYW5zZm9ybSk7XG4gICAgaWYgKGlzRnVuY3Rpb24ocG9zaXRpb25FeHByKSkge1xuICAgICAgLy8gQ2FsbGJhY2sgb2YgcG9zaXRpb24gY2FuIGJlIGFuIGFycmF5IG9yIGEgc3RyaW5nIHNwZWNpZnkgdGhlIHBvc2l0aW9uXG4gICAgICBwb3NpdGlvbkV4cHIgPSBwb3NpdGlvbkV4cHIoW3gsIHldLCBwYXJhbXMsIGNvbnRlbnQuZWwsIHJlY3QsIHtcbiAgICAgICAgdmlld1NpemU6IFt2aWV3V2lkdGgsIHZpZXdIZWlnaHRdLFxuICAgICAgICBjb250ZW50U2l6ZTogY29udGVudFNpemUuc2xpY2UoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHBvc2l0aW9uRXhwcikpIHtcbiAgICAgIHggPSBwYXJzZVBlcmNlbnQocG9zaXRpb25FeHByWzBdLCB2aWV3V2lkdGgpO1xuICAgICAgeSA9IHBhcnNlUGVyY2VudChwb3NpdGlvbkV4cHJbMV0sIHZpZXdIZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb25FeHByKSkge1xuICAgICAgdmFyIGJveExheW91dFBvc2l0aW9uID0gcG9zaXRpb25FeHByO1xuICAgICAgYm94TGF5b3V0UG9zaXRpb24ud2lkdGggPSBjb250ZW50U2l6ZVswXTtcbiAgICAgIGJveExheW91dFBvc2l0aW9uLmhlaWdodCA9IGNvbnRlbnRTaXplWzFdO1xuICAgICAgdmFyIGxheW91dFJlY3QgPSBnZXRMYXlvdXRSZWN0KGJveExheW91dFBvc2l0aW9uLCB7XG4gICAgICAgIHdpZHRoOiB2aWV3V2lkdGgsXG4gICAgICAgIGhlaWdodDogdmlld0hlaWdodFxuICAgICAgfSk7XG4gICAgICB4ID0gbGF5b3V0UmVjdC54O1xuICAgICAgeSA9IGxheW91dFJlY3QueTtcbiAgICAgIGFsaWduID0gbnVsbDtcbiAgICAgIC8vIFdoZW4gcG9zaXRpb25FeHByIGlzIGxlZnQvdG9wL3JpZ2h0L2JvdHRvbSxcbiAgICAgIC8vIGFsaWduIGFuZCB2ZXJ0aWNhbEFsaWduIHdpbGwgbm90IHdvcmsuXG4gICAgICB2QWxpZ24gPSBudWxsO1xuICAgIH1cbiAgICAvLyBTcGVjaWZ5IHRvb2x0aXAgcG9zaXRpb24gYnkgc3RyaW5nICd0b3AnICdib3R0b20nICdsZWZ0JyAncmlnaHQnIGFyb3VuZCBncmFwaGljIGVsZW1lbnRcbiAgICBlbHNlIGlmIChpc1N0cmluZyhwb3NpdGlvbkV4cHIpICYmIGVsKSB7XG4gICAgICB2YXIgcG9zID0gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbkV4cHIsIHJlY3QsIGNvbnRlbnRTaXplLCB0b29sdGlwTW9kZWwuZ2V0KCdib3JkZXJXaWR0aCcpKTtcbiAgICAgIHggPSBwb3NbMF07XG4gICAgICB5ID0gcG9zWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcG9zID0gcmVmaXhUb29sdGlwUG9zaXRpb24oeCwgeSwgY29udGVudCwgdmlld1dpZHRoLCB2aWV3SGVpZ2h0LCBhbGlnbiA/IG51bGwgOiAyMCwgdkFsaWduID8gbnVsbCA6IDIwKTtcbiAgICAgIHggPSBwb3NbMF07XG4gICAgICB5ID0gcG9zWzFdO1xuICAgIH1cbiAgICBhbGlnbiAmJiAoeCAtPSBpc0NlbnRlckFsaWduKGFsaWduKSA/IGNvbnRlbnRTaXplWzBdIC8gMiA6IGFsaWduID09PSAncmlnaHQnID8gY29udGVudFNpemVbMF0gOiAwKTtcbiAgICB2QWxpZ24gJiYgKHkgLT0gaXNDZW50ZXJBbGlnbih2QWxpZ24pID8gY29udGVudFNpemVbMV0gLyAyIDogdkFsaWduID09PSAnYm90dG9tJyA/IGNvbnRlbnRTaXplWzFdIDogMCk7XG4gICAgaWYgKHNob3VsZFRvb2x0aXBDb25maW5lKHRvb2x0aXBNb2RlbCkpIHtcbiAgICAgIHZhciBwb3MgPSBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCk7XG4gICAgICB4ID0gcG9zWzBdO1xuICAgICAgeSA9IHBvc1sxXTtcbiAgICB9XG4gICAgY29udGVudC5tb3ZlVG8oeCwgeSk7XG4gIH07XG4gIC8vIEZJWE1FXG4gIC8vIFNob3VsZCB3ZSByZW1vdmUgdGhpcyBidXQgbGVhdmUgdGhpcyB0byB1c2VyP1xuICBUb29sdGlwVmlldy5wcm90b3R5cGUuX3VwZGF0ZUNvbnRlbnROb3RDaGFuZ2VkT25BeGlzID0gZnVuY3Rpb24gKGRhdGFCeUNvb3JkU3lzLCBjYlBhcmFtc0xpc3QpIHtcbiAgICB2YXIgbGFzdENvb3JkU3lzID0gdGhpcy5fbGFzdERhdGFCeUNvb3JkU3lzO1xuICAgIHZhciBsYXN0Q2JQYXJhbXNMaXN0ID0gdGhpcy5fY2JQYXJhbXNMaXN0O1xuICAgIHZhciBjb250ZW50Tm90Q2hhbmdlZCA9ICEhbGFzdENvb3JkU3lzICYmIGxhc3RDb29yZFN5cy5sZW5ndGggPT09IGRhdGFCeUNvb3JkU3lzLmxlbmd0aDtcbiAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RDb29yZFN5cywgZnVuY3Rpb24gKGxhc3RJdGVtQ29vcmRTeXMsIGluZGV4Q29vcmRTeXMpIHtcbiAgICAgIHZhciBsYXN0RGF0YUJ5QXhpcyA9IGxhc3RJdGVtQ29vcmRTeXMuZGF0YUJ5QXhpcyB8fCBbXTtcbiAgICAgIHZhciB0aGlzSXRlbUNvb3JkU3lzID0gZGF0YUJ5Q29vcmRTeXNbaW5kZXhDb29yZFN5c10gfHwge307XG4gICAgICB2YXIgdGhpc0RhdGFCeUF4aXMgPSB0aGlzSXRlbUNvb3JkU3lzLmRhdGFCeUF4aXMgfHwgW107XG4gICAgICBjb250ZW50Tm90Q2hhbmdlZCA9IGNvbnRlbnROb3RDaGFuZ2VkICYmIGxhc3REYXRhQnlBeGlzLmxlbmd0aCA9PT0gdGhpc0RhdGFCeUF4aXMubGVuZ3RoO1xuICAgICAgY29udGVudE5vdENoYW5nZWQgJiYgZWFjaChsYXN0RGF0YUJ5QXhpcywgZnVuY3Rpb24gKGxhc3RJdGVtLCBpbmRleEF4aXMpIHtcbiAgICAgICAgdmFyIHRoaXNJdGVtID0gdGhpc0RhdGFCeUF4aXNbaW5kZXhBeGlzXSB8fCB7fTtcbiAgICAgICAgdmFyIGxhc3RJbmRpY2VzID0gbGFzdEl0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgIHZhciBuZXdJbmRpY2VzID0gdGhpc0l0ZW0uc2VyaWVzRGF0YUluZGljZXMgfHwgW107XG4gICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkID0gY29udGVudE5vdENoYW5nZWQgJiYgbGFzdEl0ZW0udmFsdWUgPT09IHRoaXNJdGVtLnZhbHVlICYmIGxhc3RJdGVtLmF4aXNUeXBlID09PSB0aGlzSXRlbS5heGlzVHlwZSAmJiBsYXN0SXRlbS5heGlzSWQgPT09IHRoaXNJdGVtLmF4aXNJZCAmJiBsYXN0SW5kaWNlcy5sZW5ndGggPT09IG5ld0luZGljZXMubGVuZ3RoO1xuICAgICAgICBjb250ZW50Tm90Q2hhbmdlZCAmJiBlYWNoKGxhc3RJbmRpY2VzLCBmdW5jdGlvbiAobGFzdElkeEl0ZW0sIGopIHtcbiAgICAgICAgICB2YXIgbmV3SWR4SXRlbSA9IG5ld0luZGljZXNbal07XG4gICAgICAgICAgY29udGVudE5vdENoYW5nZWQgPSBjb250ZW50Tm90Q2hhbmdlZCAmJiBsYXN0SWR4SXRlbS5zZXJpZXNJbmRleCA9PT0gbmV3SWR4SXRlbS5zZXJpZXNJbmRleCAmJiBsYXN0SWR4SXRlbS5kYXRhSW5kZXggPT09IG5ld0lkeEl0ZW0uZGF0YUluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaXMgY2JQYXJhbXMgZGF0YSB2YWx1ZSBjaGFuZ2VkXG4gICAgICAgIGxhc3RDYlBhcmFtc0xpc3QgJiYgZWFjaChsYXN0SXRlbS5zZXJpZXNEYXRhSW5kaWNlcywgZnVuY3Rpb24gKGlkeEl0ZW0pIHtcbiAgICAgICAgICB2YXIgc2VyaWVzSWR4ID0gaWR4SXRlbS5zZXJpZXNJbmRleDtcbiAgICAgICAgICB2YXIgY2JQYXJhbXMgPSBjYlBhcmFtc0xpc3Rbc2VyaWVzSWR4XTtcbiAgICAgICAgICB2YXIgbGFzdENiUGFyYW1zID0gbGFzdENiUGFyYW1zTGlzdFtzZXJpZXNJZHhdO1xuICAgICAgICAgIGlmIChjYlBhcmFtcyAmJiBsYXN0Q2JQYXJhbXMgJiYgbGFzdENiUGFyYW1zLmRhdGEgIT09IGNiUGFyYW1zLmRhdGEpIHtcbiAgICAgICAgICAgIGNvbnRlbnROb3RDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX2xhc3REYXRhQnlDb29yZFN5cyA9IGRhdGFCeUNvb3JkU3lzO1xuICAgIHRoaXMuX2NiUGFyYW1zTGlzdCA9IGNiUGFyYW1zTGlzdDtcbiAgICByZXR1cm4gISFjb250ZW50Tm90Q2hhbmdlZDtcbiAgfTtcbiAgVG9vbHRpcFZpZXcucHJvdG90eXBlLl9oaWRlID0gZnVuY3Rpb24gKGRpc3BhdGNoQWN0aW9uKSB7XG4gICAgLy8gRG8gbm90IGRpcmVjdGx5IGhpZGVMYXRlciBoZXJlLCBiZWNhdXNlIHRoaXMgYmVoYXZpb3IgbWF5IGJlIHByZXZlbnRlZFxuICAgIC8vIGluIGRpc3BhdGNoQWN0aW9uIHdoZW4gc2hvd1RpcCBpcyBkaXNwYXRjaGVkLlxuICAgIC8vIEZJWE1FXG4gICAgLy8gZHVwbGljYXRlZCBoaWRlVGlwIGlmIG1hbnVhbGx5SGlkZVRpcCBpcyBjYWxsZWQgZnJvbSBkaXNwYXRjaEFjdGlvbi5cbiAgICB0aGlzLl9sYXN0RGF0YUJ5Q29vcmRTeXMgPSBudWxsO1xuICAgIGRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICAgIGZyb206IHRoaXMudWlkXG4gICAgfSk7XG4gIH07XG4gIFRvb2x0aXBWaWV3LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIGlmIChlbnYubm9kZSB8fCAhYXBpLmdldERvbSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyKHRoaXMsICdfdXBkYXRlUG9zaXRpb24nKTtcbiAgICB0aGlzLl90b29sdGlwQ29udGVudC5kaXNwb3NlKCk7XG4gICAgZ2xvYmFsTGlzdGVuZXIudW5yZWdpc3RlcignaXRlbVRvb2x0aXAnLCBhcGkpO1xuICB9O1xuICBUb29sdGlwVmlldy50eXBlID0gJ3Rvb2x0aXAnO1xuICByZXR1cm4gVG9vbHRpcFZpZXc7XG59KENvbXBvbmVudFZpZXcpO1xuLyoqXHJcbiAqIEZyb20gdG9wIHRvIGJvdHRvbS4gKHRoZSBsYXN0IG9uZSBzaG91bGQgYmUgZ2xvYmFsVG9vbHRpcE1vZGVsKTtcclxuICovXG5mdW5jdGlvbiBidWlsZFRvb2x0aXBNb2RlbChtb2RlbENhc2NhZGUsIGdsb2JhbFRvb2x0aXBNb2RlbCwgZGVmYXVsdFRvb2x0aXBPcHRpb24pIHtcbiAgLy8gTGFzdCBpcyBhbHdheXMgdG9vbHRpcCBtb2RlbC5cbiAgdmFyIGVjTW9kZWwgPSBnbG9iYWxUb29sdGlwTW9kZWwuZWNNb2RlbDtcbiAgdmFyIHJlc3VsdE1vZGVsO1xuICBpZiAoZGVmYXVsdFRvb2x0aXBPcHRpb24pIHtcbiAgICByZXN1bHRNb2RlbCA9IG5ldyBNb2RlbChkZWZhdWx0VG9vbHRpcE9wdGlvbiwgZWNNb2RlbCwgZWNNb2RlbCk7XG4gICAgcmVzdWx0TW9kZWwgPSBuZXcgTW9kZWwoZ2xvYmFsVG9vbHRpcE1vZGVsLm9wdGlvbiwgcmVzdWx0TW9kZWwsIGVjTW9kZWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdE1vZGVsID0gZ2xvYmFsVG9vbHRpcE1vZGVsO1xuICB9XG4gIGZvciAodmFyIGkgPSBtb2RlbENhc2NhZGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgdG9vbHRpcE9wdCA9IG1vZGVsQ2FzY2FkZVtpXTtcbiAgICBpZiAodG9vbHRpcE9wdCkge1xuICAgICAgaWYgKHRvb2x0aXBPcHQgaW5zdGFuY2VvZiBNb2RlbCkge1xuICAgICAgICB0b29sdGlwT3B0ID0gdG9vbHRpcE9wdC5nZXQoJ3Rvb2x0aXAnLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIC8vIEluIGVhY2ggZGF0YSBpdGVtIHRvb2x0aXAgY2FuIGJlIHNpbXBseSB3cml0ZTpcbiAgICAgIC8vIHtcbiAgICAgIC8vICB2YWx1ZTogMTAsXG4gICAgICAvLyAgdG9vbHRpcDogJ1NvbWV0aGluZyB5b3UgbmVlZCB0byBrbm93J1xuICAgICAgLy8gfVxuICAgICAgaWYgKGlzU3RyaW5nKHRvb2x0aXBPcHQpKSB7XG4gICAgICAgIHRvb2x0aXBPcHQgPSB7XG4gICAgICAgICAgZm9ybWF0dGVyOiB0b29sdGlwT3B0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBpZiAodG9vbHRpcE9wdCkge1xuICAgICAgICByZXN1bHRNb2RlbCA9IG5ldyBNb2RlbCh0b29sdGlwT3B0LCByZXN1bHRNb2RlbCwgZWNNb2RlbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRNb2RlbDtcbn1cbmZ1bmN0aW9uIG1ha2VEaXNwYXRjaEFjdGlvbihwYXlsb2FkLCBhcGkpIHtcbiAgcmV0dXJuIHBheWxvYWQuZGlzcGF0Y2hBY3Rpb24gfHwgYmluZChhcGkuZGlzcGF0Y2hBY3Rpb24sIGFwaSk7XG59XG5mdW5jdGlvbiByZWZpeFRvb2x0aXBQb3NpdGlvbih4LCB5LCBjb250ZW50LCB2aWV3V2lkdGgsIHZpZXdIZWlnaHQsIGdhcEgsIGdhcFYpIHtcbiAgdmFyIHNpemUgPSBjb250ZW50LmdldFNpemUoKTtcbiAgdmFyIHdpZHRoID0gc2l6ZVswXTtcbiAgdmFyIGhlaWdodCA9IHNpemVbMV07XG4gIGlmIChnYXBIICE9IG51bGwpIHtcbiAgICAvLyBBZGQgZXh0cmEgMiBwaXhlbHMgZm9yIHRoaXMgY2FzZTpcbiAgICAvLyBBdCBwcmVzZW50IHRoZSBcInZhbHVlc1wiIGluIGRlZmF1bHQgdG9vbHRpcCBhcmUgdXNpbmcgQ1NTIGBmbG9hdDogcmlnaHRgLlxuICAgIC8vIFdoZW4gdGhlIHJpZ2h0IGVkZ2Ugb2YgdGhlIHRvb2x0aXAgYm94IGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZVxuICAgIC8vIHZpZXdwb3J0LCB0aGUgYGZsb2F0YCBsYXlvdXQgbWlnaHQgcHVzaCB0aGUgXCJ2YWx1ZXNcIiB0byB0aGUgc2Vjb25kIGxpbmUuXG4gICAgaWYgKHggKyB3aWR0aCArIGdhcEggKyAyID4gdmlld1dpZHRoKSB7XG4gICAgICB4IC09IHdpZHRoICsgZ2FwSDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCArPSBnYXBIO1xuICAgIH1cbiAgfVxuICBpZiAoZ2FwViAhPSBudWxsKSB7XG4gICAgaWYgKHkgKyBoZWlnaHQgKyBnYXBWID4gdmlld0hlaWdodCkge1xuICAgICAgeSAtPSBoZWlnaHQgKyBnYXBWO1xuICAgIH0gZWxzZSB7XG4gICAgICB5ICs9IGdhcFY7XG4gICAgfVxuICB9XG4gIHJldHVybiBbeCwgeV07XG59XG5mdW5jdGlvbiBjb25maW5lVG9vbHRpcFBvc2l0aW9uKHgsIHksIGNvbnRlbnQsIHZpZXdXaWR0aCwgdmlld0hlaWdodCkge1xuICB2YXIgc2l6ZSA9IGNvbnRlbnQuZ2V0U2l6ZSgpO1xuICB2YXIgd2lkdGggPSBzaXplWzBdO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZVsxXTtcbiAgeCA9IE1hdGgubWluKHggKyB3aWR0aCwgdmlld1dpZHRoKSAtIHdpZHRoO1xuICB5ID0gTWF0aC5taW4oeSArIGhlaWdodCwgdmlld0hlaWdodCkgLSBoZWlnaHQ7XG4gIHggPSBNYXRoLm1heCh4LCAwKTtcbiAgeSA9IE1hdGgubWF4KHksIDApO1xuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gY2FsY1Rvb2x0aXBQb3NpdGlvbihwb3NpdGlvbiwgcmVjdCwgY29udGVudFNpemUsIGJvcmRlcldpZHRoKSB7XG4gIHZhciBkb21XaWR0aCA9IGNvbnRlbnRTaXplWzBdO1xuICB2YXIgZG9tSGVpZ2h0ID0gY29udGVudFNpemVbMV07XG4gIHZhciBvZmZzZXQgPSBNYXRoLmNlaWwoTWF0aC5TUVJUMiAqIGJvcmRlcldpZHRoKSArIDg7XG4gIHZhciB4ID0gMDtcbiAgdmFyIHkgPSAwO1xuICB2YXIgcmVjdFdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIHJlY3RIZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoIC8gMiAtIGRvbVdpZHRoIC8gMjtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0b3AnOlxuICAgICAgeCA9IHJlY3QueCArIHJlY3RXaWR0aCAvIDIgLSBkb21XaWR0aCAvIDI7XG4gICAgICB5ID0gcmVjdC55IC0gZG9tSGVpZ2h0IC0gb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggPSByZWN0LnggKyByZWN0V2lkdGggLyAyIC0gZG9tV2lkdGggLyAyO1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgKyBvZmZzZXQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIHggPSByZWN0LnggLSBkb21XaWR0aCAtIG9mZnNldDtcbiAgICAgIHkgPSByZWN0LnkgKyByZWN0SGVpZ2h0IC8gMiAtIGRvbUhlaWdodCAvIDI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB4ID0gcmVjdC54ICsgcmVjdFdpZHRoICsgb2Zmc2V0O1xuICAgICAgeSA9IHJlY3QueSArIHJlY3RIZWlnaHQgLyAyIC0gZG9tSGVpZ2h0IC8gMjtcbiAgfVxuICByZXR1cm4gW3gsIHldO1xufVxuZnVuY3Rpb24gaXNDZW50ZXJBbGlnbihhbGlnbikge1xuICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInIHx8IGFsaWduID09PSAnbWlkZGxlJztcbn1cbi8qKlxyXG4gKiBGaW5kIHRhcmdldCBjb21wb25lbnQgYnkgcGF5bG9hZCBsaWtlOlxyXG4gKiBgYGBqc1xyXG4gKiB7IGxlZ2VuZElkOiAnc29tZV9pZCcsIG5hbWU6ICd4eHgnIH1cclxuICogeyB0b29sYm94SW5kZXg6IDEsIG5hbWU6ICd4eHgnIH1cclxuICogeyBnZW9OYW1lOiAnc29tZV9uYW1lJywgbmFtZTogJ3h4eCcgfVxyXG4gKiBgYGBcclxuICogUEVORElORzogYXQgcHJlc2VudCBvbmx5XHJcbiAqXHJcbiAqIElmIG5vdCBmb3VuZCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxyXG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21wb25lbnRSZWZlcmVuY2UocGF5bG9hZCwgZWNNb2RlbCwgYXBpKSB7XG4gIHZhciBxdWVyeU9wdGlvbk1hcCA9IHByZVBhcnNlRmluZGVyKHBheWxvYWQpLnF1ZXJ5T3B0aW9uTWFwO1xuICB2YXIgY29tcG9uZW50TWFpblR5cGUgPSBxdWVyeU9wdGlvbk1hcC5rZXlzKClbMF07XG4gIGlmICghY29tcG9uZW50TWFpblR5cGUgfHwgY29tcG9uZW50TWFpblR5cGUgPT09ICdzZXJpZXMnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBxdWVyeVJlc3VsdCA9IHF1ZXJ5UmVmZXJyaW5nQ29tcG9uZW50cyhlY01vZGVsLCBjb21wb25lbnRNYWluVHlwZSwgcXVlcnlPcHRpb25NYXAuZ2V0KGNvbXBvbmVudE1haW5UeXBlKSwge1xuICAgIHVzZURlZmF1bHQ6IGZhbHNlLFxuICAgIGVuYWJsZUFsbDogZmFsc2UsXG4gICAgZW5hYmxlTm9uZTogZmFsc2VcbiAgfSk7XG4gIHZhciBtb2RlbCA9IHF1ZXJ5UmVzdWx0Lm1vZGVsc1swXTtcbiAgaWYgKCFtb2RlbCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdmlldyA9IGFwaS5nZXRWaWV3T2ZDb21wb25lbnRNb2RlbChtb2RlbCk7XG4gIHZhciBlbDtcbiAgdmlldy5ncm91cC50cmF2ZXJzZShmdW5jdGlvbiAoc3ViRWwpIHtcbiAgICB2YXIgdG9vbHRpcENvbmZpZyA9IGdldEVDRGF0YShzdWJFbCkudG9vbHRpcENvbmZpZztcbiAgICBpZiAodG9vbHRpcENvbmZpZyAmJiB0b29sdGlwQ29uZmlnLm5hbWUgPT09IHBheWxvYWQubmFtZSkge1xuICAgICAgZWwgPSBzdWJFbDtcbiAgICAgIHJldHVybiB0cnVlOyAvLyBzdG9wXG4gICAgfVxuICB9KTtcbiAgaWYgKGVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBvbmVudE1haW5UeXBlOiBjb21wb25lbnRNYWluVHlwZSxcbiAgICAgIGNvbXBvbmVudEluZGV4OiBtb2RlbC5jb21wb25lbnRJbmRleCxcbiAgICAgIGVsOiBlbFxuICAgIH07XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBWaWV3OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsQXhpc1BvaW50ZXIgfSBmcm9tICcuLi9heGlzUG9pbnRlci9pbnN0YWxsLmpzJztcbmltcG9ydCB7IHVzZSB9IGZyb20gJy4uLy4uL2V4dGVuc2lvbi5qcyc7XG5pbXBvcnQgVG9vbHRpcE1vZGVsIGZyb20gJy4vVG9vbHRpcE1vZGVsLmpzJztcbmltcG9ydCBUb29sdGlwVmlldyBmcm9tICcuL1Rvb2x0aXBWaWV3LmpzJztcbmltcG9ydCB7IG5vb3AgfSBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbGwocmVnaXN0ZXJzKSB7XG4gIHVzZShpbnN0YWxsQXhpc1BvaW50ZXIpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChUb29sdGlwTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KFRvb2x0aXBWaWV3KTtcbiAgLyoqXHJcbiAgICogQGFjdGlvblxyXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0eXBlXHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNlcmllc0luZGV4XHJcbiAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGFJbmRleFxyXG4gICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbeF1cclxuICAgKiBAcHJvcGVydHkge251bWJlcn0gW3ldXHJcbiAgICovXG4gIHJlZ2lzdGVycy5yZWdpc3RlckFjdGlvbih7XG4gICAgdHlwZTogJ3Nob3dUaXAnLFxuICAgIGV2ZW50OiAnc2hvd1RpcCcsXG4gICAgdXBkYXRlOiAndG9vbHRpcDptYW51YWxseVNob3dUaXAnXG4gIH0sIG5vb3ApO1xuICByZWdpc3RlcnMucmVnaXN0ZXJBY3Rpb24oe1xuICAgIHR5cGU6ICdoaWRlVGlwJyxcbiAgICBldmVudDogJ2hpZGVUaXAnLFxuICAgIHVwZGF0ZTogJ3Rvb2x0aXA6bWFudWFsbHlIaWRlVGlwJ1xuICB9LCBub29wKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///6641\n")},26192:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _visual_visualDefault_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(54942);\n/* harmony import */ var _visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7857);\n/* harmony import */ var _visual_visualSolution_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6372);\n/* harmony import */ var _util_model_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(48170);\n/* harmony import */ var _util_number_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24326);\n/* harmony import */ var _model_Component_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(15915);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar mapVisual = _visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.mapVisual;\nvar eachVisual = _visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.eachVisual;\nvar isArray = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray;\nvar each = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each;\nvar asc = _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .asc */ .Y6;\nvar linearMap = _util_number_js__WEBPACK_IMPORTED_MODULE_2__/* .linearMap */ .Cb;\nvar VisualMapModel = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_3__/* .__extends */ .C6)(VisualMapModel, _super);\n  function VisualMapModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = VisualMapModel.type;\n    _this.stateList = ['inRange', 'outOfRange'];\n    _this.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color'];\n    _this.layoutMode = {\n      type: 'box',\n      ignoreSize: true\n    };\n    /**\r\n     * [lowerBound, upperBound]\r\n     */\n    _this.dataBound = [-Infinity, Infinity];\n    _this.targetVisuals = {};\n    _this.controllerVisuals = {};\n    return _this;\n  }\n  VisualMapModel.prototype.init = function (option, parentModel, ecModel) {\n    this.mergeDefaultAndTheme(option, ecModel);\n  };\n  /**\r\n   * @protected\r\n   */\n  VisualMapModel.prototype.optionUpdated = function (newOption, isInit) {\n    var thisOption = this.option;\n    !isInit && _visual_visualSolution_js__WEBPACK_IMPORTED_MODULE_4__/* .replaceVisualOption */ .St(thisOption, newOption, this.replacableOptionKeys);\n    this.textStyleModel = this.getModel('textStyle');\n    this.resetItemSize();\n    this.completeVisualOption();\n  };\n  /**\r\n   * @protected\r\n   */\n  VisualMapModel.prototype.resetVisual = function (supplementVisualOption) {\n    var stateList = this.stateList;\n    supplementVisualOption = zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.bind(supplementVisualOption, this);\n    this.controllerVisuals = _visual_visualSolution_js__WEBPACK_IMPORTED_MODULE_4__/* .createVisualMappings */ .u1(this.option.controller, stateList, supplementVisualOption);\n    this.targetVisuals = _visual_visualSolution_js__WEBPACK_IMPORTED_MODULE_4__/* .createVisualMappings */ .u1(this.option.target, stateList, supplementVisualOption);\n  };\n  /**\r\n   * @public\r\n   */\n  VisualMapModel.prototype.getItemSymbol = function () {\n    return null;\n  };\n  /**\r\n   * @protected\r\n   * @return {Array.<number>} An array of series indices.\r\n   */\n  VisualMapModel.prototype.getTargetSeriesIndices = function () {\n    var optionSeriesIndex = this.option.seriesIndex;\n    var seriesIndices = [];\n    if (optionSeriesIndex == null || optionSeriesIndex === 'all') {\n      this.ecModel.eachSeries(function (seriesModel, index) {\n        seriesIndices.push(index);\n      });\n    } else {\n      seriesIndices = _util_model_js__WEBPACK_IMPORTED_MODULE_5__/* .normalizeToArray */ .qB(optionSeriesIndex);\n    }\n    return seriesIndices;\n  };\n  /**\r\n   * @public\r\n   */\n  VisualMapModel.prototype.eachTargetSeries = function (callback, context) {\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(this.getTargetSeriesIndices(), function (seriesIndex) {\n      var seriesModel = this.ecModel.getSeriesByIndex(seriesIndex);\n      if (seriesModel) {\n        callback.call(context, seriesModel);\n      }\n    }, this);\n  };\n  /**\r\n   * @pubilc\r\n   */\n  VisualMapModel.prototype.isTargetSeries = function (seriesModel) {\n    var is = false;\n    this.eachTargetSeries(function (model) {\n      model === seriesModel && (is = true);\n    });\n    return is;\n  };\n  /**\r\n   * @example\r\n   * this.formatValueText(someVal); // format single numeric value to text.\r\n   * this.formatValueText(someVal, true); // format single category value to text.\r\n   * this.formatValueText([min, max]); // format numeric min-max to text.\r\n   * this.formatValueText([this.dataBound[0], max]); // using data lower bound.\r\n   * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.\r\n   *\r\n   * @param value Real value, or this.dataBound[0 or 1].\r\n   * @param isCategory Only available when value is number.\r\n   * @param edgeSymbols Open-close symbol when value is interval.\r\n   * @protected\r\n   */\n  VisualMapModel.prototype.formatValueText = function (value, isCategory, edgeSymbols) {\n    var option = this.option;\n    var precision = option.precision;\n    var dataBound = this.dataBound;\n    var formatter = option.formatter;\n    var isMinMax;\n    edgeSymbols = edgeSymbols || ['<', '>'];\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isArray(value)) {\n      value = value.slice();\n      isMinMax = true;\n    }\n    var textValue = isCategory ? value // Value is string when isCategory\n    : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value);\n    if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isString(formatter)) {\n      return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);\n    } else if (zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.isFunction(formatter)) {\n      return isMinMax ? formatter(value[0], value[1]) : formatter(value);\n    }\n    if (isMinMax) {\n      if (value[0] === dataBound[0]) {\n        return edgeSymbols[0] + ' ' + textValue[1];\n      } else if (value[1] === dataBound[1]) {\n        return edgeSymbols[1] + ' ' + textValue[0];\n      } else {\n        return textValue[0] + ' - ' + textValue[1];\n      }\n    } else {\n      // Format single value (includes category case).\n      return textValue;\n    }\n    function toFixed(val) {\n      return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20));\n    }\n  };\n  /**\r\n   * @protected\r\n   */\n  VisualMapModel.prototype.resetExtent = function () {\n    var thisOption = this.option;\n    // Can not calculate data extent by data here.\n    // Because series and data may be modified in processing stage.\n    // So we do not support the feature \"auto min/max\".\n    var extent = asc([thisOption.min, thisOption.max]);\n    this._dataExtent = extent;\n  };\n  /**\r\n   * PENDING:\r\n   * delete this method if no outer usage.\r\n   *\r\n   * Return  Concrete dimension. If null/undefined is returned, no dimension is used.\r\n   */\n  // getDataDimension(data: SeriesData) {\n  //     const optDim = this.option.dimension;\n  //     if (optDim != null) {\n  //         return data.getDimension(optDim);\n  //     }\n  //     const dimNames = data.dimensions;\n  //     for (let i = dimNames.length - 1; i >= 0; i--) {\n  //         const dimName = dimNames[i];\n  //         const dimInfo = data.getDimensionInfo(dimName);\n  //         if (!dimInfo.isCalculationCoord) {\n  //             return dimName;\n  //         }\n  //     }\n  // }\n  VisualMapModel.prototype.getDataDimensionIndex = function (data) {\n    var optDim = this.option.dimension;\n    if (optDim != null) {\n      return data.getDimensionIndex(optDim);\n    }\n    var dimNames = data.dimensions;\n    for (var i = dimNames.length - 1; i >= 0; i--) {\n      var dimName = dimNames[i];\n      var dimInfo = data.getDimensionInfo(dimName);\n      if (!dimInfo.isCalculationCoord) {\n        return dimInfo.storeDimIndex;\n      }\n    }\n  };\n  VisualMapModel.prototype.getExtent = function () {\n    return this._dataExtent.slice();\n  };\n  VisualMapModel.prototype.completeVisualOption = function () {\n    var ecModel = this.ecModel;\n    var thisOption = this.option;\n    var base = {\n      inRange: thisOption.inRange,\n      outOfRange: thisOption.outOfRange\n    };\n    var target = thisOption.target || (thisOption.target = {});\n    var controller = thisOption.controller || (thisOption.controller = {});\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge(target, base); // Do not override\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.merge(controller, base); // Do not override\n    var isCategory = this.isCategory();\n    completeSingle.call(this, target);\n    completeSingle.call(this, controller);\n    completeInactive.call(this, target, 'inRange', 'outOfRange');\n    // completeInactive.call(this, target, 'outOfRange', 'inRange');\n    completeController.call(this, controller);\n    function completeSingle(base) {\n      // Compatible with ec2 dataRange.color.\n      // The mapping order of dataRange.color is: [high value, ..., low value]\n      // whereas inRange.color and outOfRange.color is [low value, ..., high value]\n      // Notice: ec2 has no inverse.\n      if (isArray(thisOption.color)\n      // If there has been inRange: {symbol: ...}, adding color is a mistake.\n      // So adding color only when no inRange defined.\n      && !base.inRange) {\n        base.inRange = {\n          color: thisOption.color.slice().reverse()\n        };\n      }\n      // Compatible with previous logic, always give a default color, otherwise\n      // simple config with no inRange and outOfRange will not work.\n      // Originally we use visualMap.color as the default color, but setOption at\n      // the second time the default color will be erased. So we change to use\n      // constant DEFAULT_COLOR.\n      // If user do not want the default color, set inRange: {color: null}.\n      base.inRange = base.inRange || {\n        color: ecModel.get('gradientColor')\n      };\n    }\n    function completeInactive(base, stateExist, stateAbsent) {\n      var optExist = base[stateExist];\n      var optAbsent = base[stateAbsent];\n      if (optExist && !optAbsent) {\n        optAbsent = base[stateAbsent] = {};\n        each(optExist, function (visualData, visualType) {\n          if (!_visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_0__/* [\"default\"] */ .A.isValidType(visualType)) {\n            return;\n          }\n          var defa = _visual_visualDefault_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A.get(visualType, 'inactive', isCategory);\n          if (defa != null) {\n            optAbsent[visualType] = defa;\n            // Compatibable with ec2:\n            // Only inactive color to rgba(0,0,0,0) can not\n            // make label transparent, so use opacity also.\n            if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {\n              optAbsent.opacity = [0, 0];\n            }\n          }\n        });\n      }\n    }\n    function completeController(controller) {\n      var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;\n      var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;\n      var inactiveColor = this.get('inactiveColor');\n      var itemSymbol = this.getItemSymbol();\n      var defaultSymbol = itemSymbol || 'roundRect';\n      each(this.stateList, function (state) {\n        var itemSize = this.itemSize;\n        var visuals = controller[state];\n        // Set inactive color for controller if no other color\n        // attr (like colorAlpha) specified.\n        if (!visuals) {\n          visuals = controller[state] = {\n            color: isCategory ? inactiveColor : [inactiveColor]\n          };\n        }\n        // Consistent symbol and symbolSize if not specified.\n        if (visuals.symbol == null) {\n          visuals.symbol = symbolExists && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone(symbolExists) || (isCategory ? defaultSymbol : [defaultSymbol]);\n        }\n        if (visuals.symbolSize == null) {\n          visuals.symbolSize = symbolSizeExists && zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]]);\n        }\n        // Filter none\n        visuals.symbol = mapVisual(visuals.symbol, function (symbol) {\n          return symbol === 'none' ? defaultSymbol : symbol;\n        });\n        // Normalize symbolSize\n        var symbolSize = visuals.symbolSize;\n        if (symbolSize != null) {\n          var max_1 = -Infinity;\n          // symbolSize can be object when categories defined.\n          eachVisual(symbolSize, function (value) {\n            value > max_1 && (max_1 = value);\n          });\n          visuals.symbolSize = mapVisual(symbolSize, function (value) {\n            return linearMap(value, [0, max_1], [0, itemSize[0]], true);\n          });\n        }\n      }, this);\n    }\n  };\n  VisualMapModel.prototype.resetItemSize = function () {\n    this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))];\n  };\n  VisualMapModel.prototype.isCategory = function () {\n    return !!this.option.categories;\n  };\n  /**\r\n   * @public\r\n   * @abstract\r\n   */\n  VisualMapModel.prototype.setSelected = function (selected) {};\n  VisualMapModel.prototype.getSelected = function () {\n    return null;\n  };\n  /**\r\n   * @public\r\n   * @abstract\r\n   */\n  VisualMapModel.prototype.getValueState = function (value) {\n    return null;\n  };\n  /**\r\n   * FIXME\r\n   * Do not publish to thirt-part-dev temporarily\r\n   * util the interface is stable. (Should it return\r\n   * a function but not visual meta?)\r\n   *\r\n   * @pubilc\r\n   * @abstract\r\n   * @param getColorVisual\r\n   *        params: value, valueState\r\n   *        return: color\r\n   * @return {Object} visualMeta\r\n   *        should includes {stops, outerColors}\r\n   *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]\r\n   */\n  VisualMapModel.prototype.getVisualMeta = function (getColorVisual) {\n    return null;\n  };\n  VisualMapModel.type = 'visualMap';\n  VisualMapModel.dependencies = ['series'];\n  VisualMapModel.defaultOption = {\n    show: true,\n    // zlevel: 0,\n    z: 4,\n    seriesIndex: 'all',\n    min: 0,\n    max: 200,\n    left: 0,\n    right: null,\n    top: null,\n    bottom: 0,\n    itemWidth: null,\n    itemHeight: null,\n    inverse: false,\n    orient: 'vertical',\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderColor: '#ccc',\n    contentColor: '#5793f3',\n    inactiveColor: '#aaa',\n    borderWidth: 0,\n    padding: 5,\n    // css\n    textGap: 10,\n    precision: 0,\n    textStyle: {\n      color: '#333' // \n    }\n  };\n  return VisualMapModel;\n}(_model_Component_js__WEBPACK_IMPORTED_MODULE_7__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisualMapModel);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjYxOTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL1Zpc3VhbE1hcE1vZGVsLmpzPzE0M2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IHZpc3VhbERlZmF1bHQgZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbERlZmF1bHQuanMnO1xuaW1wb3J0IFZpc3VhbE1hcHBpbmcgZnJvbSAnLi4vLi4vdmlzdWFsL1Zpc3VhbE1hcHBpbmcuanMnO1xuaW1wb3J0ICogYXMgdmlzdWFsU29sdXRpb24gZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbFNvbHV0aW9uLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IENvbXBvbmVudE1vZGVsIGZyb20gJy4uLy4uL21vZGVsL0NvbXBvbmVudC5qcyc7XG52YXIgbWFwVmlzdWFsID0gVmlzdWFsTWFwcGluZy5tYXBWaXN1YWw7XG52YXIgZWFjaFZpc3VhbCA9IFZpc3VhbE1hcHBpbmcuZWFjaFZpc3VhbDtcbnZhciBpc0FycmF5ID0genJVdGlsLmlzQXJyYXk7XG52YXIgZWFjaCA9IHpyVXRpbC5lYWNoO1xudmFyIGFzYyA9IG51bWJlclV0aWwuYXNjO1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xudmFyIFZpc3VhbE1hcE1vZGVsID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFZpc3VhbE1hcE1vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBWaXN1YWxNYXBNb2RlbCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVmlzdWFsTWFwTW9kZWwudHlwZTtcbiAgICBfdGhpcy5zdGF0ZUxpc3QgPSBbJ2luUmFuZ2UnLCAnb3V0T2ZSYW5nZSddO1xuICAgIF90aGlzLnJlcGxhY2FibGVPcHRpb25LZXlzID0gWydpblJhbmdlJywgJ291dE9mUmFuZ2UnLCAndGFyZ2V0JywgJ2NvbnRyb2xsZXInLCAnY29sb3InXTtcbiAgICBfdGhpcy5sYXlvdXRNb2RlID0ge1xuICAgICAgdHlwZTogJ2JveCcsXG4gICAgICBpZ25vcmVTaXplOiB0cnVlXG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFtsb3dlckJvdW5kLCB1cHBlckJvdW5kXVxyXG4gICAgICovXG4gICAgX3RoaXMuZGF0YUJvdW5kID0gWy1JbmZpbml0eSwgSW5maW5pdHldO1xuICAgIF90aGlzLnRhcmdldFZpc3VhbHMgPSB7fTtcbiAgICBfdGhpcy5jb250cm9sbGVyVmlzdWFscyA9IHt9O1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBWaXN1YWxNYXBNb2RlbC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb24sIHBhcmVudE1vZGVsLCBlY01vZGVsKSB7XG4gICAgdGhpcy5tZXJnZURlZmF1bHRBbmRUaGVtZShvcHRpb24sIGVjTW9kZWwpO1xuICB9O1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICAhaXNJbml0ICYmIHZpc3VhbFNvbHV0aW9uLnJlcGxhY2VWaXN1YWxPcHRpb24odGhpc09wdGlvbiwgbmV3T3B0aW9uLCB0aGlzLnJlcGxhY2FibGVPcHRpb25LZXlzKTtcbiAgICB0aGlzLnRleHRTdHlsZU1vZGVsID0gdGhpcy5nZXRNb2RlbCgndGV4dFN0eWxlJyk7XG4gICAgdGhpcy5yZXNldEl0ZW1TaXplKCk7XG4gICAgdGhpcy5jb21wbGV0ZVZpc3VhbE9wdGlvbigpO1xuICB9O1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5yZXNldFZpc3VhbCA9IGZ1bmN0aW9uIChzdXBwbGVtZW50VmlzdWFsT3B0aW9uKSB7XG4gICAgdmFyIHN0YXRlTGlzdCA9IHRoaXMuc3RhdGVMaXN0O1xuICAgIHN1cHBsZW1lbnRWaXN1YWxPcHRpb24gPSB6clV0aWwuYmluZChzdXBwbGVtZW50VmlzdWFsT3B0aW9uLCB0aGlzKTtcbiAgICB0aGlzLmNvbnRyb2xsZXJWaXN1YWxzID0gdmlzdWFsU29sdXRpb24uY3JlYXRlVmlzdWFsTWFwcGluZ3ModGhpcy5vcHRpb24uY29udHJvbGxlciwgc3RhdGVMaXN0LCBzdXBwbGVtZW50VmlzdWFsT3B0aW9uKTtcbiAgICB0aGlzLnRhcmdldFZpc3VhbHMgPSB2aXN1YWxTb2x1dGlvbi5jcmVhdGVWaXN1YWxNYXBwaW5ncyh0aGlzLm9wdGlvbi50YXJnZXQsIHN0YXRlTGlzdCwgc3VwcGxlbWVudFZpc3VhbE9wdGlvbik7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmdldEl0ZW1TeW1ib2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gQW4gYXJyYXkgb2Ygc2VyaWVzIGluZGljZXMuXHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRUYXJnZXRTZXJpZXNJbmRpY2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb25TZXJpZXNJbmRleCA9IHRoaXMub3B0aW9uLnNlcmllc0luZGV4O1xuICAgIHZhciBzZXJpZXNJbmRpY2VzID0gW107XG4gICAgaWYgKG9wdGlvblNlcmllc0luZGV4ID09IG51bGwgfHwgb3B0aW9uU2VyaWVzSW5kZXggPT09ICdhbGwnKSB7XG4gICAgICB0aGlzLmVjTW9kZWwuZWFjaFNlcmllcyhmdW5jdGlvbiAoc2VyaWVzTW9kZWwsIGluZGV4KSB7XG4gICAgICAgIHNlcmllc0luZGljZXMucHVzaChpbmRleCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWVzSW5kaWNlcyA9IG1vZGVsVXRpbC5ub3JtYWxpemVUb0FycmF5KG9wdGlvblNlcmllc0luZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHNlcmllc0luZGljZXM7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKi9cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmVhY2hUYXJnZXRTZXJpZXMgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB6clV0aWwuZWFjaCh0aGlzLmdldFRhcmdldFNlcmllc0luZGljZXMoKSwgZnVuY3Rpb24gKHNlcmllc0luZGV4KSB7XG4gICAgICB2YXIgc2VyaWVzTW9kZWwgPSB0aGlzLmVjTW9kZWwuZ2V0U2VyaWVzQnlJbmRleChzZXJpZXNJbmRleCk7XG4gICAgICBpZiAoc2VyaWVzTW9kZWwpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChjb250ZXh0LCBzZXJpZXNNb2RlbCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwdWJpbGNcclxuICAgKi9cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmlzVGFyZ2V0U2VyaWVzID0gZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgdmFyIGlzID0gZmFsc2U7XG4gICAgdGhpcy5lYWNoVGFyZ2V0U2VyaWVzKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgbW9kZWwgPT09IHNlcmllc01vZGVsICYmIChpcyA9IHRydWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpcztcbiAgfTtcbiAgLyoqXHJcbiAgICogQGV4YW1wbGVcclxuICAgKiB0aGlzLmZvcm1hdFZhbHVlVGV4dChzb21lVmFsKTsgLy8gZm9ybWF0IHNpbmdsZSBudW1lcmljIHZhbHVlIHRvIHRleHQuXHJcbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoc29tZVZhbCwgdHJ1ZSk7IC8vIGZvcm1hdCBzaW5nbGUgY2F0ZWdvcnkgdmFsdWUgdG8gdGV4dC5cclxuICAgKiB0aGlzLmZvcm1hdFZhbHVlVGV4dChbbWluLCBtYXhdKTsgLy8gZm9ybWF0IG51bWVyaWMgbWluLW1heCB0byB0ZXh0LlxyXG4gICAqIHRoaXMuZm9ybWF0VmFsdWVUZXh0KFt0aGlzLmRhdGFCb3VuZFswXSwgbWF4XSk7IC8vIHVzaW5nIGRhdGEgbG93ZXIgYm91bmQuXHJcbiAgICogdGhpcy5mb3JtYXRWYWx1ZVRleHQoW21pbiwgdGhpcy5kYXRhQm91bmRbMV1dKTsgLy8gdXNpbmcgZGF0YSB1cHBlciBib3VuZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB2YWx1ZSBSZWFsIHZhbHVlLCBvciB0aGlzLmRhdGFCb3VuZFswIG9yIDFdLlxyXG4gICAqIEBwYXJhbSBpc0NhdGVnb3J5IE9ubHkgYXZhaWxhYmxlIHdoZW4gdmFsdWUgaXMgbnVtYmVyLlxyXG4gICAqIEBwYXJhbSBlZGdlU3ltYm9scyBPcGVuLWNsb3NlIHN5bWJvbCB3aGVuIHZhbHVlIGlzIGludGVydmFsLlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKi9cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmZvcm1hdFZhbHVlVGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNDYXRlZ29yeSwgZWRnZVN5bWJvbHMpIHtcbiAgICB2YXIgb3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIHByZWNpc2lvbiA9IG9wdGlvbi5wcmVjaXNpb247XG4gICAgdmFyIGRhdGFCb3VuZCA9IHRoaXMuZGF0YUJvdW5kO1xuICAgIHZhciBmb3JtYXR0ZXIgPSBvcHRpb24uZm9ybWF0dGVyO1xuICAgIHZhciBpc01pbk1heDtcbiAgICBlZGdlU3ltYm9scyA9IGVkZ2VTeW1ib2xzIHx8IFsnPCcsICc+J107XG4gICAgaWYgKHpyVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgpO1xuICAgICAgaXNNaW5NYXggPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgdGV4dFZhbHVlID0gaXNDYXRlZ29yeSA/IHZhbHVlIC8vIFZhbHVlIGlzIHN0cmluZyB3aGVuIGlzQ2F0ZWdvcnlcbiAgICA6IGlzTWluTWF4ID8gW3RvRml4ZWQodmFsdWVbMF0pLCB0b0ZpeGVkKHZhbHVlWzFdKV0gOiB0b0ZpeGVkKHZhbHVlKTtcbiAgICBpZiAoenJVdGlsLmlzU3RyaW5nKGZvcm1hdHRlcikpIHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIucmVwbGFjZSgne3ZhbHVlfScsIGlzTWluTWF4ID8gdGV4dFZhbHVlWzBdIDogdGV4dFZhbHVlKS5yZXBsYWNlKCd7dmFsdWUyfScsIGlzTWluTWF4ID8gdGV4dFZhbHVlWzFdIDogdGV4dFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0Z1bmN0aW9uKGZvcm1hdHRlcikpIHtcbiAgICAgIHJldHVybiBpc01pbk1heCA/IGZvcm1hdHRlcih2YWx1ZVswXSwgdmFsdWVbMV0pIDogZm9ybWF0dGVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKGlzTWluTWF4KSB7XG4gICAgICBpZiAodmFsdWVbMF0gPT09IGRhdGFCb3VuZFswXSkge1xuICAgICAgICByZXR1cm4gZWRnZVN5bWJvbHNbMF0gKyAnICcgKyB0ZXh0VmFsdWVbMV07XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlWzFdID09PSBkYXRhQm91bmRbMV0pIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VTeW1ib2xzWzFdICsgJyAnICsgdGV4dFZhbHVlWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRleHRWYWx1ZVswXSArICcgLSAnICsgdGV4dFZhbHVlWzFdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3JtYXQgc2luZ2xlIHZhbHVlIChpbmNsdWRlcyBjYXRlZ29yeSBjYXNlKS5cbiAgICAgIHJldHVybiB0ZXh0VmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvRml4ZWQodmFsKSB7XG4gICAgICByZXR1cm4gdmFsID09PSBkYXRhQm91bmRbMF0gPyAnbWluJyA6IHZhbCA9PT0gZGF0YUJvdW5kWzFdID8gJ21heCcgOiAoK3ZhbCkudG9GaXhlZChNYXRoLm1pbihwcmVjaXNpb24sIDIwKSk7XG4gICAgfVxuICB9O1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5yZXNldEV4dGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIC8vIENhbiBub3QgY2FsY3VsYXRlIGRhdGEgZXh0ZW50IGJ5IGRhdGEgaGVyZS5cbiAgICAvLyBCZWNhdXNlIHNlcmllcyBhbmQgZGF0YSBtYXkgYmUgbW9kaWZpZWQgaW4gcHJvY2Vzc2luZyBzdGFnZS5cbiAgICAvLyBTbyB3ZSBkbyBub3Qgc3VwcG9ydCB0aGUgZmVhdHVyZSBcImF1dG8gbWluL21heFwiLlxuICAgIHZhciBleHRlbnQgPSBhc2MoW3RoaXNPcHRpb24ubWluLCB0aGlzT3B0aW9uLm1heF0pO1xuICAgIHRoaXMuX2RhdGFFeHRlbnQgPSBleHRlbnQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIFBFTkRJTkc6XHJcbiAgICogZGVsZXRlIHRoaXMgbWV0aG9kIGlmIG5vIG91dGVyIHVzYWdlLlxyXG4gICAqXHJcbiAgICogUmV0dXJuICBDb25jcmV0ZSBkaW1lbnNpb24uIElmIG51bGwvdW5kZWZpbmVkIGlzIHJldHVybmVkLCBubyBkaW1lbnNpb24gaXMgdXNlZC5cclxuICAgKi9cbiAgLy8gZ2V0RGF0YURpbWVuc2lvbihkYXRhOiBTZXJpZXNEYXRhKSB7XG4gIC8vICAgICBjb25zdCBvcHREaW0gPSB0aGlzLm9wdGlvbi5kaW1lbnNpb247XG4gIC8vICAgICBpZiAob3B0RGltICE9IG51bGwpIHtcbiAgLy8gICAgICAgICByZXR1cm4gZGF0YS5nZXREaW1lbnNpb24ob3B0RGltKTtcbiAgLy8gICAgIH1cbiAgLy8gICAgIGNvbnN0IGRpbU5hbWVzID0gZGF0YS5kaW1lbnNpb25zO1xuICAvLyAgICAgZm9yIChsZXQgaSA9IGRpbU5hbWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gIC8vICAgICAgICAgY29uc3QgZGltTmFtZSA9IGRpbU5hbWVzW2ldO1xuICAvLyAgICAgICAgIGNvbnN0IGRpbUluZm8gPSBkYXRhLmdldERpbWVuc2lvbkluZm8oZGltTmFtZSk7XG4gIC8vICAgICAgICAgaWYgKCFkaW1JbmZvLmlzQ2FsY3VsYXRpb25Db29yZCkge1xuICAvLyAgICAgICAgICAgICByZXR1cm4gZGltTmFtZTtcbiAgLy8gICAgICAgICB9XG4gIC8vICAgICB9XG4gIC8vIH1cbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmdldERhdGFEaW1lbnNpb25JbmRleCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIG9wdERpbSA9IHRoaXMub3B0aW9uLmRpbWVuc2lvbjtcbiAgICBpZiAob3B0RGltICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBkYXRhLmdldERpbWVuc2lvbkluZGV4KG9wdERpbSk7XG4gICAgfVxuICAgIHZhciBkaW1OYW1lcyA9IGRhdGEuZGltZW5zaW9ucztcbiAgICBmb3IgKHZhciBpID0gZGltTmFtZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBkaW1OYW1lID0gZGltTmFtZXNbaV07XG4gICAgICB2YXIgZGltSW5mbyA9IGRhdGEuZ2V0RGltZW5zaW9uSW5mbyhkaW1OYW1lKTtcbiAgICAgIGlmICghZGltSW5mby5pc0NhbGN1bGF0aW9uQ29vcmQpIHtcbiAgICAgICAgcmV0dXJuIGRpbUluZm8uc3RvcmVEaW1JbmRleDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRFeHRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFFeHRlbnQuc2xpY2UoKTtcbiAgfTtcbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLmNvbXBsZXRlVmlzdWFsT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlY01vZGVsID0gdGhpcy5lY01vZGVsO1xuICAgIHZhciB0aGlzT3B0aW9uID0gdGhpcy5vcHRpb247XG4gICAgdmFyIGJhc2UgPSB7XG4gICAgICBpblJhbmdlOiB0aGlzT3B0aW9uLmluUmFuZ2UsXG4gICAgICBvdXRPZlJhbmdlOiB0aGlzT3B0aW9uLm91dE9mUmFuZ2VcbiAgICB9O1xuICAgIHZhciB0YXJnZXQgPSB0aGlzT3B0aW9uLnRhcmdldCB8fCAodGhpc09wdGlvbi50YXJnZXQgPSB7fSk7XG4gICAgdmFyIGNvbnRyb2xsZXIgPSB0aGlzT3B0aW9uLmNvbnRyb2xsZXIgfHwgKHRoaXNPcHRpb24uY29udHJvbGxlciA9IHt9KTtcbiAgICB6clV0aWwubWVyZ2UodGFyZ2V0LCBiYXNlKTsgLy8gRG8gbm90IG92ZXJyaWRlXG4gICAgenJVdGlsLm1lcmdlKGNvbnRyb2xsZXIsIGJhc2UpOyAvLyBEbyBub3Qgb3ZlcnJpZGVcbiAgICB2YXIgaXNDYXRlZ29yeSA9IHRoaXMuaXNDYXRlZ29yeSgpO1xuICAgIGNvbXBsZXRlU2luZ2xlLmNhbGwodGhpcywgdGFyZ2V0KTtcbiAgICBjb21wbGV0ZVNpbmdsZS5jYWxsKHRoaXMsIGNvbnRyb2xsZXIpO1xuICAgIGNvbXBsZXRlSW5hY3RpdmUuY2FsbCh0aGlzLCB0YXJnZXQsICdpblJhbmdlJywgJ291dE9mUmFuZ2UnKTtcbiAgICAvLyBjb21wbGV0ZUluYWN0aXZlLmNhbGwodGhpcywgdGFyZ2V0LCAnb3V0T2ZSYW5nZScsICdpblJhbmdlJyk7XG4gICAgY29tcGxldGVDb250cm9sbGVyLmNhbGwodGhpcywgY29udHJvbGxlcik7XG4gICAgZnVuY3Rpb24gY29tcGxldGVTaW5nbGUoYmFzZSkge1xuICAgICAgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMiBkYXRhUmFuZ2UuY29sb3IuXG4gICAgICAvLyBUaGUgbWFwcGluZyBvcmRlciBvZiBkYXRhUmFuZ2UuY29sb3IgaXM6IFtoaWdoIHZhbHVlLCAuLi4sIGxvdyB2YWx1ZV1cbiAgICAgIC8vIHdoZXJlYXMgaW5SYW5nZS5jb2xvciBhbmQgb3V0T2ZSYW5nZS5jb2xvciBpcyBbbG93IHZhbHVlLCAuLi4sIGhpZ2ggdmFsdWVdXG4gICAgICAvLyBOb3RpY2U6IGVjMiBoYXMgbm8gaW52ZXJzZS5cbiAgICAgIGlmIChpc0FycmF5KHRoaXNPcHRpb24uY29sb3IpXG4gICAgICAvLyBJZiB0aGVyZSBoYXMgYmVlbiBpblJhbmdlOiB7c3ltYm9sOiAuLi59LCBhZGRpbmcgY29sb3IgaXMgYSBtaXN0YWtlLlxuICAgICAgLy8gU28gYWRkaW5nIGNvbG9yIG9ubHkgd2hlbiBubyBpblJhbmdlIGRlZmluZWQuXG4gICAgICAmJiAhYmFzZS5pblJhbmdlKSB7XG4gICAgICAgIGJhc2UuaW5SYW5nZSA9IHtcbiAgICAgICAgICBjb2xvcjogdGhpc09wdGlvbi5jb2xvci5zbGljZSgpLnJldmVyc2UoKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgLy8gQ29tcGF0aWJsZSB3aXRoIHByZXZpb3VzIGxvZ2ljLCBhbHdheXMgZ2l2ZSBhIGRlZmF1bHQgY29sb3IsIG90aGVyd2lzZVxuICAgICAgLy8gc2ltcGxlIGNvbmZpZyB3aXRoIG5vIGluUmFuZ2UgYW5kIG91dE9mUmFuZ2Ugd2lsbCBub3Qgd29yay5cbiAgICAgIC8vIE9yaWdpbmFsbHkgd2UgdXNlIHZpc3VhbE1hcC5jb2xvciBhcyB0aGUgZGVmYXVsdCBjb2xvciwgYnV0IHNldE9wdGlvbiBhdFxuICAgICAgLy8gdGhlIHNlY29uZCB0aW1lIHRoZSBkZWZhdWx0IGNvbG9yIHdpbGwgYmUgZXJhc2VkLiBTbyB3ZSBjaGFuZ2UgdG8gdXNlXG4gICAgICAvLyBjb25zdGFudCBERUZBVUxUX0NPTE9SLlxuICAgICAgLy8gSWYgdXNlciBkbyBub3Qgd2FudCB0aGUgZGVmYXVsdCBjb2xvciwgc2V0IGluUmFuZ2U6IHtjb2xvcjogbnVsbH0uXG4gICAgICBiYXNlLmluUmFuZ2UgPSBiYXNlLmluUmFuZ2UgfHwge1xuICAgICAgICBjb2xvcjogZWNNb2RlbC5nZXQoJ2dyYWRpZW50Q29sb3InKVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGVJbmFjdGl2ZShiYXNlLCBzdGF0ZUV4aXN0LCBzdGF0ZUFic2VudCkge1xuICAgICAgdmFyIG9wdEV4aXN0ID0gYmFzZVtzdGF0ZUV4aXN0XTtcbiAgICAgIHZhciBvcHRBYnNlbnQgPSBiYXNlW3N0YXRlQWJzZW50XTtcbiAgICAgIGlmIChvcHRFeGlzdCAmJiAhb3B0QWJzZW50KSB7XG4gICAgICAgIG9wdEFic2VudCA9IGJhc2Vbc3RhdGVBYnNlbnRdID0ge307XG4gICAgICAgIGVhY2gob3B0RXhpc3QsIGZ1bmN0aW9uICh2aXN1YWxEYXRhLCB2aXN1YWxUeXBlKSB7XG4gICAgICAgICAgaWYgKCFWaXN1YWxNYXBwaW5nLmlzVmFsaWRUeXBlKHZpc3VhbFR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBkZWZhID0gdmlzdWFsRGVmYXVsdC5nZXQodmlzdWFsVHlwZSwgJ2luYWN0aXZlJywgaXNDYXRlZ29yeSk7XG4gICAgICAgICAgaWYgKGRlZmEgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0QWJzZW50W3Zpc3VhbFR5cGVdID0gZGVmYTtcbiAgICAgICAgICAgIC8vIENvbXBhdGliYWJsZSB3aXRoIGVjMjpcbiAgICAgICAgICAgIC8vIE9ubHkgaW5hY3RpdmUgY29sb3IgdG8gcmdiYSgwLDAsMCwwKSBjYW4gbm90XG4gICAgICAgICAgICAvLyBtYWtlIGxhYmVsIHRyYW5zcGFyZW50LCBzbyB1c2Ugb3BhY2l0eSBhbHNvLlxuICAgICAgICAgICAgaWYgKHZpc3VhbFR5cGUgPT09ICdjb2xvcicgJiYgIW9wdEFic2VudC5oYXNPd25Qcm9wZXJ0eSgnb3BhY2l0eScpICYmICFvcHRBYnNlbnQuaGFzT3duUHJvcGVydHkoJ2NvbG9yQWxwaGEnKSkge1xuICAgICAgICAgICAgICBvcHRBYnNlbnQub3BhY2l0eSA9IFswLCAwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUNvbnRyb2xsZXIoY29udHJvbGxlcikge1xuICAgICAgdmFyIHN5bWJvbEV4aXN0cyA9IChjb250cm9sbGVyLmluUmFuZ2UgfHwge30pLnN5bWJvbCB8fCAoY29udHJvbGxlci5vdXRPZlJhbmdlIHx8IHt9KS5zeW1ib2w7XG4gICAgICB2YXIgc3ltYm9sU2l6ZUV4aXN0cyA9IChjb250cm9sbGVyLmluUmFuZ2UgfHwge30pLnN5bWJvbFNpemUgfHwgKGNvbnRyb2xsZXIub3V0T2ZSYW5nZSB8fCB7fSkuc3ltYm9sU2l6ZTtcbiAgICAgIHZhciBpbmFjdGl2ZUNvbG9yID0gdGhpcy5nZXQoJ2luYWN0aXZlQ29sb3InKTtcbiAgICAgIHZhciBpdGVtU3ltYm9sID0gdGhpcy5nZXRJdGVtU3ltYm9sKCk7XG4gICAgICB2YXIgZGVmYXVsdFN5bWJvbCA9IGl0ZW1TeW1ib2wgfHwgJ3JvdW5kUmVjdCc7XG4gICAgICBlYWNoKHRoaXMuc3RhdGVMaXN0LCBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgdmFyIGl0ZW1TaXplID0gdGhpcy5pdGVtU2l6ZTtcbiAgICAgICAgdmFyIHZpc3VhbHMgPSBjb250cm9sbGVyW3N0YXRlXTtcbiAgICAgICAgLy8gU2V0IGluYWN0aXZlIGNvbG9yIGZvciBjb250cm9sbGVyIGlmIG5vIG90aGVyIGNvbG9yXG4gICAgICAgIC8vIGF0dHIgKGxpa2UgY29sb3JBbHBoYSkgc3BlY2lmaWVkLlxuICAgICAgICBpZiAoIXZpc3VhbHMpIHtcbiAgICAgICAgICB2aXN1YWxzID0gY29udHJvbGxlcltzdGF0ZV0gPSB7XG4gICAgICAgICAgICBjb2xvcjogaXNDYXRlZ29yeSA/IGluYWN0aXZlQ29sb3IgOiBbaW5hY3RpdmVDb2xvcl1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnNpc3RlbnQgc3ltYm9sIGFuZCBzeW1ib2xTaXplIGlmIG5vdCBzcGVjaWZpZWQuXG4gICAgICAgIGlmICh2aXN1YWxzLnN5bWJvbCA9PSBudWxsKSB7XG4gICAgICAgICAgdmlzdWFscy5zeW1ib2wgPSBzeW1ib2xFeGlzdHMgJiYgenJVdGlsLmNsb25lKHN5bWJvbEV4aXN0cykgfHwgKGlzQ2F0ZWdvcnkgPyBkZWZhdWx0U3ltYm9sIDogW2RlZmF1bHRTeW1ib2xdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzdWFscy5zeW1ib2xTaXplID09IG51bGwpIHtcbiAgICAgICAgICB2aXN1YWxzLnN5bWJvbFNpemUgPSBzeW1ib2xTaXplRXhpc3RzICYmIHpyVXRpbC5jbG9uZShzeW1ib2xTaXplRXhpc3RzKSB8fCAoaXNDYXRlZ29yeSA/IGl0ZW1TaXplWzBdIDogW2l0ZW1TaXplWzBdLCBpdGVtU2l6ZVswXV0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpbHRlciBub25lXG4gICAgICAgIHZpc3VhbHMuc3ltYm9sID0gbWFwVmlzdWFsKHZpc3VhbHMuc3ltYm9sLCBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgICAgcmV0dXJuIHN5bWJvbCA9PT0gJ25vbmUnID8gZGVmYXVsdFN5bWJvbCA6IHN5bWJvbDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBzeW1ib2xTaXplXG4gICAgICAgIHZhciBzeW1ib2xTaXplID0gdmlzdWFscy5zeW1ib2xTaXplO1xuICAgICAgICBpZiAoc3ltYm9sU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG1heF8xID0gLUluZmluaXR5O1xuICAgICAgICAgIC8vIHN5bWJvbFNpemUgY2FuIGJlIG9iamVjdCB3aGVuIGNhdGVnb3JpZXMgZGVmaW5lZC5cbiAgICAgICAgICBlYWNoVmlzdWFsKHN5bWJvbFNpemUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgdmFsdWUgPiBtYXhfMSAmJiAobWF4XzEgPSB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmlzdWFscy5zeW1ib2xTaXplID0gbWFwVmlzdWFsKHN5bWJvbFNpemUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVhck1hcCh2YWx1ZSwgWzAsIG1heF8xXSwgWzAsIGl0ZW1TaXplWzBdXSwgdHJ1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgVmlzdWFsTWFwTW9kZWwucHJvdG90eXBlLnJlc2V0SXRlbVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pdGVtU2l6ZSA9IFtwYXJzZUZsb2F0KHRoaXMuZ2V0KCdpdGVtV2lkdGgnKSksIHBhcnNlRmxvYXQodGhpcy5nZXQoJ2l0ZW1IZWlnaHQnKSldO1xuICB9O1xuICBWaXN1YWxNYXBNb2RlbC5wcm90b3R5cGUuaXNDYXRlZ29yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLm9wdGlvbi5jYXRlZ29yaWVzO1xuICB9O1xuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICogQGFic3RyYWN0XHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5zZXRTZWxlY3RlZCA9IGZ1bmN0aW9uIChzZWxlY3RlZCkge307XG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRTZWxlY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqL1xuICBWaXN1YWxNYXBNb2RlbC5wcm90b3R5cGUuZ2V0VmFsdWVTdGF0ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICAvKipcclxuICAgKiBGSVhNRVxyXG4gICAqIERvIG5vdCBwdWJsaXNoIHRvIHRoaXJ0LXBhcnQtZGV2IHRlbXBvcmFyaWx5XHJcbiAgICogdXRpbCB0aGUgaW50ZXJmYWNlIGlzIHN0YWJsZS4gKFNob3VsZCBpdCByZXR1cm5cclxuICAgKiBhIGZ1bmN0aW9uIGJ1dCBub3QgdmlzdWFsIG1ldGE/KVxyXG4gICAqXHJcbiAgICogQHB1YmlsY1xyXG4gICAqIEBhYnN0cmFjdFxyXG4gICAqIEBwYXJhbSBnZXRDb2xvclZpc3VhbFxyXG4gICAqICAgICAgICBwYXJhbXM6IHZhbHVlLCB2YWx1ZVN0YXRlXHJcbiAgICogICAgICAgIHJldHVybjogY29sb3JcclxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHZpc3VhbE1ldGFcclxuICAgKiAgICAgICAgc2hvdWxkIGluY2x1ZGVzIHtzdG9wcywgb3V0ZXJDb2xvcnN9XHJcbiAgICogICAgICAgIG91dGVyQ29sb3IgbWVhbnMgW2NvbG9yQmV5b25kTWluVmFsdWUsIGNvbG9yQmV5b25kTWF4VmFsdWVdXHJcbiAgICovXG4gIFZpc3VhbE1hcE1vZGVsLnByb3RvdHlwZS5nZXRWaXN1YWxNZXRhID0gZnVuY3Rpb24gKGdldENvbG9yVmlzdWFsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIFZpc3VhbE1hcE1vZGVsLnR5cGUgPSAndmlzdWFsTWFwJztcbiAgVmlzdWFsTWFwTW9kZWwuZGVwZW5kZW5jaWVzID0gWydzZXJpZXMnXTtcbiAgVmlzdWFsTWFwTW9kZWwuZGVmYXVsdE9wdGlvbiA9IHtcbiAgICBzaG93OiB0cnVlLFxuICAgIC8vIHpsZXZlbDogMCxcbiAgICB6OiA0LFxuICAgIHNlcmllc0luZGV4OiAnYWxsJyxcbiAgICBtaW46IDAsXG4gICAgbWF4OiAyMDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogbnVsbCxcbiAgICB0b3A6IG51bGwsXG4gICAgYm90dG9tOiAwLFxuICAgIGl0ZW1XaWR0aDogbnVsbCxcbiAgICBpdGVtSGVpZ2h0OiBudWxsLFxuICAgIGludmVyc2U6IGZhbHNlLFxuICAgIG9yaWVudDogJ3ZlcnRpY2FsJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICBib3JkZXJDb2xvcjogJyNjY2MnLFxuICAgIGNvbnRlbnRDb2xvcjogJyM1NzkzZjMnLFxuICAgIGluYWN0aXZlQ29sb3I6ICcjYWFhJyxcbiAgICBib3JkZXJXaWR0aDogMCxcbiAgICBwYWRkaW5nOiA1LFxuICAgIC8vIOaOpeWPl+aVsOe7hOWIhuWIq+iuvuWumuS4iuWPs+S4i+W3pui+uei3ne+8jOWQjGNzc1xuICAgIHRleHRHYXA6IDEwLFxuICAgIHByZWNpc2lvbjogMCxcbiAgICB0ZXh0U3R5bGU6IHtcbiAgICAgIGNvbG9yOiAnIzMzMycgLy8g5YC85Z+f5paH5a2X6aKc6ImyXG4gICAgfVxuICB9O1xuICByZXR1cm4gVmlzdWFsTWFwTW9kZWw7XG59KENvbXBvbmVudE1vZGVsKTtcbmV4cG9ydCBkZWZhdWx0IFZpc3VhbE1hcE1vZGVsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26192\n")},28540:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ install)\n/* harmony export */ });\n/* harmony import */ var _extension_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3087);\n/* harmony import */ var _installVisualMapContinuous_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67113);\n/* harmony import */ var _installVisualMapPiecewise_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(68781);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* "License"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* "License"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_installVisualMapContinuous_js__WEBPACK_IMPORTED_MODULE_1__/* .install */ .a);\n  (0,_extension_js__WEBPACK_IMPORTED_MODULE_0__/* .use */ .Y)(_installVisualMapPiecewise_js__WEBPACK_IMPORTED_MODULE_2__/* .install */ .a);\n  // Do not install \'./dataZoomSelect\',\n  // since it only work for toolbox dataZoom.\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjg1NDAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9pbnN0YWxsLmpzPzc0YTciXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyB1c2UgfSBmcm9tICcuLi8uLi9leHRlbnNpb24uanMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsVmlzdWFsTWFwQ29udGludW91cyB9IGZyb20gJy4vaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMuanMnO1xuaW1wb3J0IHsgaW5zdGFsbCBhcyBpbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlIH0gZnJvbSAnLi9pbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICB1c2UoaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMpO1xuICB1c2UoaW5zdGFsbFZpc3VhbE1hcFBpZWNld2lzZSk7XG4gIC8vIERvIG5vdCBpbnN0YWxsICcuL2RhdGFab29tU2VsZWN0JyxcbiAgLy8gc2luY2UgaXQgb25seSB3b3JrIGZvciB0b29sYm94IGRhdGFab29tLlxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28540\n')},41369:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  A: () => (/* binding */ installCommon)\n});\n\n;// ./node_modules/echarts/lib/component/visualMap/visualMapAction.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nvar visualMapActionInfo = {\n  type: 'selectDataRange',\n  event: 'dataRangeSelected',\n  // FIXME use updateView appears wrong\n  update: 'update'\n};\nvar visualMapActionHander = function (payload, ecModel) {\n  ecModel.eachComponent({\n    mainType: 'visualMap',\n    query: payload\n  }, function (model) {\n    model.setSelected(payload.selected);\n  });\n};\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/visualSolution.js\nvar visualSolution = __webpack_require__(6372);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/VisualMapping.js\nvar VisualMapping = __webpack_require__(7857);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/helper.js\nvar helper = __webpack_require__(37395);\n;// ./node_modules/echarts/lib/component/visualMap/visualEncoding.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar visualMapEncodingHandlers = [{\n  createOnAllSeries: true,\n  reset: function (seriesModel, ecModel) {\n    var resetDefines = [];\n    ecModel.eachComponent('visualMap', function (visualMapModel) {\n      var pipelineContext = seriesModel.pipelineContext;\n      if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {\n        return;\n      }\n      resetDefines.push(visualSolution/* incrementalApplyVisual */.dS(visualMapModel.stateList, visualMapModel.targetVisuals, util.bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())));\n    });\n    return resetDefines;\n  }\n},\n// Only support color.\n{\n  createOnAllSeries: true,\n  reset: function (seriesModel, ecModel) {\n    var data = seriesModel.getData();\n    var visualMetaList = [];\n    ecModel.eachComponent('visualMap', function (visualMapModel) {\n      if (visualMapModel.isTargetSeries(seriesModel)) {\n        var visualMeta = visualMapModel.getVisualMeta(util.bind(getColorVisual, null, seriesModel, visualMapModel)) || {\n          stops: [],\n          outerColors: []\n        };\n        var dimIdx = visualMapModel.getDataDimensionIndex(data);\n        if (dimIdx >= 0) {\n          // visualMeta.dimension should be dimension index, but not concrete dimension.\n          visualMeta.dimension = dimIdx;\n          visualMetaList.push(visualMeta);\n        }\n      }\n    });\n    // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));\n    seriesModel.getData().setVisual('visualMeta', visualMetaList);\n  }\n}];\n// FIXME\n// performance and export for heatmap?\n// value can be Infinity or -Infinity\nfunction getColorVisual(seriesModel, visualMapModel, value, valueState) {\n  var mappings = visualMapModel.targetVisuals[valueState];\n  var visualTypes = VisualMapping/* default */.A.prepareVisualTypes(mappings);\n  var resultVisual = {\n    color: (0,helper/* getVisualFromData */.rI)(seriesModel.getData(), 'color') // default color.\n  };\n  for (var i = 0, len = visualTypes.length; i < len; i++) {\n    var type = visualTypes[i];\n    var mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type];\n    mapping && mapping.applyVisual(value, getVisual, setVisual);\n  }\n  return resultVisual.color;\n  function getVisual(key) {\n    return resultVisual[key];\n  }\n  function setVisual(key, value) {\n    resultVisual[key] = value;\n  }\n}\n;// ./node_modules/echarts/lib/component/visualMap/preprocessor.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n// @ts-nocheck\n\nvar each = util.each;\nfunction visualMapPreprocessor(option) {\n  var visualMap = option && option.visualMap;\n  if (!util.isArray(visualMap)) {\n    visualMap = visualMap ? [visualMap] : [];\n  }\n  each(visualMap, function (opt) {\n    if (!opt) {\n      return;\n    }\n    // rename splitList to pieces\n    if (has(opt, 'splitList') && !has(opt, 'pieces')) {\n      opt.pieces = opt.splitList;\n      delete opt.splitList;\n    }\n    var pieces = opt.pieces;\n    if (pieces && util.isArray(pieces)) {\n      each(pieces, function (piece) {\n        if (util.isObject(piece)) {\n          if (has(piece, 'start') && !has(piece, 'min')) {\n            piece.min = piece.start;\n          }\n          if (has(piece, 'end') && !has(piece, 'max')) {\n            piece.max = piece.end;\n          }\n        }\n      });\n    }\n  });\n}\nfunction has(obj, name) {\n  return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);\n}\n;// ./node_modules/echarts/lib/component/visualMap/installCommon.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\nvar installed = false;\nfunction installCommon(registers) {\n  if (installed) {\n    return;\n  }\n  installed = true;\n  registers.registerSubTypeDefaulter('visualMap', function (option) {\n    // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.\n    return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';\n  });\n  registers.registerAction(visualMapActionInfo, visualMapActionHander);\n  (0,util.each)(visualMapEncodingHandlers, function (handler) {\n    registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler);\n  });\n  registers.registerPreprocessor(visualMapPreprocessor);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDEzNjkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL3Zpc3VhbE1hcEFjdGlvbi5qcz9jZmIyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL3Zpc3VhbEVuY29kaW5nLmpzPzMwN2UiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvcHJlcHJvY2Vzc29yLmpzPzI3YjEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvaW5zdGFsbENvbW1vbi5qcz9lM2IxIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuZXhwb3J0IHZhciB2aXN1YWxNYXBBY3Rpb25JbmZvID0ge1xuICB0eXBlOiAnc2VsZWN0RGF0YVJhbmdlJyxcbiAgZXZlbnQ6ICdkYXRhUmFuZ2VTZWxlY3RlZCcsXG4gIC8vIEZJWE1FIHVzZSB1cGRhdGVWaWV3IGFwcGVhcnMgd3JvbmdcbiAgdXBkYXRlOiAndXBkYXRlJ1xufTtcbmV4cG9ydCB2YXIgdmlzdWFsTWFwQWN0aW9uSGFuZGVyID0gZnVuY3Rpb24gKHBheWxvYWQsIGVjTW9kZWwpIHtcbiAgZWNNb2RlbC5lYWNoQ29tcG9uZW50KHtcbiAgICBtYWluVHlwZTogJ3Zpc3VhbE1hcCcsXG4gICAgcXVlcnk6IHBheWxvYWRcbiAgfSwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgbW9kZWwuc2V0U2VsZWN0ZWQocGF5bG9hZC5zZWxlY3RlZCk7XG4gIH0pO1xufTsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0ICogYXMgdmlzdWFsU29sdXRpb24gZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbFNvbHV0aW9uLmpzJztcbmltcG9ydCBWaXN1YWxNYXBwaW5nIGZyb20gJy4uLy4uL3Zpc3VhbC9WaXN1YWxNYXBwaW5nLmpzJztcbmltcG9ydCB7IGdldFZpc3VhbEZyb21EYXRhIH0gZnJvbSAnLi4vLi4vdmlzdWFsL2hlbHBlci5qcyc7XG5leHBvcnQgdmFyIHZpc3VhbE1hcEVuY29kaW5nSGFuZGxlcnMgPSBbe1xuICBjcmVhdGVPbkFsbFNlcmllczogdHJ1ZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciByZXNldERlZmluZXMgPSBbXTtcbiAgICBlY01vZGVsLmVhY2hDb21wb25lbnQoJ3Zpc3VhbE1hcCcsIGZ1bmN0aW9uICh2aXN1YWxNYXBNb2RlbCkge1xuICAgICAgdmFyIHBpcGVsaW5lQ29udGV4dCA9IHNlcmllc01vZGVsLnBpcGVsaW5lQ29udGV4dDtcbiAgICAgIGlmICghdmlzdWFsTWFwTW9kZWwuaXNUYXJnZXRTZXJpZXMoc2VyaWVzTW9kZWwpIHx8IHBpcGVsaW5lQ29udGV4dCAmJiBwaXBlbGluZUNvbnRleHQubGFyZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzZXREZWZpbmVzLnB1c2godmlzdWFsU29sdXRpb24uaW5jcmVtZW50YWxBcHBseVZpc3VhbCh2aXN1YWxNYXBNb2RlbC5zdGF0ZUxpc3QsIHZpc3VhbE1hcE1vZGVsLnRhcmdldFZpc3VhbHMsIHpyVXRpbC5iaW5kKHZpc3VhbE1hcE1vZGVsLmdldFZhbHVlU3RhdGUsIHZpc3VhbE1hcE1vZGVsKSwgdmlzdWFsTWFwTW9kZWwuZ2V0RGF0YURpbWVuc2lvbkluZGV4KHNlcmllc01vZGVsLmdldERhdGEoKSkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzZXREZWZpbmVzO1xuICB9XG59LFxuLy8gT25seSBzdXBwb3J0IGNvbG9yLlxue1xuICBjcmVhdGVPbkFsbFNlcmllczogdHJ1ZSxcbiAgcmVzZXQ6IGZ1bmN0aW9uIChzZXJpZXNNb2RlbCwgZWNNb2RlbCkge1xuICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgIHZhciB2aXN1YWxNZXRhTGlzdCA9IFtdO1xuICAgIGVjTW9kZWwuZWFjaENvbXBvbmVudCgndmlzdWFsTWFwJywgZnVuY3Rpb24gKHZpc3VhbE1hcE1vZGVsKSB7XG4gICAgICBpZiAodmlzdWFsTWFwTW9kZWwuaXNUYXJnZXRTZXJpZXMoc2VyaWVzTW9kZWwpKSB7XG4gICAgICAgIHZhciB2aXN1YWxNZXRhID0gdmlzdWFsTWFwTW9kZWwuZ2V0VmlzdWFsTWV0YSh6clV0aWwuYmluZChnZXRDb2xvclZpc3VhbCwgbnVsbCwgc2VyaWVzTW9kZWwsIHZpc3VhbE1hcE1vZGVsKSkgfHwge1xuICAgICAgICAgIHN0b3BzOiBbXSxcbiAgICAgICAgICBvdXRlckNvbG9yczogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGRpbUlkeCA9IHZpc3VhbE1hcE1vZGVsLmdldERhdGFEaW1lbnNpb25JbmRleChkYXRhKTtcbiAgICAgICAgaWYgKGRpbUlkeCA+PSAwKSB7XG4gICAgICAgICAgLy8gdmlzdWFsTWV0YS5kaW1lbnNpb24gc2hvdWxkIGJlIGRpbWVuc2lvbiBpbmRleCwgYnV0IG5vdCBjb25jcmV0ZSBkaW1lbnNpb24uXG4gICAgICAgICAgdmlzdWFsTWV0YS5kaW1lbnNpb24gPSBkaW1JZHg7XG4gICAgICAgICAgdmlzdWFsTWV0YUxpc3QucHVzaCh2aXN1YWxNZXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KHZpc3VhbE1ldGFMaXN0Lm1hcChhID0+IGEuc3RvcHMpKSk7XG4gICAgc2VyaWVzTW9kZWwuZ2V0RGF0YSgpLnNldFZpc3VhbCgndmlzdWFsTWV0YScsIHZpc3VhbE1ldGFMaXN0KTtcbiAgfVxufV07XG4vLyBGSVhNRVxuLy8gcGVyZm9ybWFuY2UgYW5kIGV4cG9ydCBmb3IgaGVhdG1hcD9cbi8vIHZhbHVlIGNhbiBiZSBJbmZpbml0eSBvciAtSW5maW5pdHlcbmZ1bmN0aW9uIGdldENvbG9yVmlzdWFsKHNlcmllc01vZGVsLCB2aXN1YWxNYXBNb2RlbCwgdmFsdWUsIHZhbHVlU3RhdGUpIHtcbiAgdmFyIG1hcHBpbmdzID0gdmlzdWFsTWFwTW9kZWwudGFyZ2V0VmlzdWFsc1t2YWx1ZVN0YXRlXTtcbiAgdmFyIHZpc3VhbFR5cGVzID0gVmlzdWFsTWFwcGluZy5wcmVwYXJlVmlzdWFsVHlwZXMobWFwcGluZ3MpO1xuICB2YXIgcmVzdWx0VmlzdWFsID0ge1xuICAgIGNvbG9yOiBnZXRWaXN1YWxGcm9tRGF0YShzZXJpZXNNb2RlbC5nZXREYXRhKCksICdjb2xvcicpIC8vIGRlZmF1bHQgY29sb3IuXG4gIH07XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2aXN1YWxUeXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciB0eXBlID0gdmlzdWFsVHlwZXNbaV07XG4gICAgdmFyIG1hcHBpbmcgPSBtYXBwaW5nc1t0eXBlID09PSAnb3BhY2l0eScgPyAnX19hbHBoYUZvck9wYWNpdHknIDogdHlwZV07XG4gICAgbWFwcGluZyAmJiBtYXBwaW5nLmFwcGx5VmlzdWFsKHZhbHVlLCBnZXRWaXN1YWwsIHNldFZpc3VhbCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFZpc3VhbC5jb2xvcjtcbiAgZnVuY3Rpb24gZ2V0VmlzdWFsKGtleSkge1xuICAgIHJldHVybiByZXN1bHRWaXN1YWxba2V5XTtcbiAgfVxuICBmdW5jdGlvbiBzZXRWaXN1YWwoa2V5LCB2YWx1ZSkge1xuICAgIHJlc3VsdFZpc3VhbFtrZXldID0gdmFsdWU7XG4gIH1cbn0iLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbi8vIEB0cy1ub2NoZWNrXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbnZhciBlYWNoID0genJVdGlsLmVhY2g7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB2aXN1YWxNYXBQcmVwcm9jZXNzb3Iob3B0aW9uKSB7XG4gIHZhciB2aXN1YWxNYXAgPSBvcHRpb24gJiYgb3B0aW9uLnZpc3VhbE1hcDtcbiAgaWYgKCF6clV0aWwuaXNBcnJheSh2aXN1YWxNYXApKSB7XG4gICAgdmlzdWFsTWFwID0gdmlzdWFsTWFwID8gW3Zpc3VhbE1hcF0gOiBbXTtcbiAgfVxuICBlYWNoKHZpc3VhbE1hcCwgZnVuY3Rpb24gKG9wdCkge1xuICAgIGlmICghb3B0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbmFtZSBzcGxpdExpc3QgdG8gcGllY2VzXG4gICAgaWYgKGhhcyhvcHQsICdzcGxpdExpc3QnKSAmJiAhaGFzKG9wdCwgJ3BpZWNlcycpKSB7XG4gICAgICBvcHQucGllY2VzID0gb3B0LnNwbGl0TGlzdDtcbiAgICAgIGRlbGV0ZSBvcHQuc3BsaXRMaXN0O1xuICAgIH1cbiAgICB2YXIgcGllY2VzID0gb3B0LnBpZWNlcztcbiAgICBpZiAocGllY2VzICYmIHpyVXRpbC5pc0FycmF5KHBpZWNlcykpIHtcbiAgICAgIGVhY2gocGllY2VzLCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgICAgaWYgKHpyVXRpbC5pc09iamVjdChwaWVjZSkpIHtcbiAgICAgICAgICBpZiAoaGFzKHBpZWNlLCAnc3RhcnQnKSAmJiAhaGFzKHBpZWNlLCAnbWluJykpIHtcbiAgICAgICAgICAgIHBpZWNlLm1pbiA9IHBpZWNlLnN0YXJ0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzKHBpZWNlLCAnZW5kJykgJiYgIWhhcyhwaWVjZSwgJ21heCcpKSB7XG4gICAgICAgICAgICBwaWVjZS5tYXggPSBwaWVjZS5lbmQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaGFzKG9iaiwgbmFtZSkge1xuICByZXR1cm4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSAmJiBvYmouaGFzT3duUHJvcGVydHkobmFtZSk7XG59IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyB2aXN1YWxNYXBBY3Rpb25JbmZvLCB2aXN1YWxNYXBBY3Rpb25IYW5kZXIgfSBmcm9tICcuL3Zpc3VhbE1hcEFjdGlvbi5qcyc7XG5pbXBvcnQgeyB2aXN1YWxNYXBFbmNvZGluZ0hhbmRsZXJzIH0gZnJvbSAnLi92aXN1YWxFbmNvZGluZy5qcyc7XG5pbXBvcnQgeyBlYWNoIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCBwcmVwcm9jZXNzb3IgZnJvbSAnLi9wcmVwcm9jZXNzb3IuanMnO1xudmFyIGluc3RhbGxlZCA9IGZhbHNlO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpIHtcbiAgaWYgKGluc3RhbGxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpbnN0YWxsZWQgPSB0cnVlO1xuICByZWdpc3RlcnMucmVnaXN0ZXJTdWJUeXBlRGVmYXVsdGVyKCd2aXN1YWxNYXAnLCBmdW5jdGlvbiAob3B0aW9uKSB7XG4gICAgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMiwgd2hlbiBzcGxpdE51bWJlciA9PT0gMCwgY29udGludW91cyB2aXN1YWxNYXAgd2lsbCBiZSB1c2VkLlxuICAgIHJldHVybiAhb3B0aW9uLmNhdGVnb3JpZXMgJiYgKCEob3B0aW9uLnBpZWNlcyA/IG9wdGlvbi5waWVjZXMubGVuZ3RoID4gMCA6IG9wdGlvbi5zcGxpdE51bWJlciA+IDApIHx8IG9wdGlvbi5jYWxjdWxhYmxlKSA/ICdjb250aW51b3VzJyA6ICdwaWVjZXdpc2UnO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyQWN0aW9uKHZpc3VhbE1hcEFjdGlvbkluZm8sIHZpc3VhbE1hcEFjdGlvbkhhbmRlcik7XG4gIGVhY2godmlzdWFsTWFwRW5jb2RpbmdIYW5kbGVycywgZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICByZWdpc3RlcnMucmVnaXN0ZXJWaXN1YWwocmVnaXN0ZXJzLlBSSU9SSVRZLlZJU1VBTC5DT01QT05FTlQsIGhhbmRsZXIpO1xuICB9KTtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyUHJlcHJvY2Vzc29yKHByZXByb2Nlc3Nvcik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///41369\n")},44934:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/conditionalExpression.js\nvar conditionalExpression = __webpack_require__(6129);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/log.js\nvar log = __webpack_require__(41025);\n;// ./node_modules/echarts/lib/component/transform/filterTransform.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nvar filterTransform = {\n  type: 'echarts:filter',\n  // PENDING: enhance to filter by index rather than create new data\n  transform: function (params) {\n    // [Caveat] Fail-Fast:\n    // Do not return the whole dataset unless user config indicates it explicitly.\n    // For example, if no condition is specified by mistake, returning an empty result\n    // is better than returning the entire raw source for the user to find the mistake.\n    var upstream = params.upstream;\n    var rawItem;\n    var condition = (0,conditionalExpression/* parseConditionalExpression */.I)(params.config, {\n      valueGetterAttrMap: (0,util.createHashMap)({\n        dimension: true\n      }),\n      prepareGetValue: function (exprOption) {\n        var errMsg = '';\n        var dimLoose = exprOption.dimension;\n        if (!(0,util.hasOwn)(exprOption, 'dimension')) {\n          if (false) {}\n          (0,log/* throwError */.$8)(errMsg);\n        }\n        var dimInfo = upstream.getDimensionInfo(dimLoose);\n        if (!dimInfo) {\n          if (false) {}\n          (0,log/* throwError */.$8)(errMsg);\n        }\n        return {\n          dimIdx: dimInfo.index\n        };\n      },\n      getValue: function (param) {\n        return upstream.retrieveValueFromItem(rawItem, param.dimIdx);\n      }\n    });\n    var resultData = [];\n    for (var i = 0, len = upstream.count(); i < len; i++) {\n      rawItem = upstream.getRawDataItem(i);\n      if (condition.evaluate()) {\n        resultData.push(rawItem);\n      }\n    }\n    return {\n      data: resultData\n    };\n  }\n};\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/types.js\nvar types = __webpack_require__(13430);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/data/helper/dataValueHelper.js\nvar dataValueHelper = __webpack_require__(31825);\n;// ./node_modules/echarts/lib/component/transform/sortTransform.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\nvar sampleLog = '';\nif (false) {}\nvar sortTransform = {\n  type: 'echarts:sort',\n  transform: function (params) {\n    var upstream = params.upstream;\n    var config = params.config;\n    var errMsg = '';\n    // Normalize\n    // const orderExprList: OrderExpression[] = isArray(config[0])\n    //     ? config as OrderExpression[]\n    //     : [config as OrderExpression];\n    var orderExprList = (0,model/* normalizeToArray */.qB)(config);\n    if (!orderExprList.length) {\n      if (false) {}\n      (0,log/* throwError */.$8)(errMsg);\n    }\n    var orderDefList = [];\n    (0,util.each)(orderExprList, function (orderExpr) {\n      var dimLoose = orderExpr.dimension;\n      var order = orderExpr.order;\n      var parserName = orderExpr.parser;\n      var incomparable = orderExpr.incomparable;\n      if (dimLoose == null) {\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg);\n      }\n      if (order !== 'asc' && order !== 'desc') {\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg);\n      }\n      if (incomparable && incomparable !== 'min' && incomparable !== 'max') {\n        var errMsg_1 = '';\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg_1);\n      }\n      if (order !== 'asc' && order !== 'desc') {\n        var errMsg_2 = '';\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg_2);\n      }\n      var dimInfo = upstream.getDimensionInfo(dimLoose);\n      if (!dimInfo) {\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg);\n      }\n      var parser = parserName ? (0,dataValueHelper/* getRawValueParser */.zC)(parserName) : null;\n      if (parserName && !parser) {\n        if (false) {}\n        (0,log/* throwError */.$8)(errMsg);\n      }\n      orderDefList.push({\n        dimIdx: dimInfo.index,\n        parser: parser,\n        comparator: new dataValueHelper/* SortOrderComparator */.Fl(order, incomparable)\n      });\n    });\n    // TODO: support it?\n    var sourceFormat = upstream.sourceFormat;\n    if (sourceFormat !== types/* SOURCE_FORMAT_ARRAY_ROWS */.Km && sourceFormat !== types/* SOURCE_FORMAT_OBJECT_ROWS */.Wk) {\n      if (false) {}\n      (0,log/* throwError */.$8)(errMsg);\n    }\n    // Other upstream format are all array.\n    var resultData = [];\n    for (var i = 0, len = upstream.count(); i < len; i++) {\n      resultData.push(upstream.getRawDataItem(i));\n    }\n    resultData.sort(function (item0, item1) {\n      for (var i = 0; i < orderDefList.length; i++) {\n        var orderDef = orderDefList[i];\n        var val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx);\n        var val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx);\n        if (orderDef.parser) {\n          val0 = orderDef.parser(val0);\n          val1 = orderDef.parser(val1);\n        }\n        var result = orderDef.comparator.evaluate(val0, val1);\n        if (result !== 0) {\n          return result;\n        }\n      }\n      return 0;\n    });\n    return {\n      data: resultData\n    };\n  }\n};\n;// ./node_modules/echarts/lib/component/transform/install.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nfunction install(registers) {\n  registers.registerTransform(filterTransform);\n  registers.registerTransform(sortTransform);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDQ5MzQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90cmFuc2Zvcm0vZmlsdGVyVHJhbnNmb3JtLmpzPzRmZWIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC90cmFuc2Zvcm0vc29ydFRyYW5zZm9ybS5qcz81YjRkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdHJhbnNmb3JtL2luc3RhbGwuanM/YjkzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jb25kaXRpb25hbEV4cHJlc3Npb24uanMnO1xuaW1wb3J0IHsgaGFzT3duLCBjcmVhdGVIYXNoTWFwIH0gZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IG1ha2VQcmludGFibGUsIHRocm93RXJyb3IgfSBmcm9tICcuLi8uLi91dGlsL2xvZy5qcyc7XG5leHBvcnQgdmFyIGZpbHRlclRyYW5zZm9ybSA9IHtcbiAgdHlwZTogJ2VjaGFydHM6ZmlsdGVyJyxcbiAgLy8gUEVORElORzogZW5oYW5jZSB0byBmaWx0ZXIgYnkgaW5kZXggcmF0aGVyIHRoYW4gY3JlYXRlIG5ldyBkYXRhXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gKHBhcmFtcykge1xuICAgIC8vIFtDYXZlYXRdIEZhaWwtRmFzdDpcbiAgICAvLyBEbyBub3QgcmV0dXJuIHRoZSB3aG9sZSBkYXRhc2V0IHVubGVzcyB1c2VyIGNvbmZpZyBpbmRpY2F0ZXMgaXQgZXhwbGljaXRseS5cbiAgICAvLyBGb3IgZXhhbXBsZSwgaWYgbm8gY29uZGl0aW9uIGlzIHNwZWNpZmllZCBieSBtaXN0YWtlLCByZXR1cm5pbmcgYW4gZW1wdHkgcmVzdWx0XG4gICAgLy8gaXMgYmV0dGVyIHRoYW4gcmV0dXJuaW5nIHRoZSBlbnRpcmUgcmF3IHNvdXJjZSBmb3IgdGhlIHVzZXIgdG8gZmluZCB0aGUgbWlzdGFrZS5cbiAgICB2YXIgdXBzdHJlYW0gPSBwYXJhbXMudXBzdHJlYW07XG4gICAgdmFyIHJhd0l0ZW07XG4gICAgdmFyIGNvbmRpdGlvbiA9IHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKHBhcmFtcy5jb25maWcsIHtcbiAgICAgIHZhbHVlR2V0dGVyQXR0ck1hcDogY3JlYXRlSGFzaE1hcCh7XG4gICAgICAgIGRpbWVuc2lvbjogdHJ1ZVxuICAgICAgfSksXG4gICAgICBwcmVwYXJlR2V0VmFsdWU6IGZ1bmN0aW9uIChleHByT3B0aW9uKSB7XG4gICAgICAgIHZhciBlcnJNc2cgPSAnJztcbiAgICAgICAgdmFyIGRpbUxvb3NlID0gZXhwck9wdGlvbi5kaW1lbnNpb247XG4gICAgICAgIGlmICghaGFzT3duKGV4cHJPcHRpb24sICdkaW1lbnNpb24nKSkge1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdSZWxhdGlvbiBjb25kaXRpb24gbXVzdCBoYXMgcHJvcCBcImRpbWVuc2lvblwiIHNwZWNpZmllZC4nLCAnSWxsZWdhbCBjb25kaXRpb246JywgZXhwck9wdGlvbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGltSW5mbyA9IHVwc3RyZWFtLmdldERpbWVuc2lvbkluZm8oZGltTG9vc2UpO1xuICAgICAgICBpZiAoIWRpbUluZm8pIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnQ2FuIG5vdCBmaW5kIGRpbWVuc2lvbiBpbmZvIHZpYTogJyArIGRpbUxvb3NlICsgJy5cXG4nLCAnRXhpc3RpbmcgZGltZW5zaW9uczogJywgdXBzdHJlYW0uY2xvbmVBbGxEaW1lbnNpb25JbmZvKCksICcuXFxuJywgJ0lsbGVnYWwgY29uZGl0aW9uOicsIGV4cHJPcHRpb24sICcuXFxuJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpbUlkeDogZGltSW5mby5pbmRleFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHVwc3RyZWFtLnJldHJpZXZlVmFsdWVGcm9tSXRlbShyYXdJdGVtLCBwYXJhbS5kaW1JZHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciByZXN1bHREYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHVwc3RyZWFtLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmF3SXRlbSA9IHVwc3RyZWFtLmdldFJhd0RhdGFJdGVtKGkpO1xuICAgICAgaWYgKGNvbmRpdGlvbi5ldmFsdWF0ZSgpKSB7XG4gICAgICAgIHJlc3VsdERhdGEucHVzaChyYXdJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHJlc3VsdERhdGFcbiAgICB9O1xuICB9XG59OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgU09VUkNFX0ZPUk1BVF9BUlJBWV9ST1dTLCBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTIH0gZnJvbSAnLi4vLi4vdXRpbC90eXBlcy5qcyc7XG5pbXBvcnQgeyBtYWtlUHJpbnRhYmxlLCB0aHJvd0Vycm9yIH0gZnJvbSAnLi4vLi4vdXRpbC9sb2cuanMnO1xuaW1wb3J0IHsgZWFjaCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgeyBub3JtYWxpemVUb0FycmF5IH0gZnJvbSAnLi4vLi4vdXRpbC9tb2RlbC5qcyc7XG5pbXBvcnQgeyBnZXRSYXdWYWx1ZVBhcnNlciwgU29ydE9yZGVyQ29tcGFyYXRvciB9IGZyb20gJy4uLy4uL2RhdGEvaGVscGVyL2RhdGFWYWx1ZUhlbHBlci5qcyc7XG52YXIgc2FtcGxlTG9nID0gJyc7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzYW1wbGVMb2cgPSBbJ1ZhbGlkIGNvbmZpZyBpcyBsaWtlOicsICd7IGRpbWVuc2lvbjogXCJhZ2VcIiwgb3JkZXI6IFwiYXNjXCIgfScsICdvciBbeyBkaW1lbnNpb246IFwiYWdlXCIsIG9yZGVyOiBcImFzY1wiXSwgeyBkaW1lbnNpb246IFwiZGF0ZVwiLCBvcmRlcjogXCJkZXNjXCIgfV0nXS5qb2luKCcgJyk7XG59XG5leHBvcnQgdmFyIHNvcnRUcmFuc2Zvcm0gPSB7XG4gIHR5cGU6ICdlY2hhcnRzOnNvcnQnLFxuICB0cmFuc2Zvcm06IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgdXBzdHJlYW0gPSBwYXJhbXMudXBzdHJlYW07XG4gICAgdmFyIGNvbmZpZyA9IHBhcmFtcy5jb25maWc7XG4gICAgdmFyIGVyck1zZyA9ICcnO1xuICAgIC8vIE5vcm1hbGl6ZVxuICAgIC8vIGNvbnN0IG9yZGVyRXhwckxpc3Q6IE9yZGVyRXhwcmVzc2lvbltdID0gaXNBcnJheShjb25maWdbMF0pXG4gICAgLy8gICAgID8gY29uZmlnIGFzIE9yZGVyRXhwcmVzc2lvbltdXG4gICAgLy8gICAgIDogW2NvbmZpZyBhcyBPcmRlckV4cHJlc3Npb25dO1xuICAgIHZhciBvcmRlckV4cHJMaXN0ID0gbm9ybWFsaXplVG9BcnJheShjb25maWcpO1xuICAgIGlmICghb3JkZXJFeHByTGlzdC5sZW5ndGgpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGVyck1zZyA9ICdFbXB0eSBgY29uZmlnYCBpbiBzb3J0IHRyYW5zZm9ybS4nO1xuICAgICAgfVxuICAgICAgdGhyb3dFcnJvcihlcnJNc2cpO1xuICAgIH1cbiAgICB2YXIgb3JkZXJEZWZMaXN0ID0gW107XG4gICAgZWFjaChvcmRlckV4cHJMaXN0LCBmdW5jdGlvbiAob3JkZXJFeHByKSB7XG4gICAgICB2YXIgZGltTG9vc2UgPSBvcmRlckV4cHIuZGltZW5zaW9uO1xuICAgICAgdmFyIG9yZGVyID0gb3JkZXJFeHByLm9yZGVyO1xuICAgICAgdmFyIHBhcnNlck5hbWUgPSBvcmRlckV4cHIucGFyc2VyO1xuICAgICAgdmFyIGluY29tcGFyYWJsZSA9IG9yZGVyRXhwci5pbmNvbXBhcmFibGU7XG4gICAgICBpZiAoZGltTG9vc2UgPT0gbnVsbCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGVyck1zZyA9ICdTb3J0IHRyYW5zZm9ybSBjb25maWcgbXVzdCBoYXMgXCJkaW1lbnNpb25cIiBzcGVjaWZpZWQuJyArIHNhbXBsZUxvZztcbiAgICAgICAgfVxuICAgICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXIgIT09ICdhc2MnICYmIG9yZGVyICE9PSAnZGVzYycpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2cgPSAnU29ydCB0cmFuc2Zvcm0gY29uZmlnIG11c3QgaGFzIFwib3JkZXJcIiBzcGVjaWZpZWQuJyArIHNhbXBsZUxvZztcbiAgICAgICAgfVxuICAgICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgICB9XG4gICAgICBpZiAoaW5jb21wYXJhYmxlICYmIGluY29tcGFyYWJsZSAhPT0gJ21pbicgJiYgaW5jb21wYXJhYmxlICE9PSAnbWF4Jykge1xuICAgICAgICB2YXIgZXJyTXNnXzEgPSAnJztcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2dfMSA9ICdpbmNvbXBhcmFibGUgbXVzdCBiZSBcIm1pblwiIG9yIFwibWF4XCIgcmF0aGVyIHRoYW4gXCInICsgaW5jb21wYXJhYmxlICsgJ1wiLic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFcnJvcihlcnJNc2dfMSk7XG4gICAgICB9XG4gICAgICBpZiAob3JkZXIgIT09ICdhc2MnICYmIG9yZGVyICE9PSAnZGVzYycpIHtcbiAgICAgICAgdmFyIGVyck1zZ18yID0gJyc7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyTXNnXzIgPSAnb3JkZXIgbXVzdCBiZSBcImFzY1wiIG9yIFwiZGVzY1wiIHJhdGhlciB0aGFuIFwiJyArIG9yZGVyICsgJ1wiLic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3dFcnJvcihlcnJNc2dfMik7XG4gICAgICB9XG4gICAgICB2YXIgZGltSW5mbyA9IHVwc3RyZWFtLmdldERpbWVuc2lvbkluZm8oZGltTG9vc2UpO1xuICAgICAgaWYgKCFkaW1JbmZvKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgZXJyTXNnID0gbWFrZVByaW50YWJsZSgnQ2FuIG5vdCBmaW5kIGRpbWVuc2lvbiBpbmZvIHZpYTogJyArIGRpbUxvb3NlICsgJy5cXG4nLCAnRXhpc3RpbmcgZGltZW5zaW9uczogJywgdXBzdHJlYW0uY2xvbmVBbGxEaW1lbnNpb25JbmZvKCksICcuXFxuJywgJ0lsbGVnYWwgY29uZmlnOicsIG9yZGVyRXhwciwgJy5cXG4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgICB9XG4gICAgICB2YXIgcGFyc2VyID0gcGFyc2VyTmFtZSA/IGdldFJhd1ZhbHVlUGFyc2VyKHBhcnNlck5hbWUpIDogbnVsbDtcbiAgICAgIGlmIChwYXJzZXJOYW1lICYmICFwYXJzZXIpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBlcnJNc2cgPSBtYWtlUHJpbnRhYmxlKCdJbnZhbGlkIHBhcnNlciBuYW1lICcgKyBwYXJzZXJOYW1lICsgJy5cXG4nLCAnSWxsZWdhbCBjb25maWc6Jywgb3JkZXJFeHByLCAnLlxcbicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93RXJyb3IoZXJyTXNnKTtcbiAgICAgIH1cbiAgICAgIG9yZGVyRGVmTGlzdC5wdXNoKHtcbiAgICAgICAgZGltSWR4OiBkaW1JbmZvLmluZGV4LFxuICAgICAgICBwYXJzZXI6IHBhcnNlcixcbiAgICAgICAgY29tcGFyYXRvcjogbmV3IFNvcnRPcmRlckNvbXBhcmF0b3Iob3JkZXIsIGluY29tcGFyYWJsZSlcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRPRE86IHN1cHBvcnQgaXQ/XG4gICAgdmFyIHNvdXJjZUZvcm1hdCA9IHVwc3RyZWFtLnNvdXJjZUZvcm1hdDtcbiAgICBpZiAoc291cmNlRm9ybWF0ICE9PSBTT1VSQ0VfRk9STUFUX0FSUkFZX1JPV1MgJiYgc291cmNlRm9ybWF0ICE9PSBTT1VSQ0VfRk9STUFUX09CSkVDVF9ST1dTKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBlcnJNc2cgPSAnc291cmNlRm9ybWF0IFwiJyArIHNvdXJjZUZvcm1hdCArICdcIiBpcyBub3Qgc3VwcG9ydGVkIHlldCc7XG4gICAgICB9XG4gICAgICB0aHJvd0Vycm9yKGVyck1zZyk7XG4gICAgfVxuICAgIC8vIE90aGVyIHVwc3RyZWFtIGZvcm1hdCBhcmUgYWxsIGFycmF5LlxuICAgIHZhciByZXN1bHREYXRhID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHVwc3RyZWFtLmNvdW50KCk7IGkgPCBsZW47IGkrKykge1xuICAgICAgcmVzdWx0RGF0YS5wdXNoKHVwc3RyZWFtLmdldFJhd0RhdGFJdGVtKGkpKTtcbiAgICB9XG4gICAgcmVzdWx0RGF0YS5zb3J0KGZ1bmN0aW9uIChpdGVtMCwgaXRlbTEpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXJEZWZMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcmRlckRlZiA9IG9yZGVyRGVmTGlzdFtpXTtcbiAgICAgICAgdmFyIHZhbDAgPSB1cHN0cmVhbS5yZXRyaWV2ZVZhbHVlRnJvbUl0ZW0oaXRlbTAsIG9yZGVyRGVmLmRpbUlkeCk7XG4gICAgICAgIHZhciB2YWwxID0gdXBzdHJlYW0ucmV0cmlldmVWYWx1ZUZyb21JdGVtKGl0ZW0xLCBvcmRlckRlZi5kaW1JZHgpO1xuICAgICAgICBpZiAob3JkZXJEZWYucGFyc2VyKSB7XG4gICAgICAgICAgdmFsMCA9IG9yZGVyRGVmLnBhcnNlcih2YWwwKTtcbiAgICAgICAgICB2YWwxID0gb3JkZXJEZWYucGFyc2VyKHZhbDEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBvcmRlckRlZi5jb21wYXJhdG9yLmV2YWx1YXRlKHZhbDAsIHZhbDEpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IHJlc3VsdERhdGFcbiAgICB9O1xuICB9XG59OyIsIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgZmlsdGVyVHJhbnNmb3JtIH0gZnJvbSAnLi9maWx0ZXJUcmFuc2Zvcm0uanMnO1xuaW1wb3J0IHsgc29ydFRyYW5zZm9ybSB9IGZyb20gJy4vc29ydFRyYW5zZm9ybS5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaW5zdGFsbChyZWdpc3RlcnMpIHtcbiAgcmVnaXN0ZXJzLnJlZ2lzdGVyVHJhbnNmb3JtKGZpbHRlclRyYW5zZm9ybSk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlclRyYW5zZm9ybShzb3J0VHJhbnNmb3JtKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///44934\n")},46259:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   J: () => (/* binding */ getItemAlign),\n/* harmony export */   l: () => (/* binding */ makeHighDownBatch)\n/* harmony export */ });\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(98026);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(34253);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\nvar paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']];\n/**\r\n * @param visualMapModel\r\n * @param api\r\n * @param itemSize always [short, long]\r\n * @return {string} 'left' or 'right' or 'top' or 'bottom'\r\n */\nfunction getItemAlign(visualMapModel, api, itemSize) {\n  var modelOption = visualMapModel.option;\n  var itemAlign = modelOption.align;\n  if (itemAlign != null && itemAlign !== 'auto') {\n    return itemAlign;\n  }\n  // Auto decision align.\n  var ecSize = {\n    width: api.getWidth(),\n    height: api.getHeight()\n  };\n  var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;\n  var reals = paramsSet[realIndex];\n  var fakeValue = [0, null, 10];\n  var layoutInput = {};\n  for (var i = 0; i < 3; i++) {\n    layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];\n    layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];\n  }\n  var rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex];\n  var rect = (0,_util_layout_js__WEBPACK_IMPORTED_MODULE_0__/* .getLayoutRect */ .dV)(layoutInput, ecSize, modelOption.padding);\n  return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];\n}\n/**\r\n * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and\r\n * dataIndexInside means filtered index.\r\n */\n// TODO: TYPE more specified payload types.\nfunction makeHighDownBatch(batch, visualMapModel) {\n  zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_1__.each(batch || [], function (batchItem) {\n    if (batchItem.dataIndex != null) {\n      batchItem.dataIndexInside = batchItem.dataIndex;\n      batchItem.dataIndex = null;\n    }\n    batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '');\n  });\n  return batch;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDYyNTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvaGVscGVyLmpzP2U1M2YiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IGdldExheW91dFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG52YXIgcGFyYW1zU2V0ID0gW1snbGVmdCcsICdyaWdodCcsICd3aWR0aCddLCBbJ3RvcCcsICdib3R0b20nLCAnaGVpZ2h0J11dO1xuLyoqXHJcbiAqIEBwYXJhbSB2aXN1YWxNYXBNb2RlbFxyXG4gKiBAcGFyYW0gYXBpXHJcbiAqIEBwYXJhbSBpdGVtU2l6ZSBhbHdheXMgW3Nob3J0LCBsb25nXVxyXG4gKiBAcmV0dXJuIHtzdHJpbmd9ICdsZWZ0JyBvciAncmlnaHQnIG9yICd0b3AnIG9yICdib3R0b20nXHJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEl0ZW1BbGlnbih2aXN1YWxNYXBNb2RlbCwgYXBpLCBpdGVtU2l6ZSkge1xuICB2YXIgbW9kZWxPcHRpb24gPSB2aXN1YWxNYXBNb2RlbC5vcHRpb247XG4gIHZhciBpdGVtQWxpZ24gPSBtb2RlbE9wdGlvbi5hbGlnbjtcbiAgaWYgKGl0ZW1BbGlnbiAhPSBudWxsICYmIGl0ZW1BbGlnbiAhPT0gJ2F1dG8nKSB7XG4gICAgcmV0dXJuIGl0ZW1BbGlnbjtcbiAgfVxuICAvLyBBdXRvIGRlY2lzaW9uIGFsaWduLlxuICB2YXIgZWNTaXplID0ge1xuICAgIHdpZHRoOiBhcGkuZ2V0V2lkdGgoKSxcbiAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICB9O1xuICB2YXIgcmVhbEluZGV4ID0gbW9kZWxPcHRpb24ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyAxIDogMDtcbiAgdmFyIHJlYWxzID0gcGFyYW1zU2V0W3JlYWxJbmRleF07XG4gIHZhciBmYWtlVmFsdWUgPSBbMCwgbnVsbCwgMTBdO1xuICB2YXIgbGF5b3V0SW5wdXQgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICBsYXlvdXRJbnB1dFtwYXJhbXNTZXRbMSAtIHJlYWxJbmRleF1baV1dID0gZmFrZVZhbHVlW2ldO1xuICAgIGxheW91dElucHV0W3JlYWxzW2ldXSA9IGkgPT09IDIgPyBpdGVtU2l6ZVswXSA6IG1vZGVsT3B0aW9uW3JlYWxzW2ldXTtcbiAgfVxuICB2YXIgclBhcmFtID0gW1sneCcsICd3aWR0aCcsIDNdLCBbJ3knLCAnaGVpZ2h0JywgMF1dW3JlYWxJbmRleF07XG4gIHZhciByZWN0ID0gZ2V0TGF5b3V0UmVjdChsYXlvdXRJbnB1dCwgZWNTaXplLCBtb2RlbE9wdGlvbi5wYWRkaW5nKTtcbiAgcmV0dXJuIHJlYWxzWyhyZWN0Lm1hcmdpbltyUGFyYW1bMl1dIHx8IDApICsgcmVjdFtyUGFyYW1bMF1dICsgcmVjdFtyUGFyYW1bMV1dICogMC41IDwgZWNTaXplW3JQYXJhbVsxXV0gKiAwLjUgPyAwIDogMV07XG59XG4vKipcclxuICogUHJlcGFyZSBkYXRhSW5kZXggZm9yIG91dHNpZGUgdXNhZ2UsIHdoZXJlIGRhdGFJbmRleCBtZWFucyByYXdJbmRleCwgYW5kXHJcbiAqIGRhdGFJbmRleEluc2lkZSBtZWFucyBmaWx0ZXJlZCBpbmRleC5cclxuICovXG4vLyBUT0RPOiBUWVBFIG1vcmUgc3BlY2lmaWVkIHBheWxvYWQgdHlwZXMuXG5leHBvcnQgZnVuY3Rpb24gbWFrZUhpZ2hEb3duQmF0Y2goYmF0Y2gsIHZpc3VhbE1hcE1vZGVsKSB7XG4gIHpyVXRpbC5lYWNoKGJhdGNoIHx8IFtdLCBmdW5jdGlvbiAoYmF0Y2hJdGVtKSB7XG4gICAgaWYgKGJhdGNoSXRlbS5kYXRhSW5kZXggIT0gbnVsbCkge1xuICAgICAgYmF0Y2hJdGVtLmRhdGFJbmRleEluc2lkZSA9IGJhdGNoSXRlbS5kYXRhSW5kZXg7XG4gICAgICBiYXRjaEl0ZW0uZGF0YUluZGV4ID0gbnVsbDtcbiAgICB9XG4gICAgYmF0Y2hJdGVtLmhpZ2hsaWdodEtleSA9ICd2aXN1YWxNYXAnICsgKHZpc3VhbE1hcE1vZGVsID8gdmlzdWFsTWFwTW9kZWwuY29tcG9uZW50SW5kZXggOiAnJyk7XG4gIH0pO1xuICByZXR1cm4gYmF0Y2g7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46259\n")},59044:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74179);\n/* harmony import */ var zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(98026);\n/* harmony import */ var _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30010);\n/* harmony import */ var _util_format_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(83412);\n/* harmony import */ var _util_layout_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(34253);\n/* harmony import */ var _visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7857);\n/* harmony import */ var _view_Component_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59109);\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar VisualMapView = /** @class */function (_super) {\n  (0,tslib__WEBPACK_IMPORTED_MODULE_0__/* .__extends */ .C6)(VisualMapView, _super);\n  function VisualMapView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = VisualMapView.type;\n    _this.autoPositionValues = {\n      left: 1,\n      right: 1,\n      top: 1,\n      bottom: 1\n    };\n    return _this;\n  }\n  VisualMapView.prototype.init = function (ecModel, api) {\n    this.ecModel = ecModel;\n    this.api = api;\n  };\n  /**\r\n   * @protected\r\n   */\n  VisualMapView.prototype.render = function (visualMapModel, ecModel, api, payload // TODO: TYPE\n  ) {\n    this.visualMapModel = visualMapModel;\n    if (visualMapModel.get('show') === false) {\n      this.group.removeAll();\n      return;\n    }\n    this.doRender(visualMapModel, ecModel, api, payload);\n  };\n  /**\r\n   * @protected\r\n   */\n  VisualMapView.prototype.renderBackground = function (group) {\n    var visualMapModel = this.visualMapModel;\n    var padding = _util_format_js__WEBPACK_IMPORTED_MODULE_1__/* .normalizeCssArray */ .QX(visualMapModel.get('padding') || 0);\n    var rect = group.getBoundingRect();\n    group.add(new _util_graphic_js__WEBPACK_IMPORTED_MODULE_2__/* [\"default\"] */ .A({\n      z2: -1,\n      silent: true,\n      shape: {\n        x: rect.x - padding[3],\n        y: rect.y - padding[0],\n        width: rect.width + padding[3] + padding[1],\n        height: rect.height + padding[0] + padding[2]\n      },\n      style: {\n        fill: visualMapModel.get('backgroundColor'),\n        stroke: visualMapModel.get('borderColor'),\n        lineWidth: visualMapModel.get('borderWidth')\n      }\n    }));\n  };\n  /**\r\n   * @protected\r\n   * @param targetValue can be Infinity or -Infinity\r\n   * @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'\r\n   * @param opts\r\n   * @param opts.forceState Specify state, instead of using getValueState method.\r\n   * @param opts.convertOpacityToAlpha For color gradient in controller widget.\r\n   * @return {*} Visual value.\r\n   */\n  VisualMapView.prototype.getControllerVisual = function (targetValue, visualCluster, opts) {\n    opts = opts || {};\n    var forceState = opts.forceState;\n    var visualMapModel = this.visualMapModel;\n    var visualObj = {};\n    // Default values.\n    if (visualCluster === 'color') {\n      var defaultColor = visualMapModel.get('contentColor');\n      visualObj.color = defaultColor;\n    }\n    function getter(key) {\n      return visualObj[key];\n    }\n    function setter(key, value) {\n      visualObj[key] = value;\n    }\n    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];\n    var visualTypes = _visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.prepareVisualTypes(mappings);\n    zrender_lib_core_util_js__WEBPACK_IMPORTED_MODULE_4__.each(visualTypes, function (type) {\n      var visualMapping = mappings[type];\n      if (opts.convertOpacityToAlpha && type === 'opacity') {\n        type = 'colorAlpha';\n        visualMapping = mappings.__alphaForOpacity;\n      }\n      if (_visual_VisualMapping_js__WEBPACK_IMPORTED_MODULE_3__/* [\"default\"] */ .A.dependsOn(type, visualCluster)) {\n        visualMapping && visualMapping.applyVisual(targetValue, getter, setter);\n      }\n    });\n    return visualObj[visualCluster];\n  };\n  VisualMapView.prototype.positionGroup = function (group) {\n    var model = this.visualMapModel;\n    var api = this.api;\n    _util_layout_js__WEBPACK_IMPORTED_MODULE_5__/* .positionElement */ .m$(group, model.getBoxLayoutParams(), {\n      width: api.getWidth(),\n      height: api.getHeight()\n    });\n  };\n  VisualMapView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {};\n  VisualMapView.type = 'visualMap';\n  return VisualMapView;\n}(_view_Component_js__WEBPACK_IMPORTED_MODULE_6__/* [\"default\"] */ .A);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (VisualMapView);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNTkwNDQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvVmlzdWFsTWFwVmlldy5qcz8wZDY1Il0sInNvdXJjZXNDb250ZW50IjpbIlxuLypcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4qXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4qXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiogdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbi8qKlxuICogQVVUTy1HRU5FUkFURUQgRklMRS4gRE8gTk9UIE1PRElGWS5cbiAqL1xuXG4vKlxyXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcclxuKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcclxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxyXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcclxuKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXHJcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXHJcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG4qXHJcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuKlxyXG4qIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcclxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxyXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbiogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXHJcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xyXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qL1xuaW1wb3J0IHsgX19leHRlbmRzIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgKiBhcyB6clV0aWwgZnJvbSAnenJlbmRlci9saWIvY29yZS91dGlsLmpzJztcbmltcG9ydCB7IFJlY3QgfSBmcm9tICcuLi8uLi91dGlsL2dyYXBoaWMuanMnO1xuaW1wb3J0ICogYXMgZm9ybWF0VXRpbCBmcm9tICcuLi8uLi91dGlsL2Zvcm1hdC5qcyc7XG5pbXBvcnQgKiBhcyBsYXlvdXQgZnJvbSAnLi4vLi4vdXRpbC9sYXlvdXQuanMnO1xuaW1wb3J0IFZpc3VhbE1hcHBpbmcgZnJvbSAnLi4vLi4vdmlzdWFsL1Zpc3VhbE1hcHBpbmcuanMnO1xuaW1wb3J0IENvbXBvbmVudFZpZXcgZnJvbSAnLi4vLi4vdmlldy9Db21wb25lbnQuanMnO1xudmFyIFZpc3VhbE1hcFZpZXcgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoVmlzdWFsTWFwVmlldywgX3N1cGVyKTtcbiAgZnVuY3Rpb24gVmlzdWFsTWFwVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gVmlzdWFsTWFwVmlldy50eXBlO1xuICAgIF90aGlzLmF1dG9Qb3NpdGlvblZhbHVlcyA9IHtcbiAgICAgIGxlZnQ6IDEsXG4gICAgICByaWdodDogMSxcbiAgICAgIHRvcDogMSxcbiAgICAgIGJvdHRvbTogMVxuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFZpc3VhbE1hcFZpZXcucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWNNb2RlbCwgYXBpKSB7XG4gICAgdGhpcy5lY01vZGVsID0gZWNNb2RlbDtcbiAgICB0aGlzLmFwaSA9IGFwaTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHByb3RlY3RlZFxyXG4gICAqL1xuICBWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodmlzdWFsTWFwTW9kZWwsIGVjTW9kZWwsIGFwaSwgcGF5bG9hZCAvLyBUT0RPOiBUWVBFXG4gICkge1xuICAgIHRoaXMudmlzdWFsTWFwTW9kZWwgPSB2aXN1YWxNYXBNb2RlbDtcbiAgICBpZiAodmlzdWFsTWFwTW9kZWwuZ2V0KCdzaG93JykgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmdyb3VwLnJlbW92ZUFsbCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmRvUmVuZGVyKHZpc3VhbE1hcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpO1xuICB9O1xuICAvKipcclxuICAgKiBAcHJvdGVjdGVkXHJcbiAgICovXG4gIFZpc3VhbE1hcFZpZXcucHJvdG90eXBlLnJlbmRlckJhY2tncm91bmQgPSBmdW5jdGlvbiAoZ3JvdXApIHtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBwYWRkaW5nID0gZm9ybWF0VXRpbC5ub3JtYWxpemVDc3NBcnJheSh2aXN1YWxNYXBNb2RlbC5nZXQoJ3BhZGRpbmcnKSB8fCAwKTtcbiAgICB2YXIgcmVjdCA9IGdyb3VwLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIGdyb3VwLmFkZChuZXcgUmVjdCh7XG4gICAgICB6MjogLTEsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB4OiByZWN0LnggLSBwYWRkaW5nWzNdLFxuICAgICAgICB5OiByZWN0LnkgLSBwYWRkaW5nWzBdLFxuICAgICAgICB3aWR0aDogcmVjdC53aWR0aCArIHBhZGRpbmdbM10gKyBwYWRkaW5nWzFdLFxuICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgIH0sXG4gICAgICBzdHlsZToge1xuICAgICAgICBmaWxsOiB2aXN1YWxNYXBNb2RlbC5nZXQoJ2JhY2tncm91bmRDb2xvcicpLFxuICAgICAgICBzdHJva2U6IHZpc3VhbE1hcE1vZGVsLmdldCgnYm9yZGVyQ29sb3InKSxcbiAgICAgICAgbGluZVdpZHRoOiB2aXN1YWxNYXBNb2RlbC5nZXQoJ2JvcmRlcldpZHRoJylcbiAgICAgIH1cbiAgICB9KSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAcGFyYW0gdGFyZ2V0VmFsdWUgY2FuIGJlIEluZmluaXR5IG9yIC1JbmZpbml0eVxyXG4gICAqIEBwYXJhbSB2aXN1YWxDbHVzdGVyIE9ubHkgY2FuIGJlICdjb2xvcicgJ29wYWNpdHknICdzeW1ib2wnICdzeW1ib2xTaXplJ1xyXG4gICAqIEBwYXJhbSBvcHRzXHJcbiAgICogQHBhcmFtIG9wdHMuZm9yY2VTdGF0ZSBTcGVjaWZ5IHN0YXRlLCBpbnN0ZWFkIG9mIHVzaW5nIGdldFZhbHVlU3RhdGUgbWV0aG9kLlxyXG4gICAqIEBwYXJhbSBvcHRzLmNvbnZlcnRPcGFjaXR5VG9BbHBoYSBGb3IgY29sb3IgZ3JhZGllbnQgaW4gY29udHJvbGxlciB3aWRnZXQuXHJcbiAgICogQHJldHVybiB7Kn0gVmlzdWFsIHZhbHVlLlxyXG4gICAqL1xuICBWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5nZXRDb250cm9sbGVyVmlzdWFsID0gZnVuY3Rpb24gKHRhcmdldFZhbHVlLCB2aXN1YWxDbHVzdGVyLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIGZvcmNlU3RhdGUgPSBvcHRzLmZvcmNlU3RhdGU7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgdmlzdWFsT2JqID0ge307XG4gICAgLy8gRGVmYXVsdCB2YWx1ZXMuXG4gICAgaWYgKHZpc3VhbENsdXN0ZXIgPT09ICdjb2xvcicpIHtcbiAgICAgIHZhciBkZWZhdWx0Q29sb3IgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2NvbnRlbnRDb2xvcicpO1xuICAgICAgdmlzdWFsT2JqLmNvbG9yID0gZGVmYXVsdENvbG9yO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXR0ZXIoa2V5KSB7XG4gICAgICByZXR1cm4gdmlzdWFsT2JqW2tleV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHRlcihrZXksIHZhbHVlKSB7XG4gICAgICB2aXN1YWxPYmpba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YXIgbWFwcGluZ3MgPSB2aXN1YWxNYXBNb2RlbC5jb250cm9sbGVyVmlzdWFsc1tmb3JjZVN0YXRlIHx8IHZpc3VhbE1hcE1vZGVsLmdldFZhbHVlU3RhdGUodGFyZ2V0VmFsdWUpXTtcbiAgICB2YXIgdmlzdWFsVHlwZXMgPSBWaXN1YWxNYXBwaW5nLnByZXBhcmVWaXN1YWxUeXBlcyhtYXBwaW5ncyk7XG4gICAgenJVdGlsLmVhY2godmlzdWFsVHlwZXMsIGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICB2YXIgdmlzdWFsTWFwcGluZyA9IG1hcHBpbmdzW3R5cGVdO1xuICAgICAgaWYgKG9wdHMuY29udmVydE9wYWNpdHlUb0FscGhhICYmIHR5cGUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICB0eXBlID0gJ2NvbG9yQWxwaGEnO1xuICAgICAgICB2aXN1YWxNYXBwaW5nID0gbWFwcGluZ3MuX19hbHBoYUZvck9wYWNpdHk7XG4gICAgICB9XG4gICAgICBpZiAoVmlzdWFsTWFwcGluZy5kZXBlbmRzT24odHlwZSwgdmlzdWFsQ2x1c3RlcikpIHtcbiAgICAgICAgdmlzdWFsTWFwcGluZyAmJiB2aXN1YWxNYXBwaW5nLmFwcGx5VmlzdWFsKHRhcmdldFZhbHVlLCBnZXR0ZXIsIHNldHRlcik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHZpc3VhbE9ialt2aXN1YWxDbHVzdGVyXTtcbiAgfTtcbiAgVmlzdWFsTWFwVmlldy5wcm90b3R5cGUucG9zaXRpb25Hcm91cCA9IGZ1bmN0aW9uIChncm91cCkge1xuICAgIHZhciBtb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIGFwaSA9IHRoaXMuYXBpO1xuICAgIGxheW91dC5wb3NpdGlvbkVsZW1lbnQoZ3JvdXAsIG1vZGVsLmdldEJveExheW91dFBhcmFtcygpLCB7XG4gICAgICB3aWR0aDogYXBpLmdldFdpZHRoKCksXG4gICAgICBoZWlnaHQ6IGFwaS5nZXRIZWlnaHQoKVxuICAgIH0pO1xuICB9O1xuICBWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5kb1JlbmRlciA9IGZ1bmN0aW9uICh2aXN1YWxNYXBNb2RlbCwgZWNNb2RlbCwgYXBpLCBwYXlsb2FkKSB7fTtcbiAgVmlzdWFsTWFwVmlldy50eXBlID0gJ3Zpc3VhbE1hcCc7XG4gIHJldHVybiBWaXN1YWxNYXBWaWV3O1xufShDb21wb25lbnRWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IFZpc3VhbE1hcFZpZXc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///59044\n")},67113:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/VisualMapModel.js\nvar VisualMapModel = __webpack_require__(26192);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/visualMap/ContinuousModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n// Constant\nvar DEFAULT_BAR_BOUND = [20, 140];\nvar ContinuousModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ContinuousModel, _super);\n  function ContinuousModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ContinuousModel.type;\n    return _this;\n  }\n  /**\r\n   * @override\r\n   */\n  ContinuousModel.prototype.optionUpdated = function (newOption, isInit) {\n    _super.prototype.optionUpdated.apply(this, arguments);\n    this.resetExtent();\n    this.resetVisual(function (mappingOption) {\n      mappingOption.mappingMethod = 'linear';\n      mappingOption.dataExtent = this.getExtent();\n    });\n    this._resetRange();\n  };\n  /**\r\n   * @protected\r\n   * @override\r\n   */\n  ContinuousModel.prototype.resetItemSize = function () {\n    _super.prototype.resetItemSize.apply(this, arguments);\n    var itemSize = this.itemSize;\n    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);\n    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);\n  };\n  /**\r\n   * @private\r\n   */\n  ContinuousModel.prototype._resetRange = function () {\n    var dataExtent = this.getExtent();\n    var range = this.option.range;\n    if (!range || range.auto) {\n      // `range` should always be array (so we don't use other\n      // value like 'auto') for user-friend. (consider getOption).\n      dataExtent.auto = 1;\n      this.option.range = dataExtent;\n    } else if (util.isArray(range)) {\n      if (range[0] > range[1]) {\n        range.reverse();\n      }\n      range[0] = Math.max(range[0], dataExtent[0]);\n      range[1] = Math.min(range[1], dataExtent[1]);\n    }\n  };\n  /**\r\n   * @protected\r\n   * @override\r\n   */\n  ContinuousModel.prototype.completeVisualOption = function () {\n    _super.prototype.completeVisualOption.apply(this, arguments);\n    util.each(this.stateList, function (state) {\n      var symbolSize = this.option.controller[state].symbolSize;\n      if (symbolSize && symbolSize[0] !== symbolSize[1]) {\n        symbolSize[0] = symbolSize[1] / 3; // For good looking.\n      }\n    }, this);\n  };\n  /**\r\n   * @override\r\n   */\n  ContinuousModel.prototype.setSelected = function (selected) {\n    this.option.range = selected.slice();\n    this._resetRange();\n  };\n  /**\r\n   * @public\r\n   */\n  ContinuousModel.prototype.getSelected = function () {\n    var dataExtent = this.getExtent();\n    var dataInterval = number/* asc */.Y6((this.get('range') || []).slice());\n    // Clamp\n    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);\n    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);\n    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);\n    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);\n    return dataInterval;\n  };\n  /**\r\n   * @override\r\n   */\n  ContinuousModel.prototype.getValueState = function (value) {\n    var range = this.option.range;\n    var dataExtent = this.getExtent();\n    // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.\n    // range[1] is processed likewise.\n    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';\n  };\n  ContinuousModel.prototype.findTargetDataIndices = function (range) {\n    var result = [];\n    this.eachTargetSeries(function (seriesModel) {\n      var dataIndices = [];\n      var data = seriesModel.getData();\n      data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {\n        range[0] <= value && value <= range[1] && dataIndices.push(dataIndex);\n      }, this);\n      result.push({\n        seriesId: seriesModel.id,\n        dataIndex: dataIndices\n      });\n    }, this);\n    return result;\n  };\n  /**\r\n   * @implement\r\n   */\n  ContinuousModel.prototype.getVisualMeta = function (getColorVisual) {\n    var oVals = getColorStopValues(this, 'outOfRange', this.getExtent());\n    var iVals = getColorStopValues(this, 'inRange', this.option.range.slice());\n    var stops = [];\n    function setStop(value, valueState) {\n      stops.push({\n        value: value,\n        color: getColorVisual(value, valueState)\n      });\n    }\n    // Format to: outOfRange -- inRange -- outOfRange.\n    var iIdx = 0;\n    var oIdx = 0;\n    var iLen = iVals.length;\n    var oLen = oVals.length;\n    for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {\n      // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.\n      if (oVals[oIdx] < iVals[iIdx]) {\n        setStop(oVals[oIdx], 'outOfRange');\n      }\n    }\n    for (var first = 1; iIdx < iLen; iIdx++, first = 0) {\n      // If range is full, value beyond min, max will be clamped.\n      // make a singularity\n      first && stops.length && setStop(iVals[iIdx], 'outOfRange');\n      setStop(iVals[iIdx], 'inRange');\n    }\n    for (var first = 1; oIdx < oLen; oIdx++) {\n      if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {\n        // make a singularity\n        if (first) {\n          stops.length && setStop(stops[stops.length - 1].value, 'outOfRange');\n          first = 0;\n        }\n        setStop(oVals[oIdx], 'outOfRange');\n      }\n    }\n    var stopsLen = stops.length;\n    return {\n      stops: stops,\n      outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']\n    };\n  };\n  ContinuousModel.type = 'visualMap.continuous';\n  ContinuousModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(VisualMapModel/* default */.A.defaultOption, {\n    align: 'auto',\n    calculable: false,\n    hoverLink: true,\n    realtime: true,\n    handleIcon: 'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',\n    handleSize: '120%',\n    handleStyle: {\n      borderColor: '#fff',\n      borderWidth: 1\n    },\n    indicatorIcon: 'circle',\n    indicatorSize: '50%',\n    indicatorStyle: {\n      borderColor: '#fff',\n      borderWidth: 2,\n      shadowBlur: 2,\n      shadowOffsetX: 1,\n      shadowOffsetY: 1,\n      shadowColor: 'rgba(0,0,0,0.2)'\n    }\n    // emphasis: {\n    //     handleStyle: {\n    //         shadowBlur: 3,\n    //         shadowOffsetX: 1,\n    //         shadowOffsetY: 1,\n    //         shadowColor: 'rgba(0,0,0,0.2)'\n    //     }\n    // }\n  });\n  return ContinuousModel;\n}(VisualMapModel/* default */.A);\nfunction getColorStopValues(visualMapModel, valueState, dataExtent) {\n  if (dataExtent[0] === dataExtent[1]) {\n    return dataExtent.slice();\n  }\n  // When using colorHue mapping, it is not linear color any more.\n  // Moreover, canvas gradient seems not to be accurate linear.\n  // FIXME\n  // Should be arbitrary value 100? or based on pixel size?\n  var count = 200;\n  var step = (dataExtent[1] - dataExtent[0]) / count;\n  var value = dataExtent[0];\n  var stopValues = [];\n  for (var i = 0; i <= count && value < dataExtent[1]; i++) {\n    stopValues.push(value);\n    value += step;\n  }\n  stopValues.push(dataExtent[1]);\n  return stopValues;\n}\n/* harmony default export */ const visualMap_ContinuousModel = (ContinuousModel);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/LinearGradient.js\nvar LinearGradient = __webpack_require__(29668);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/event.js\nvar core_event = __webpack_require__(35452);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/VisualMapView.js\nvar VisualMapView = __webpack_require__(59044);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Rect.js + 1 modules\nvar Rect = __webpack_require__(30010);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/graphic.js\nvar graphic = __webpack_require__(43199);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/shape/Polygon.js\nvar Polygon = __webpack_require__(52505);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/helper/sliderMove.js\nvar sliderMove = __webpack_require__(98983);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/helper.js\nvar helper = __webpack_require__(46259);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/model.js\nvar model = __webpack_require__(48170);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/contain/text.js\nvar contain_text = __webpack_require__(45558);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/states.js\nvar states = __webpack_require__(34833);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Image.js\nvar Image = __webpack_require__(90540);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/innerStore.js\nvar innerStore = __webpack_require__(69622);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/event.js\nvar util_event = __webpack_require__(47411);\n;// ./node_modules/echarts/lib/component/visualMap/ContinuousView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar linearMap = number/* linearMap */.Cb;\nvar each = util.each;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n// Arbitrary value\nvar HOVER_LINK_SIZE = 12;\nvar HOVER_LINK_OUT = 6;\n// Notice:\n// Any \"interval\" should be by the order of [low, high].\n// \"handle0\" (handleIndex === 0) maps to\n// low data value: this._dataInterval[0] and has low coord.\n// \"handle1\" (handleIndex === 1) maps to\n// high data value: this._dataInterval[1] and has high coord.\n// The logic of transform is implemented in this._createBarGroup.\nvar ContinuousView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(ContinuousView, _super);\n  function ContinuousView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = ContinuousView.type;\n    _this._shapes = {};\n    _this._dataInterval = [];\n    _this._handleEnds = [];\n    _this._hoverLinkDataIndices = [];\n    return _this;\n  }\n  ContinuousView.prototype.init = function (ecModel, api) {\n    _super.prototype.init.call(this, ecModel, api);\n    this._hoverLinkFromSeriesMouseOver = util.bind(this._hoverLinkFromSeriesMouseOver, this);\n    this._hideIndicator = util.bind(this._hideIndicator, this);\n  };\n  ContinuousView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {\n    if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {\n      this._buildView();\n    }\n  };\n  ContinuousView.prototype._buildView = function () {\n    this.group.removeAll();\n    var visualMapModel = this.visualMapModel;\n    var thisGroup = this.group;\n    this._orient = visualMapModel.get('orient');\n    this._useHandle = visualMapModel.get('calculable');\n    this._resetInterval();\n    this._renderBar(thisGroup);\n    var dataRangeText = visualMapModel.get('text');\n    this._renderEndsText(thisGroup, dataRangeText, 0);\n    this._renderEndsText(thisGroup, dataRangeText, 1);\n    // Do this for background size calculation.\n    this._updateView(true);\n    // After updating view, inner shapes is built completely,\n    // and then background can be rendered.\n    this.renderBackground(thisGroup);\n    // Real update view\n    this._updateView();\n    this._enableHoverLinkToSeries();\n    this._enableHoverLinkFromSeries();\n    this.positionGroup(thisGroup);\n  };\n  ContinuousView.prototype._renderEndsText = function (group, dataRangeText, endsIndex) {\n    if (!dataRangeText) {\n      return;\n    }\n    // Compatible with ec2, text[0] map to high value, text[1] map low value.\n    var text = dataRangeText[1 - endsIndex];\n    text = text != null ? text + '' : '';\n    var visualMapModel = this.visualMapModel;\n    var textGap = visualMapModel.get('textGap');\n    var itemSize = visualMapModel.itemSize;\n    var barGroup = this._shapes.mainGroup;\n    var position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup);\n    var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);\n    var orient = this._orient;\n    var textStyleModel = this.visualMapModel.textStyleModel;\n    this.group.add(new Text/* default */.Ay({\n      style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n        x: position[0],\n        y: position[1],\n        verticalAlign: orient === 'horizontal' ? 'middle' : align,\n        align: orient === 'horizontal' ? align : 'center',\n        text: text\n      })\n    }));\n  };\n  ContinuousView.prototype._renderBar = function (targetGroup) {\n    var visualMapModel = this.visualMapModel;\n    var shapes = this._shapes;\n    var itemSize = visualMapModel.itemSize;\n    var orient = this._orient;\n    var useHandle = this._useHandle;\n    var itemAlign = helper/* getItemAlign */.J(visualMapModel, this.api, itemSize);\n    var mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign);\n    var gradientBarGroup = new Group/* default */.A();\n    mainGroup.add(gradientBarGroup);\n    // Bar\n    gradientBarGroup.add(shapes.outOfRange = createPolygon());\n    gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor(this._orient) : null, util.bind(this._dragHandle, this, 'all', false), util.bind(this._dragHandle, this, 'all', true)));\n    // A border radius clip.\n    gradientBarGroup.setClipPath(new Rect/* default */.A({\n      shape: {\n        x: 0,\n        y: 0,\n        width: itemSize[0],\n        height: itemSize[1],\n        r: 3\n      }\n    }));\n    var textRect = visualMapModel.textStyleModel.getTextRect('');\n    var textSize = mathMax(textRect.width, textRect.height);\n    // Handle\n    if (useHandle) {\n      shapes.handleThumbs = [];\n      shapes.handleLabels = [];\n      shapes.handleLabelPoints = [];\n      this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient);\n      this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient);\n    }\n    this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient);\n    targetGroup.add(mainGroup);\n  };\n  ContinuousView.prototype._createHandle = function (visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {\n    var onDrift = util.bind(this._dragHandle, this, handleIndex, false);\n    var onDragEnd = util.bind(this._dragHandle, this, handleIndex, true);\n    var handleSize = (0,contain_text/* parsePercent */.lo)(visualMapModel.get('handleSize'), itemSize[0]);\n    var handleThumb = (0,symbol/* createSymbol */.v5)(visualMapModel.get('handleIcon'), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true);\n    var cursor = getCursor(this._orient);\n    handleThumb.attr({\n      cursor: cursor,\n      draggable: true,\n      drift: onDrift,\n      ondragend: onDragEnd,\n      onmousemove: function (e) {\n        core_event/* stop */.ds(e.event);\n      }\n    });\n    handleThumb.x = itemSize[0] / 2;\n    handleThumb.useStyle(visualMapModel.getModel('handleStyle').getItemStyle());\n    handleThumb.setStyle({\n      strokeNoScale: true,\n      strokeFirst: true\n    });\n    handleThumb.style.lineWidth *= 2;\n    handleThumb.ensureState('emphasis').style = visualMapModel.getModel(['emphasis', 'handleStyle']).getItemStyle();\n    (0,states/* setAsHighDownDispatcher */.ix)(handleThumb, true);\n    mainGroup.add(handleThumb);\n    // Text is always horizontal layout but should not be effected by\n    // transform (orient/inverse). So label is built separately but not\n    // use zrender/graphic/helper/RectText, and is located based on view\n    // group (according to handleLabelPoint) but not barGroup.\n    var textStyleModel = this.visualMapModel.textStyleModel;\n    var handleLabel = new Text/* default */.Ay({\n      cursor: cursor,\n      draggable: true,\n      drift: onDrift,\n      onmousemove: function (e) {\n        // For mobile device, prevent screen slider on the button.\n        core_event/* stop */.ds(e.event);\n      },\n      ondragend: onDragEnd,\n      style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n        x: 0,\n        y: 0,\n        text: ''\n      })\n    });\n    handleLabel.ensureState('blur').style = {\n      opacity: 0.1\n    };\n    handleLabel.stateTransition = {\n      duration: 200\n    };\n    this.group.add(handleLabel);\n    var handleLabelPoint = [handleSize, 0];\n    var shapes = this._shapes;\n    shapes.handleThumbs[handleIndex] = handleThumb;\n    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;\n    shapes.handleLabels[handleIndex] = handleLabel;\n  };\n  ContinuousView.prototype._createIndicator = function (visualMapModel, mainGroup, itemSize, textSize, orient) {\n    var scale = (0,contain_text/* parsePercent */.lo)(visualMapModel.get('indicatorSize'), itemSize[0]);\n    var indicator = (0,symbol/* createSymbol */.v5)(visualMapModel.get('indicatorIcon'), -scale / 2, -scale / 2, scale, scale, null, true);\n    indicator.attr({\n      cursor: 'move',\n      invisible: true,\n      silent: true,\n      x: itemSize[0] / 2\n    });\n    var indicatorStyle = visualMapModel.getModel('indicatorStyle').getItemStyle();\n    if (indicator instanceof Image/* default */.Ay) {\n      var pathStyle = indicator.style;\n      indicator.useStyle(util.extend({\n        // TODO other properties like x, y ?\n        image: pathStyle.image,\n        x: pathStyle.x,\n        y: pathStyle.y,\n        width: pathStyle.width,\n        height: pathStyle.height\n      }, indicatorStyle));\n    } else {\n      indicator.useStyle(indicatorStyle);\n    }\n    mainGroup.add(indicator);\n    var textStyleModel = this.visualMapModel.textStyleModel;\n    var indicatorLabel = new Text/* default */.Ay({\n      silent: true,\n      invisible: true,\n      style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n        x: 0,\n        y: 0,\n        text: ''\n      })\n    });\n    this.group.add(indicatorLabel);\n    var indicatorLabelPoint = [(orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0];\n    var shapes = this._shapes;\n    shapes.indicator = indicator;\n    shapes.indicatorLabel = indicatorLabel;\n    shapes.indicatorLabelPoint = indicatorLabelPoint;\n    this._firstShowIndicator = true;\n  };\n  ContinuousView.prototype._dragHandle = function (handleIndex, isEnd,\n  // dx is event from ondragend if isEnd is true. It's not used\n  dx, dy) {\n    if (!this._useHandle) {\n      return;\n    }\n    this._dragging = !isEnd;\n    if (!isEnd) {\n      // Transform dx, dy to bar coordination.\n      var vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true);\n      this._updateInterval(handleIndex, vertex[1]);\n      this._hideIndicator();\n      // Considering realtime, update view should be executed\n      // before dispatch action.\n      this._updateView();\n    }\n    // dragEnd do not dispatch action when realtime.\n    if (isEnd === !this.visualMapModel.get('realtime')) {\n      // jshint ignore:line\n      this.api.dispatchAction({\n        type: 'selectDataRange',\n        from: this.uid,\n        visualMapId: this.visualMapModel.id,\n        selected: this._dataInterval.slice()\n      });\n    }\n    if (isEnd) {\n      !this._hovering && this._clearHoverLinkToSeries();\n    } else if (useHoverLinkOnHandle(this.visualMapModel)) {\n      this._doHoverLinkToSeries(this._handleEnds[handleIndex], false);\n    }\n  };\n  ContinuousView.prototype._resetInterval = function () {\n    var visualMapModel = this.visualMapModel;\n    var dataInterval = this._dataInterval = visualMapModel.getSelected();\n    var dataExtent = visualMapModel.getExtent();\n    var sizeExtent = [0, visualMapModel.itemSize[1]];\n    this._handleEnds = [linearMap(dataInterval[0], dataExtent, sizeExtent, true), linearMap(dataInterval[1], dataExtent, sizeExtent, true)];\n  };\n  /**\r\n   * @private\r\n   * @param {(number|string)} handleIndex 0 or 1 or 'all'\r\n   * @param {number} dx\r\n   * @param {number} dy\r\n   */\n  ContinuousView.prototype._updateInterval = function (handleIndex, delta) {\n    delta = delta || 0;\n    var visualMapModel = this.visualMapModel;\n    var handleEnds = this._handleEnds;\n    var sizeExtent = [0, visualMapModel.itemSize[1]];\n    (0,sliderMove/* default */.A)(delta, handleEnds, sizeExtent, handleIndex,\n    // cross is forbidden\n    0);\n    var dataExtent = visualMapModel.getExtent();\n    // Update data interval.\n    this._dataInterval = [linearMap(handleEnds[0], sizeExtent, dataExtent, true), linearMap(handleEnds[1], sizeExtent, dataExtent, true)];\n  };\n  ContinuousView.prototype._updateView = function (forSketch) {\n    var visualMapModel = this.visualMapModel;\n    var dataExtent = visualMapModel.getExtent();\n    var shapes = this._shapes;\n    var outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]];\n    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;\n    var visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange');\n    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');\n    shapes.inRange.setStyle({\n      fill: visualInRange.barColor\n      // opacity: visualInRange.opacity\n    }).setShape('points', visualInRange.barPoints);\n    shapes.outOfRange.setStyle({\n      fill: visualOutOfRange.barColor\n      // opacity: visualOutOfRange.opacity\n    }).setShape('points', visualOutOfRange.barPoints);\n    this._updateHandle(inRangeHandleEnds, visualInRange);\n  };\n  ContinuousView.prototype._createBarVisual = function (dataInterval, dataExtent, handleEnds, forceState) {\n    var opts = {\n      forceState: forceState,\n      convertOpacityToAlpha: true\n    };\n    var colorStops = this._makeColorGradient(dataInterval, opts);\n    var symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)];\n    var barPoints = this._createBarPoints(handleEnds, symbolSizes);\n    return {\n      barColor: new LinearGradient/* default */.A(0, 0, 0, 1, colorStops),\n      barPoints: barPoints,\n      handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]\n    };\n  };\n  ContinuousView.prototype._makeColorGradient = function (dataInterval, opts) {\n    // Considering colorHue, which is not linear, so we have to sample\n    // to calculate gradient color stops, but not only calculate head\n    // and tail.\n    var sampleNumber = 100; // Arbitrary value.\n    var colorStops = [];\n    var step = (dataInterval[1] - dataInterval[0]) / sampleNumber;\n    colorStops.push({\n      color: this.getControllerVisual(dataInterval[0], 'color', opts),\n      offset: 0\n    });\n    for (var i = 1; i < sampleNumber; i++) {\n      var currValue = dataInterval[0] + step * i;\n      if (currValue > dataInterval[1]) {\n        break;\n      }\n      colorStops.push({\n        color: this.getControllerVisual(currValue, 'color', opts),\n        offset: i / sampleNumber\n      });\n    }\n    colorStops.push({\n      color: this.getControllerVisual(dataInterval[1], 'color', opts),\n      offset: 1\n    });\n    return colorStops;\n  };\n  ContinuousView.prototype._createBarPoints = function (handleEnds, symbolSizes) {\n    var itemSize = this.visualMapModel.itemSize;\n    return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]];\n  };\n  ContinuousView.prototype._createBarGroup = function (itemAlign) {\n    var orient = this._orient;\n    var inverse = this.visualMapModel.get('inverse');\n    return new Group/* default */.A(orient === 'horizontal' && !inverse ? {\n      scaleX: itemAlign === 'bottom' ? 1 : -1,\n      rotation: Math.PI / 2\n    } : orient === 'horizontal' && inverse ? {\n      scaleX: itemAlign === 'bottom' ? -1 : 1,\n      rotation: -Math.PI / 2\n    } : orient === 'vertical' && !inverse ? {\n      scaleX: itemAlign === 'left' ? 1 : -1,\n      scaleY: -1\n    } : {\n      scaleX: itemAlign === 'left' ? 1 : -1\n    });\n  };\n  ContinuousView.prototype._updateHandle = function (handleEnds, visualInRange) {\n    if (!this._useHandle) {\n      return;\n    }\n    var shapes = this._shapes;\n    var visualMapModel = this.visualMapModel;\n    var handleThumbs = shapes.handleThumbs;\n    var handleLabels = shapes.handleLabels;\n    var itemSize = visualMapModel.itemSize;\n    var dataExtent = visualMapModel.getExtent();\n    var align = this._applyTransform('left', shapes.mainGroup);\n    each([0, 1], function (handleIndex) {\n      var handleThumb = handleThumbs[handleIndex];\n      handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex]);\n      handleThumb.y = handleEnds[handleIndex];\n      var val = linearMap(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true);\n      var symbolSize = this.getControllerVisual(val, 'symbolSize');\n      handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0];\n      handleThumb.x = itemSize[0] - symbolSize / 2;\n      // Update handle label position.\n      var textPoint = graphic.applyTransform(shapes.handleLabelPoints[handleIndex], graphic.getTransform(handleThumb, this.group));\n      if (this._orient === 'horizontal') {\n        // If visualMap controls symbol size, an additional offset needs to be added to labels to avoid collision at minimum size.\n        // Offset reaches value of 0 at \"maximum\" position, so maximum position is not altered at all.\n        var minimumOffset = align === 'left' || align === 'top' ? (itemSize[0] - symbolSize) / 2 : (itemSize[0] - symbolSize) / -2;\n        textPoint[1] += minimumOffset;\n      }\n      handleLabels[handleIndex].setStyle({\n        x: textPoint[0],\n        y: textPoint[1],\n        text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),\n        verticalAlign: 'middle',\n        align: this._orient === 'vertical' ? this._applyTransform('left', shapes.mainGroup) : 'center'\n      });\n    }, this);\n  };\n  ContinuousView.prototype._showIndicator = function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {\n    var visualMapModel = this.visualMapModel;\n    var dataExtent = visualMapModel.getExtent();\n    var itemSize = visualMapModel.itemSize;\n    var sizeExtent = [0, itemSize[1]];\n    var shapes = this._shapes;\n    var indicator = shapes.indicator;\n    if (!indicator) {\n      return;\n    }\n    indicator.attr('invisible', false);\n    var opts = {\n      convertOpacityToAlpha: true\n    };\n    var color = this.getControllerVisual(cursorValue, 'color', opts);\n    var symbolSize = this.getControllerVisual(cursorValue, 'symbolSize');\n    var y = linearMap(cursorValue, dataExtent, sizeExtent, true);\n    var x = itemSize[0] - symbolSize / 2;\n    var oldIndicatorPos = {\n      x: indicator.x,\n      y: indicator.y\n    };\n    // Update handle label position.\n    indicator.y = y;\n    indicator.x = x;\n    var textPoint = graphic.applyTransform(shapes.indicatorLabelPoint, graphic.getTransform(indicator, this.group));\n    var indicatorLabel = shapes.indicatorLabel;\n    indicatorLabel.attr('invisible', false);\n    var align = this._applyTransform('left', shapes.mainGroup);\n    var orient = this._orient;\n    var isHorizontal = orient === 'horizontal';\n    indicatorLabel.setStyle({\n      text: (rangeSymbol ? rangeSymbol : '') + visualMapModel.formatValueText(textValue),\n      verticalAlign: isHorizontal ? align : 'middle',\n      align: isHorizontal ? 'center' : align\n    });\n    var indicatorNewProps = {\n      x: x,\n      y: y,\n      style: {\n        fill: color\n      }\n    };\n    var labelNewProps = {\n      style: {\n        x: textPoint[0],\n        y: textPoint[1]\n      }\n    };\n    if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {\n      var animationCfg = {\n        duration: 100,\n        easing: 'cubicInOut',\n        additive: true\n      };\n      indicator.x = oldIndicatorPos.x;\n      indicator.y = oldIndicatorPos.y;\n      indicator.animateTo(indicatorNewProps, animationCfg);\n      indicatorLabel.animateTo(labelNewProps, animationCfg);\n    } else {\n      indicator.attr(indicatorNewProps);\n      indicatorLabel.attr(labelNewProps);\n    }\n    this._firstShowIndicator = false;\n    var handleLabels = this._shapes.handleLabels;\n    if (handleLabels) {\n      for (var i = 0; i < handleLabels.length; i++) {\n        // Fade out handle labels.\n        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.\n        this.api.enterBlur(handleLabels[i]);\n      }\n    }\n  };\n  ContinuousView.prototype._enableHoverLinkToSeries = function () {\n    var self = this;\n    this._shapes.mainGroup.on('mousemove', function (e) {\n      self._hovering = true;\n      if (!self._dragging) {\n        var itemSize = self.visualMapModel.itemSize;\n        var pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.mainGroup, true, true);\n        // For hover link show when hover handle, which might be\n        // below or upper than sizeExtent.\n        pos[1] = mathMin(mathMax(0, pos[1]), itemSize[1]);\n        self._doHoverLinkToSeries(pos[1], 0 <= pos[0] && pos[0] <= itemSize[0]);\n      }\n    }).on('mouseout', function () {\n      // When mouse is out of handle, hoverLink still need\n      // to be displayed when realtime is set as false.\n      self._hovering = false;\n      !self._dragging && self._clearHoverLinkToSeries();\n    });\n  };\n  ContinuousView.prototype._enableHoverLinkFromSeries = function () {\n    var zr = this.api.getZr();\n    if (this.visualMapModel.option.hoverLink) {\n      zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this);\n      zr.on('mouseout', this._hideIndicator, this);\n    } else {\n      this._clearHoverLinkFromSeries();\n    }\n  };\n  ContinuousView.prototype._doHoverLinkToSeries = function (cursorPos, hoverOnBar) {\n    var visualMapModel = this.visualMapModel;\n    var itemSize = visualMapModel.itemSize;\n    if (!visualMapModel.option.hoverLink) {\n      return;\n    }\n    var sizeExtent = [0, itemSize[1]];\n    var dataExtent = visualMapModel.getExtent();\n    // For hover link show when hover handle, which might be below or upper than sizeExtent.\n    cursorPos = mathMin(mathMax(sizeExtent[0], cursorPos), sizeExtent[1]);\n    var halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent);\n    var hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize];\n    var cursorValue = linearMap(cursorPos, sizeExtent, dataExtent, true);\n    var valueRange = [linearMap(hoverRange[0], sizeExtent, dataExtent, true), linearMap(hoverRange[1], sizeExtent, dataExtent, true)];\n    // Consider data range is out of visualMap range, see test/visualMap-continuous.html,\n    // where china and india has very large population.\n    hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity);\n    hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity);\n    // Do not show indicator when mouse is over handle,\n    // otherwise labels overlap, especially when dragging.\n    if (hoverOnBar) {\n      if (valueRange[0] === -Infinity) {\n        this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize);\n      } else if (valueRange[1] === Infinity) {\n        this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize);\n      } else {\n        this._showIndicator(cursorValue, cursorValue, ' ', halfHoverLinkSize);\n      }\n    }\n    // When realtime is set as false, handles, which are in barGroup,\n    // also trigger hoverLink, which help user to realize where they\n    // focus on when dragging. (see test/heatmap-large.html)\n    // When realtime is set as true, highlight will not show when hover\n    // handle, because the label on handle, which displays a exact value\n    // but not range, might mislead users.\n    var oldBatch = this._hoverLinkDataIndices;\n    var newBatch = [];\n    if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {\n      newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange);\n    }\n    var resultBatches = model/* compressBatches */.D6(oldBatch, newBatch);\n    this._dispatchHighDown('downplay', helper/* makeHighDownBatch */.l(resultBatches[0], visualMapModel));\n    this._dispatchHighDown('highlight', helper/* makeHighDownBatch */.l(resultBatches[1], visualMapModel));\n  };\n  ContinuousView.prototype._hoverLinkFromSeriesMouseOver = function (e) {\n    var ecData;\n    (0,util_event/* findEventDispatcher */.R)(e.target, function (target) {\n      var currECData = (0,innerStore/* getECData */.z)(target);\n      if (currECData.dataIndex != null) {\n        ecData = currECData;\n        return true;\n      }\n    }, true);\n    if (!ecData) {\n      return;\n    }\n    var dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex);\n    var visualMapModel = this.visualMapModel;\n    if (!visualMapModel.isTargetSeries(dataModel)) {\n      return;\n    }\n    var data = dataModel.getData(ecData.dataType);\n    var value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex);\n    if (!isNaN(value)) {\n      this._showIndicator(value, value);\n    }\n  };\n  ContinuousView.prototype._hideIndicator = function () {\n    var shapes = this._shapes;\n    shapes.indicator && shapes.indicator.attr('invisible', true);\n    shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true);\n    var handleLabels = this._shapes.handleLabels;\n    if (handleLabels) {\n      for (var i = 0; i < handleLabels.length; i++) {\n        // Fade out handle labels.\n        // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.\n        this.api.leaveBlur(handleLabels[i]);\n      }\n    }\n  };\n  ContinuousView.prototype._clearHoverLinkToSeries = function () {\n    this._hideIndicator();\n    var indices = this._hoverLinkDataIndices;\n    this._dispatchHighDown('downplay', helper/* makeHighDownBatch */.l(indices, this.visualMapModel));\n    indices.length = 0;\n  };\n  ContinuousView.prototype._clearHoverLinkFromSeries = function () {\n    this._hideIndicator();\n    var zr = this.api.getZr();\n    zr.off('mouseover', this._hoverLinkFromSeriesMouseOver);\n    zr.off('mouseout', this._hideIndicator);\n  };\n  ContinuousView.prototype._applyTransform = function (vertex, element, inverse, global) {\n    var transform = graphic.getTransform(element, global ? null : this.group);\n    return util.isArray(vertex) ? graphic.applyTransform(vertex, transform, inverse) : graphic.transformDirection(vertex, transform, inverse);\n  };\n  // TODO: TYPE more specified payload types.\n  ContinuousView.prototype._dispatchHighDown = function (type, batch) {\n    batch && batch.length && this.api.dispatchAction({\n      type: type,\n      batch: batch\n    });\n  };\n  /**\r\n   * @override\r\n   */\n  ContinuousView.prototype.dispose = function () {\n    this._clearHoverLinkFromSeries();\n    this._clearHoverLinkToSeries();\n  };\n  ContinuousView.type = 'visualMap.continuous';\n  return ContinuousView;\n}(VisualMapView/* default */.A);\nfunction createPolygon(points, cursor, onDrift, onDragEnd) {\n  return new Polygon/* default */.A({\n    shape: {\n      points: points\n    },\n    draggable: !!onDrift,\n    cursor: cursor,\n    drift: onDrift,\n    onmousemove: function (e) {\n      // For mobile device, prevent screen slider on the button.\n      core_event/* stop */.ds(e.event);\n    },\n    ondragend: onDragEnd\n  });\n}\nfunction getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent) {\n  var halfHoverLinkSize = HOVER_LINK_SIZE / 2;\n  var hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize');\n  if (hoverLinkDataSize) {\n    halfHoverLinkSize = linearMap(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2;\n  }\n  return halfHoverLinkSize;\n}\nfunction useHoverLinkOnHandle(visualMapModel) {\n  var hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle');\n  return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle);\n}\nfunction getCursor(orient) {\n  return orient === 'vertical' ? 'ns-resize' : 'ew-resize';\n}\n/* harmony default export */ const visualMap_ContinuousView = (ContinuousView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(41369);\n;// ./node_modules/echarts/lib/component/visualMap/installVisualMapContinuous.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(visualMap_ContinuousModel);\n  registers.registerComponentView(visualMap_ContinuousView);\n  (0,installCommon/* default */.A)(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjcxMTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDOVBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0ckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL0NvbnRpbnVvdXNNb2RlbC5qcz8yNGRiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL0NvbnRpbnVvdXNWaWV3LmpzPzY5MzYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2VjaGFydHMvbGliL2NvbXBvbmVudC92aXN1YWxNYXAvaW5zdGFsbFZpc3VhbE1hcENvbnRpbnVvdXMuanM/MmUwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0ICogYXMgenJVdGlsIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcyc7XG5pbXBvcnQgVmlzdWFsTWFwTW9kZWwgZnJvbSAnLi9WaXN1YWxNYXBNb2RlbC5qcyc7XG5pbXBvcnQgKiBhcyBudW1iZXJVdGlsIGZyb20gJy4uLy4uL3V0aWwvbnVtYmVyLmpzJztcbmltcG9ydCB7IGluaGVyaXREZWZhdWx0T3B0aW9uIH0gZnJvbSAnLi4vLi4vdXRpbC9jb21wb25lbnQuanMnO1xuLy8gQ29uc3RhbnRcbnZhciBERUZBVUxUX0JBUl9CT1VORCA9IFsyMCwgMTQwXTtcbnZhciBDb250aW51b3VzTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoQ29udGludW91c01vZGVsLCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDb250aW51b3VzTW9kZWwoKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgX3RoaXMudHlwZSA9IENvbnRpbnVvdXNNb2RlbC50eXBlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ29udGludW91c01vZGVsLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkID0gZnVuY3Rpb24gKG5ld09wdGlvbiwgaXNJbml0KSB7XG4gICAgX3N1cGVyLnByb3RvdHlwZS5vcHRpb25VcGRhdGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdGhpcy5yZXNldEV4dGVudCgpO1xuICAgIHRoaXMucmVzZXRWaXN1YWwoZnVuY3Rpb24gKG1hcHBpbmdPcHRpb24pIHtcbiAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdsaW5lYXInO1xuICAgICAgbWFwcGluZ09wdGlvbi5kYXRhRXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNldFJhbmdlKCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ29udGludW91c01vZGVsLnByb3RvdHlwZS5yZXNldEl0ZW1TaXplID0gZnVuY3Rpb24gKCkge1xuICAgIF9zdXBlci5wcm90b3R5cGUucmVzZXRJdGVtU2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMuaXRlbVNpemU7XG4gICAgKGl0ZW1TaXplWzBdID09IG51bGwgfHwgaXNOYU4oaXRlbVNpemVbMF0pKSAmJiAoaXRlbVNpemVbMF0gPSBERUZBVUxUX0JBUl9CT1VORFswXSk7XG4gICAgKGl0ZW1TaXplWzFdID09IG51bGwgfHwgaXNOYU4oaXRlbVNpemVbMV0pKSAmJiAoaXRlbVNpemVbMV0gPSBERUZBVUxUX0JBUl9CT1VORFsxXSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUuX3Jlc2V0UmFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB0aGlzLmdldEV4dGVudCgpO1xuICAgIHZhciByYW5nZSA9IHRoaXMub3B0aW9uLnJhbmdlO1xuICAgIGlmICghcmFuZ2UgfHwgcmFuZ2UuYXV0bykge1xuICAgICAgLy8gYHJhbmdlYCBzaG91bGQgYWx3YXlzIGJlIGFycmF5IChzbyB3ZSBkb24ndCB1c2Ugb3RoZXJcbiAgICAgIC8vIHZhbHVlIGxpa2UgJ2F1dG8nKSBmb3IgdXNlci1mcmllbmQuIChjb25zaWRlciBnZXRPcHRpb24pLlxuICAgICAgZGF0YUV4dGVudC5hdXRvID0gMTtcbiAgICAgIHRoaXMub3B0aW9uLnJhbmdlID0gZGF0YUV4dGVudDtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc0FycmF5KHJhbmdlKSkge1xuICAgICAgaWYgKHJhbmdlWzBdID4gcmFuZ2VbMV0pIHtcbiAgICAgICAgcmFuZ2UucmV2ZXJzZSgpO1xuICAgICAgfVxuICAgICAgcmFuZ2VbMF0gPSBNYXRoLm1heChyYW5nZVswXSwgZGF0YUV4dGVudFswXSk7XG4gICAgICByYW5nZVsxXSA9IE1hdGgubWluKHJhbmdlWzFdLCBkYXRhRXh0ZW50WzFdKTtcbiAgICB9XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ29udGludW91c01vZGVsLnByb3RvdHlwZS5jb21wbGV0ZVZpc3VhbE9wdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLmNvbXBsZXRlVmlzdWFsT3B0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgenJVdGlsLmVhY2godGhpcy5zdGF0ZUxpc3QsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSB0aGlzLm9wdGlvbi5jb250cm9sbGVyW3N0YXRlXS5zeW1ib2xTaXplO1xuICAgICAgaWYgKHN5bWJvbFNpemUgJiYgc3ltYm9sU2l6ZVswXSAhPT0gc3ltYm9sU2l6ZVsxXSkge1xuICAgICAgICBzeW1ib2xTaXplWzBdID0gc3ltYm9sU2l6ZVsxXSAvIDM7IC8vIEZvciBnb29kIGxvb2tpbmcuXG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdGhpcy5vcHRpb24ucmFuZ2UgPSBzZWxlY3RlZC5zbGljZSgpO1xuICAgIHRoaXMuX3Jlc2V0UmFuZ2UoKTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLmdldFNlbGVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgZGF0YUludGVydmFsID0gbnVtYmVyVXRpbC5hc2MoKHRoaXMuZ2V0KCdyYW5nZScpIHx8IFtdKS5zbGljZSgpKTtcbiAgICAvLyBDbGFtcFxuICAgIGRhdGFJbnRlcnZhbFswXSA+IGRhdGFFeHRlbnRbMV0gJiYgKGRhdGFJbnRlcnZhbFswXSA9IGRhdGFFeHRlbnRbMV0pO1xuICAgIGRhdGFJbnRlcnZhbFsxXSA+IGRhdGFFeHRlbnRbMV0gJiYgKGRhdGFJbnRlcnZhbFsxXSA9IGRhdGFFeHRlbnRbMV0pO1xuICAgIGRhdGFJbnRlcnZhbFswXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFJbnRlcnZhbFswXSA9IGRhdGFFeHRlbnRbMF0pO1xuICAgIGRhdGFJbnRlcnZhbFsxXSA8IGRhdGFFeHRlbnRbMF0gJiYgKGRhdGFJbnRlcnZhbFsxXSA9IGRhdGFFeHRlbnRbMF0pO1xuICAgIHJldHVybiBkYXRhSW50ZXJ2YWw7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBvdmVycmlkZVxyXG4gICAqL1xuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLmdldFZhbHVlU3RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLm9wdGlvbi5yYW5nZTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgLy8gV2hlbiByYW5nZVswXSA9PT0gZGF0YUV4dGVudFswXSwgYW55IHZhbHVlIGxhcmdlciB0aGFuIGRhdGFFeHRlbnRbMF0gbWFwcyB0byAnaW5SYW5nZScuXG4gICAgLy8gcmFuZ2VbMV0gaXMgcHJvY2Vzc2VkIGxpa2V3aXNlLlxuICAgIHJldHVybiAocmFuZ2VbMF0gPD0gZGF0YUV4dGVudFswXSB8fCByYW5nZVswXSA8PSB2YWx1ZSkgJiYgKHJhbmdlWzFdID49IGRhdGFFeHRlbnRbMV0gfHwgdmFsdWUgPD0gcmFuZ2VbMV0pID8gJ2luUmFuZ2UnIDogJ291dE9mUmFuZ2UnO1xuICB9O1xuICBDb250aW51b3VzTW9kZWwucHJvdG90eXBlLmZpbmRUYXJnZXREYXRhSW5kaWNlcyA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB0aGlzLmVhY2hUYXJnZXRTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgZGF0YS5lYWNoKHRoaXMuZ2V0RGF0YURpbWVuc2lvbkluZGV4KGRhdGEpLCBmdW5jdGlvbiAodmFsdWUsIGRhdGFJbmRleCkge1xuICAgICAgICByYW5nZVswXSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSByYW5nZVsxXSAmJiBkYXRhSW5kaWNlcy5wdXNoKGRhdGFJbmRleCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgc2VyaWVzSWQ6IHNlcmllc01vZGVsLmlkLFxuICAgICAgICBkYXRhSW5kZXg6IGRhdGFJbmRpY2VzXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICAvKipcclxuICAgKiBAaW1wbGVtZW50XHJcbiAgICovXG4gIENvbnRpbnVvdXNNb2RlbC5wcm90b3R5cGUuZ2V0VmlzdWFsTWV0YSA9IGZ1bmN0aW9uIChnZXRDb2xvclZpc3VhbCkge1xuICAgIHZhciBvVmFscyA9IGdldENvbG9yU3RvcFZhbHVlcyh0aGlzLCAnb3V0T2ZSYW5nZScsIHRoaXMuZ2V0RXh0ZW50KCkpO1xuICAgIHZhciBpVmFscyA9IGdldENvbG9yU3RvcFZhbHVlcyh0aGlzLCAnaW5SYW5nZScsIHRoaXMub3B0aW9uLnJhbmdlLnNsaWNlKCkpO1xuICAgIHZhciBzdG9wcyA9IFtdO1xuICAgIGZ1bmN0aW9uIHNldFN0b3AodmFsdWUsIHZhbHVlU3RhdGUpIHtcbiAgICAgIHN0b3BzLnB1c2goe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGNvbG9yOiBnZXRDb2xvclZpc3VhbCh2YWx1ZSwgdmFsdWVTdGF0ZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgdG86IG91dE9mUmFuZ2UgLS0gaW5SYW5nZSAtLSBvdXRPZlJhbmdlLlxuICAgIHZhciBpSWR4ID0gMDtcbiAgICB2YXIgb0lkeCA9IDA7XG4gICAgdmFyIGlMZW4gPSBpVmFscy5sZW5ndGg7XG4gICAgdmFyIG9MZW4gPSBvVmFscy5sZW5ndGg7XG4gICAgZm9yICg7IG9JZHggPCBvTGVuICYmICghaVZhbHMubGVuZ3RoIHx8IG9WYWxzW29JZHhdIDw9IGlWYWxzWzBdKTsgb0lkeCsrKSB7XG4gICAgICAvLyBJZiBvVmFsW29JZHhdID09PSBpVmFsc1tpSWR4XSwgb1ZhbFtvSWR4XSBzaG91bGQgYmUgaWdub3JlZC5cbiAgICAgIGlmIChvVmFsc1tvSWR4XSA8IGlWYWxzW2lJZHhdKSB7XG4gICAgICAgIHNldFN0b3Aob1ZhbHNbb0lkeF0sICdvdXRPZlJhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGZpcnN0ID0gMTsgaUlkeCA8IGlMZW47IGlJZHgrKywgZmlyc3QgPSAwKSB7XG4gICAgICAvLyBJZiByYW5nZSBpcyBmdWxsLCB2YWx1ZSBiZXlvbmQgbWluLCBtYXggd2lsbCBiZSBjbGFtcGVkLlxuICAgICAgLy8gbWFrZSBhIHNpbmd1bGFyaXR5XG4gICAgICBmaXJzdCAmJiBzdG9wcy5sZW5ndGggJiYgc2V0U3RvcChpVmFsc1tpSWR4XSwgJ291dE9mUmFuZ2UnKTtcbiAgICAgIHNldFN0b3AoaVZhbHNbaUlkeF0sICdpblJhbmdlJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGZpcnN0ID0gMTsgb0lkeCA8IG9MZW47IG9JZHgrKykge1xuICAgICAgaWYgKCFpVmFscy5sZW5ndGggfHwgaVZhbHNbaVZhbHMubGVuZ3RoIC0gMV0gPCBvVmFsc1tvSWR4XSkge1xuICAgICAgICAvLyBtYWtlIGEgc2luZ3VsYXJpdHlcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgc3RvcHMubGVuZ3RoICYmIHNldFN0b3Aoc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0udmFsdWUsICdvdXRPZlJhbmdlJyk7XG4gICAgICAgICAgZmlyc3QgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldFN0b3Aob1ZhbHNbb0lkeF0sICdvdXRPZlJhbmdlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdG9wc0xlbiA9IHN0b3BzLmxlbmd0aDtcbiAgICByZXR1cm4ge1xuICAgICAgc3RvcHM6IHN0b3BzLFxuICAgICAgb3V0ZXJDb2xvcnM6IFtzdG9wc0xlbiA/IHN0b3BzWzBdLmNvbG9yIDogJ3RyYW5zcGFyZW50Jywgc3RvcHNMZW4gPyBzdG9wc1tzdG9wc0xlbiAtIDFdLmNvbG9yIDogJ3RyYW5zcGFyZW50J11cbiAgICB9O1xuICB9O1xuICBDb250aW51b3VzTW9kZWwudHlwZSA9ICd2aXN1YWxNYXAuY29udGludW91cyc7XG4gIENvbnRpbnVvdXNNb2RlbC5kZWZhdWx0T3B0aW9uID0gaW5oZXJpdERlZmF1bHRPcHRpb24oVmlzdWFsTWFwTW9kZWwuZGVmYXVsdE9wdGlvbiwge1xuICAgIGFsaWduOiAnYXV0bycsXG4gICAgY2FsY3VsYWJsZTogZmFsc2UsXG4gICAgaG92ZXJMaW5rOiB0cnVlLFxuICAgIHJlYWx0aW1lOiB0cnVlLFxuICAgIGhhbmRsZUljb246ICdwYXRoOi8vTS0xMS4zOSw5Ljc3aDBhMy41LDMuNSwwLDAsMS0zLjUsMy41aC0yMmEzLjUsMy41LDAsMCwxLTMuNS0zLjVoMGEzLjUsMy41LDAsMCwxLDMuNS0zLjVoMjJBMy41LDMuNSwwLDAsMS0xMS4zOSw5Ljc3WicsXG4gICAgaGFuZGxlU2l6ZTogJzEyMCUnLFxuICAgIGhhbmRsZVN0eWxlOiB7XG4gICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICB9LFxuICAgIGluZGljYXRvckljb246ICdjaXJjbGUnLFxuICAgIGluZGljYXRvclNpemU6ICc1MCUnLFxuICAgIGluZGljYXRvclN0eWxlOiB7XG4gICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgYm9yZGVyV2lkdGg6IDIsXG4gICAgICBzaGFkb3dCbHVyOiAyLFxuICAgICAgc2hhZG93T2Zmc2V0WDogMSxcbiAgICAgIHNoYWRvd09mZnNldFk6IDEsXG4gICAgICBzaGFkb3dDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKSdcbiAgICB9XG4gICAgLy8gZW1waGFzaXM6IHtcbiAgICAvLyAgICAgaGFuZGxlU3R5bGU6IHtcbiAgICAvLyAgICAgICAgIHNoYWRvd0JsdXI6IDMsXG4gICAgLy8gICAgICAgICBzaGFkb3dPZmZzZXRYOiAxLFxuICAgIC8vICAgICAgICAgc2hhZG93T2Zmc2V0WTogMSxcbiAgICAvLyAgICAgICAgIHNoYWRvd0NvbG9yOiAncmdiYSgwLDAsMCwwLjIpJ1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxuICB9KTtcbiAgcmV0dXJuIENvbnRpbnVvdXNNb2RlbDtcbn0oVmlzdWFsTWFwTW9kZWwpO1xuZnVuY3Rpb24gZ2V0Q29sb3JTdG9wVmFsdWVzKHZpc3VhbE1hcE1vZGVsLCB2YWx1ZVN0YXRlLCBkYXRhRXh0ZW50KSB7XG4gIGlmIChkYXRhRXh0ZW50WzBdID09PSBkYXRhRXh0ZW50WzFdKSB7XG4gICAgcmV0dXJuIGRhdGFFeHRlbnQuc2xpY2UoKTtcbiAgfVxuICAvLyBXaGVuIHVzaW5nIGNvbG9ySHVlIG1hcHBpbmcsIGl0IGlzIG5vdCBsaW5lYXIgY29sb3IgYW55IG1vcmUuXG4gIC8vIE1vcmVvdmVyLCBjYW52YXMgZ3JhZGllbnQgc2VlbXMgbm90IHRvIGJlIGFjY3VyYXRlIGxpbmVhci5cbiAgLy8gRklYTUVcbiAgLy8gU2hvdWxkIGJlIGFyYml0cmFyeSB2YWx1ZSAxMDA/IG9yIGJhc2VkIG9uIHBpeGVsIHNpemU/XG4gIHZhciBjb3VudCA9IDIwMDtcbiAgdmFyIHN0ZXAgPSAoZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gY291bnQ7XG4gIHZhciB2YWx1ZSA9IGRhdGFFeHRlbnRbMF07XG4gIHZhciBzdG9wVmFsdWVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50ICYmIHZhbHVlIDwgZGF0YUV4dGVudFsxXTsgaSsrKSB7XG4gICAgc3RvcFZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICB2YWx1ZSArPSBzdGVwO1xuICB9XG4gIHN0b3BWYWx1ZXMucHVzaChkYXRhRXh0ZW50WzFdKTtcbiAgcmV0dXJuIHN0b3BWYWx1ZXM7XG59XG5leHBvcnQgZGVmYXVsdCBDb250aW51b3VzTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IExpbmVhckdyYWRpZW50IGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvTGluZWFyR3JhZGllbnQuanMnO1xuaW1wb3J0ICogYXMgZXZlbnRUb29sIGZyb20gJ3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanMnO1xuaW1wb3J0IFZpc3VhbE1hcFZpZXcgZnJvbSAnLi9WaXN1YWxNYXBWaWV3LmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCAqIGFzIG51bWJlclV0aWwgZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHNsaWRlck1vdmUgZnJvbSAnLi4vaGVscGVyL3NsaWRlck1vdmUuanMnO1xuaW1wb3J0ICogYXMgaGVscGVyIGZyb20gJy4vaGVscGVyLmpzJztcbmltcG9ydCAqIGFzIG1vZGVsVXRpbCBmcm9tICcuLi8uLi91dGlsL21vZGVsLmpzJztcbmltcG9ydCB7IHBhcnNlUGVyY2VudCB9IGZyb20gJ3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcyc7XG5pbXBvcnQgeyBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlciB9IGZyb20gJy4uLy4uL3V0aWwvc3RhdGVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCBaUkltYWdlIGZyb20gJ3pyZW5kZXIvbGliL2dyYXBoaWMvSW1hZ2UuanMnO1xuaW1wb3J0IHsgZ2V0RUNEYXRhIH0gZnJvbSAnLi4vLi4vdXRpbC9pbm5lclN0b3JlLmpzJztcbmltcG9ydCB7IGNyZWF0ZVRleHRTdHlsZSB9IGZyb20gJy4uLy4uL2xhYmVsL2xhYmVsU3R5bGUuanMnO1xuaW1wb3J0IHsgZmluZEV2ZW50RGlzcGF0Y2hlciB9IGZyb20gJy4uLy4uL3V0aWwvZXZlbnQuanMnO1xudmFyIGxpbmVhck1hcCA9IG51bWJlclV0aWwubGluZWFyTWFwO1xudmFyIGVhY2ggPSB6clV0aWwuZWFjaDtcbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuLy8gQXJiaXRyYXJ5IHZhbHVlXG52YXIgSE9WRVJfTElOS19TSVpFID0gMTI7XG52YXIgSE9WRVJfTElOS19PVVQgPSA2O1xuLy8gTm90aWNlOlxuLy8gQW55IFwiaW50ZXJ2YWxcIiBzaG91bGQgYmUgYnkgdGhlIG9yZGVyIG9mIFtsb3csIGhpZ2hdLlxuLy8gXCJoYW5kbGUwXCIgKGhhbmRsZUluZGV4ID09PSAwKSBtYXBzIHRvXG4vLyBsb3cgZGF0YSB2YWx1ZTogdGhpcy5fZGF0YUludGVydmFsWzBdIGFuZCBoYXMgbG93IGNvb3JkLlxuLy8gXCJoYW5kbGUxXCIgKGhhbmRsZUluZGV4ID09PSAxKSBtYXBzIHRvXG4vLyBoaWdoIGRhdGEgdmFsdWU6IHRoaXMuX2RhdGFJbnRlcnZhbFsxXSBhbmQgaGFzIGhpZ2ggY29vcmQuXG4vLyBUaGUgbG9naWMgb2YgdHJhbnNmb3JtIGlzIGltcGxlbWVudGVkIGluIHRoaXMuX2NyZWF0ZUJhckdyb3VwLlxudmFyIENvbnRpbnVvdXNWaWV3ID0gLyoqIEBjbGFzcyAqL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKENvbnRpbnVvdXNWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBDb250aW51b3VzVmlldygpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICBfdGhpcy50eXBlID0gQ29udGludW91c1ZpZXcudHlwZTtcbiAgICBfdGhpcy5fc2hhcGVzID0ge307XG4gICAgX3RoaXMuX2RhdGFJbnRlcnZhbCA9IFtdO1xuICAgIF90aGlzLl9oYW5kbGVFbmRzID0gW107XG4gICAgX3RoaXMuX2hvdmVyTGlua0RhdGFJbmRpY2VzID0gW107XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVjTW9kZWwsIGFwaSkge1xuICAgIF9zdXBlci5wcm90b3R5cGUuaW5pdC5jYWxsKHRoaXMsIGVjTW9kZWwsIGFwaSk7XG4gICAgdGhpcy5faG92ZXJMaW5rRnJvbVNlcmllc01vdXNlT3ZlciA9IHpyVXRpbC5iaW5kKHRoaXMuX2hvdmVyTGlua0Zyb21TZXJpZXNNb3VzZU92ZXIsIHRoaXMpO1xuICAgIHRoaXMuX2hpZGVJbmRpY2F0b3IgPSB6clV0aWwuYmluZCh0aGlzLl9oaWRlSW5kaWNhdG9yLCB0aGlzKTtcbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLmRvUmVuZGVyID0gZnVuY3Rpb24gKHZpc3VhbE1hcE1vZGVsLCBlY01vZGVsLCBhcGksIHBheWxvYWQpIHtcbiAgICBpZiAoIXBheWxvYWQgfHwgcGF5bG9hZC50eXBlICE9PSAnc2VsZWN0RGF0YVJhbmdlJyB8fCBwYXlsb2FkLmZyb20gIT09IHRoaXMudWlkKSB7XG4gICAgICB0aGlzLl9idWlsZFZpZXcoKTtcbiAgICB9XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fYnVpbGRWaWV3ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZ3JvdXAucmVtb3ZlQWxsKCk7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgdGhpc0dyb3VwID0gdGhpcy5ncm91cDtcbiAgICB0aGlzLl9vcmllbnQgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIHRoaXMuX3VzZUhhbmRsZSA9IHZpc3VhbE1hcE1vZGVsLmdldCgnY2FsY3VsYWJsZScpO1xuICAgIHRoaXMuX3Jlc2V0SW50ZXJ2YWwoKTtcbiAgICB0aGlzLl9yZW5kZXJCYXIodGhpc0dyb3VwKTtcbiAgICB2YXIgZGF0YVJhbmdlVGV4dCA9IHZpc3VhbE1hcE1vZGVsLmdldCgndGV4dCcpO1xuICAgIHRoaXMuX3JlbmRlckVuZHNUZXh0KHRoaXNHcm91cCwgZGF0YVJhbmdlVGV4dCwgMCk7XG4gICAgdGhpcy5fcmVuZGVyRW5kc1RleHQodGhpc0dyb3VwLCBkYXRhUmFuZ2VUZXh0LCAxKTtcbiAgICAvLyBEbyB0aGlzIGZvciBiYWNrZ3JvdW5kIHNpemUgY2FsY3VsYXRpb24uXG4gICAgdGhpcy5fdXBkYXRlVmlldyh0cnVlKTtcbiAgICAvLyBBZnRlciB1cGRhdGluZyB2aWV3LCBpbm5lciBzaGFwZXMgaXMgYnVpbHQgY29tcGxldGVseSxcbiAgICAvLyBhbmQgdGhlbiBiYWNrZ3JvdW5kIGNhbiBiZSByZW5kZXJlZC5cbiAgICB0aGlzLnJlbmRlckJhY2tncm91bmQodGhpc0dyb3VwKTtcbiAgICAvLyBSZWFsIHVwZGF0ZSB2aWV3XG4gICAgdGhpcy5fdXBkYXRlVmlldygpO1xuICAgIHRoaXMuX2VuYWJsZUhvdmVyTGlua1RvU2VyaWVzKCk7XG4gICAgdGhpcy5fZW5hYmxlSG92ZXJMaW5rRnJvbVNlcmllcygpO1xuICAgIHRoaXMucG9zaXRpb25Hcm91cCh0aGlzR3JvdXApO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3JlbmRlckVuZHNUZXh0ID0gZnVuY3Rpb24gKGdyb3VwLCBkYXRhUmFuZ2VUZXh0LCBlbmRzSW5kZXgpIHtcbiAgICBpZiAoIWRhdGFSYW5nZVRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ29tcGF0aWJsZSB3aXRoIGVjMiwgdGV4dFswXSBtYXAgdG8gaGlnaCB2YWx1ZSwgdGV4dFsxXSBtYXAgbG93IHZhbHVlLlxuICAgIHZhciB0ZXh0ID0gZGF0YVJhbmdlVGV4dFsxIC0gZW5kc0luZGV4XTtcbiAgICB0ZXh0ID0gdGV4dCAhPSBudWxsID8gdGV4dCArICcnIDogJyc7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgdGV4dEdhcCA9IHZpc3VhbE1hcE1vZGVsLmdldCgndGV4dEdhcCcpO1xuICAgIHZhciBpdGVtU2l6ZSA9IHZpc3VhbE1hcE1vZGVsLml0ZW1TaXplO1xuICAgIHZhciBiYXJHcm91cCA9IHRoaXMuX3NoYXBlcy5tYWluR3JvdXA7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fYXBwbHlUcmFuc2Zvcm0oW2l0ZW1TaXplWzBdIC8gMiwgZW5kc0luZGV4ID09PSAwID8gLXRleHRHYXAgOiBpdGVtU2l6ZVsxXSArIHRleHRHYXBdLCBiYXJHcm91cCk7XG4gICAgdmFyIGFsaWduID0gdGhpcy5fYXBwbHlUcmFuc2Zvcm0oZW5kc0luZGV4ID09PSAwID8gJ2JvdHRvbScgOiAndG9wJywgYmFyR3JvdXApO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICB0aGlzLmdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgeDogcG9zaXRpb25bMF0sXG4gICAgICAgIHk6IHBvc2l0aW9uWzFdLFxuICAgICAgICB2ZXJ0aWNhbEFsaWduOiBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICdtaWRkbGUnIDogYWxpZ24sXG4gICAgICAgIGFsaWduOiBvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IGFsaWduIDogJ2NlbnRlcicsXG4gICAgICAgIHRleHQ6IHRleHRcbiAgICAgIH0pXG4gICAgfSkpO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX3JlbmRlckJhciA9IGZ1bmN0aW9uICh0YXJnZXRHcm91cCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgb3JpZW50ID0gdGhpcy5fb3JpZW50O1xuICAgIHZhciB1c2VIYW5kbGUgPSB0aGlzLl91c2VIYW5kbGU7XG4gICAgdmFyIGl0ZW1BbGlnbiA9IGhlbHBlci5nZXRJdGVtQWxpZ24odmlzdWFsTWFwTW9kZWwsIHRoaXMuYXBpLCBpdGVtU2l6ZSk7XG4gICAgdmFyIG1haW5Hcm91cCA9IHNoYXBlcy5tYWluR3JvdXAgPSB0aGlzLl9jcmVhdGVCYXJHcm91cChpdGVtQWxpZ24pO1xuICAgIHZhciBncmFkaWVudEJhckdyb3VwID0gbmV3IGdyYXBoaWMuR3JvdXAoKTtcbiAgICBtYWluR3JvdXAuYWRkKGdyYWRpZW50QmFyR3JvdXApO1xuICAgIC8vIEJhclxuICAgIGdyYWRpZW50QmFyR3JvdXAuYWRkKHNoYXBlcy5vdXRPZlJhbmdlID0gY3JlYXRlUG9seWdvbigpKTtcbiAgICBncmFkaWVudEJhckdyb3VwLmFkZChzaGFwZXMuaW5SYW5nZSA9IGNyZWF0ZVBvbHlnb24obnVsbCwgdXNlSGFuZGxlID8gZ2V0Q3Vyc29yKHRoaXMuX29yaWVudCkgOiBudWxsLCB6clV0aWwuYmluZCh0aGlzLl9kcmFnSGFuZGxlLCB0aGlzLCAnYWxsJywgZmFsc2UpLCB6clV0aWwuYmluZCh0aGlzLl9kcmFnSGFuZGxlLCB0aGlzLCAnYWxsJywgdHJ1ZSkpKTtcbiAgICAvLyBBIGJvcmRlciByYWRpdXMgY2xpcC5cbiAgICBncmFkaWVudEJhckdyb3VwLnNldENsaXBQYXRoKG5ldyBncmFwaGljLlJlY3Qoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IGl0ZW1TaXplWzBdLFxuICAgICAgICBoZWlnaHQ6IGl0ZW1TaXplWzFdLFxuICAgICAgICByOiAzXG4gICAgICB9XG4gICAgfSkpO1xuICAgIHZhciB0ZXh0UmVjdCA9IHZpc3VhbE1hcE1vZGVsLnRleHRTdHlsZU1vZGVsLmdldFRleHRSZWN0KCflm70nKTtcbiAgICB2YXIgdGV4dFNpemUgPSBtYXRoTWF4KHRleHRSZWN0LndpZHRoLCB0ZXh0UmVjdC5oZWlnaHQpO1xuICAgIC8vIEhhbmRsZVxuICAgIGlmICh1c2VIYW5kbGUpIHtcbiAgICAgIHNoYXBlcy5oYW5kbGVUaHVtYnMgPSBbXTtcbiAgICAgIHNoYXBlcy5oYW5kbGVMYWJlbHMgPSBbXTtcbiAgICAgIHNoYXBlcy5oYW5kbGVMYWJlbFBvaW50cyA9IFtdO1xuICAgICAgdGhpcy5fY3JlYXRlSGFuZGxlKHZpc3VhbE1hcE1vZGVsLCBtYWluR3JvdXAsIDAsIGl0ZW1TaXplLCB0ZXh0U2l6ZSwgb3JpZW50KTtcbiAgICAgIHRoaXMuX2NyZWF0ZUhhbmRsZSh2aXN1YWxNYXBNb2RlbCwgbWFpbkdyb3VwLCAxLCBpdGVtU2l6ZSwgdGV4dFNpemUsIG9yaWVudCk7XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZUluZGljYXRvcih2aXN1YWxNYXBNb2RlbCwgbWFpbkdyb3VwLCBpdGVtU2l6ZSwgdGV4dFNpemUsIG9yaWVudCk7XG4gICAgdGFyZ2V0R3JvdXAuYWRkKG1haW5Hcm91cCk7XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fY3JlYXRlSGFuZGxlID0gZnVuY3Rpb24gKHZpc3VhbE1hcE1vZGVsLCBtYWluR3JvdXAsIGhhbmRsZUluZGV4LCBpdGVtU2l6ZSwgdGV4dFNpemUsIG9yaWVudCkge1xuICAgIHZhciBvbkRyaWZ0ID0genJVdGlsLmJpbmQodGhpcy5fZHJhZ0hhbmRsZSwgdGhpcywgaGFuZGxlSW5kZXgsIGZhbHNlKTtcbiAgICB2YXIgb25EcmFnRW5kID0genJVdGlsLmJpbmQodGhpcy5fZHJhZ0hhbmRsZSwgdGhpcywgaGFuZGxlSW5kZXgsIHRydWUpO1xuICAgIHZhciBoYW5kbGVTaXplID0gcGFyc2VQZXJjZW50KHZpc3VhbE1hcE1vZGVsLmdldCgnaGFuZGxlU2l6ZScpLCBpdGVtU2l6ZVswXSk7XG4gICAgdmFyIGhhbmRsZVRodW1iID0gY3JlYXRlU3ltYm9sKHZpc3VhbE1hcE1vZGVsLmdldCgnaGFuZGxlSWNvbicpLCAtaGFuZGxlU2l6ZSAvIDIsIC1oYW5kbGVTaXplIC8gMiwgaGFuZGxlU2l6ZSwgaGFuZGxlU2l6ZSwgbnVsbCwgdHJ1ZSk7XG4gICAgdmFyIGN1cnNvciA9IGdldEN1cnNvcih0aGlzLl9vcmllbnQpO1xuICAgIGhhbmRsZVRodW1iLmF0dHIoe1xuICAgICAgY3Vyc29yOiBjdXJzb3IsXG4gICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICBkcmlmdDogb25EcmlmdCxcbiAgICAgIG9uZHJhZ2VuZDogb25EcmFnRW5kLFxuICAgICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGhhbmRsZVRodW1iLnggPSBpdGVtU2l6ZVswXSAvIDI7XG4gICAgaGFuZGxlVGh1bWIudXNlU3R5bGUodmlzdWFsTWFwTW9kZWwuZ2V0TW9kZWwoJ2hhbmRsZVN0eWxlJykuZ2V0SXRlbVN0eWxlKCkpO1xuICAgIGhhbmRsZVRodW1iLnNldFN0eWxlKHtcbiAgICAgIHN0cm9rZU5vU2NhbGU6IHRydWUsXG4gICAgICBzdHJva2VGaXJzdDogdHJ1ZVxuICAgIH0pO1xuICAgIGhhbmRsZVRodW1iLnN0eWxlLmxpbmVXaWR0aCAqPSAyO1xuICAgIGhhbmRsZVRodW1iLmVuc3VyZVN0YXRlKCdlbXBoYXNpcycpLnN0eWxlID0gdmlzdWFsTWFwTW9kZWwuZ2V0TW9kZWwoWydlbXBoYXNpcycsICdoYW5kbGVTdHlsZSddKS5nZXRJdGVtU3R5bGUoKTtcbiAgICBzZXRBc0hpZ2hEb3duRGlzcGF0Y2hlcihoYW5kbGVUaHVtYiwgdHJ1ZSk7XG4gICAgbWFpbkdyb3VwLmFkZChoYW5kbGVUaHVtYik7XG4gICAgLy8gVGV4dCBpcyBhbHdheXMgaG9yaXpvbnRhbCBsYXlvdXQgYnV0IHNob3VsZCBub3QgYmUgZWZmZWN0ZWQgYnlcbiAgICAvLyB0cmFuc2Zvcm0gKG9yaWVudC9pbnZlcnNlKS4gU28gbGFiZWwgaXMgYnVpbHQgc2VwYXJhdGVseSBidXQgbm90XG4gICAgLy8gdXNlIHpyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvUmVjdFRleHQsIGFuZCBpcyBsb2NhdGVkIGJhc2VkIG9uIHZpZXdcbiAgICAvLyBncm91cCAoYWNjb3JkaW5nIHRvIGhhbmRsZUxhYmVsUG9pbnQpIGJ1dCBub3QgYmFyR3JvdXAuXG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICB2YXIgaGFuZGxlTGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIGN1cnNvcjogY3Vyc29yLFxuICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgZHJpZnQ6IG9uRHJpZnQsXG4gICAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgLy8gRm9yIG1vYmlsZSBkZXZpY2UsIHByZXZlbnQgc2NyZWVuIHNsaWRlciBvbiB0aGUgYnV0dG9uLlxuICAgICAgICBldmVudFRvb2wuc3RvcChlLmV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBvbmRyYWdlbmQ6IG9uRHJhZ0VuZCxcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgaGFuZGxlTGFiZWwuZW5zdXJlU3RhdGUoJ2JsdXInKS5zdHlsZSA9IHtcbiAgICAgIG9wYWNpdHk6IDAuMVxuICAgIH07XG4gICAgaGFuZGxlTGFiZWwuc3RhdGVUcmFuc2l0aW9uID0ge1xuICAgICAgZHVyYXRpb246IDIwMFxuICAgIH07XG4gICAgdGhpcy5ncm91cC5hZGQoaGFuZGxlTGFiZWwpO1xuICAgIHZhciBoYW5kbGVMYWJlbFBvaW50ID0gW2hhbmRsZVNpemUsIDBdO1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXM7XG4gICAgc2hhcGVzLmhhbmRsZVRodW1ic1toYW5kbGVJbmRleF0gPSBoYW5kbGVUaHVtYjtcbiAgICBzaGFwZXMuaGFuZGxlTGFiZWxQb2ludHNbaGFuZGxlSW5kZXhdID0gaGFuZGxlTGFiZWxQb2ludDtcbiAgICBzaGFwZXMuaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XSA9IGhhbmRsZUxhYmVsO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NyZWF0ZUluZGljYXRvciA9IGZ1bmN0aW9uICh2aXN1YWxNYXBNb2RlbCwgbWFpbkdyb3VwLCBpdGVtU2l6ZSwgdGV4dFNpemUsIG9yaWVudCkge1xuICAgIHZhciBzY2FsZSA9IHBhcnNlUGVyY2VudCh2aXN1YWxNYXBNb2RlbC5nZXQoJ2luZGljYXRvclNpemUnKSwgaXRlbVNpemVbMF0pO1xuICAgIHZhciBpbmRpY2F0b3IgPSBjcmVhdGVTeW1ib2wodmlzdWFsTWFwTW9kZWwuZ2V0KCdpbmRpY2F0b3JJY29uJyksIC1zY2FsZSAvIDIsIC1zY2FsZSAvIDIsIHNjYWxlLCBzY2FsZSwgbnVsbCwgdHJ1ZSk7XG4gICAgaW5kaWNhdG9yLmF0dHIoe1xuICAgICAgY3Vyc29yOiAnbW92ZScsXG4gICAgICBpbnZpc2libGU6IHRydWUsXG4gICAgICBzaWxlbnQ6IHRydWUsXG4gICAgICB4OiBpdGVtU2l6ZVswXSAvIDJcbiAgICB9KTtcbiAgICB2YXIgaW5kaWNhdG9yU3R5bGUgPSB2aXN1YWxNYXBNb2RlbC5nZXRNb2RlbCgnaW5kaWNhdG9yU3R5bGUnKS5nZXRJdGVtU3R5bGUoKTtcbiAgICBpZiAoaW5kaWNhdG9yIGluc3RhbmNlb2YgWlJJbWFnZSkge1xuICAgICAgdmFyIHBhdGhTdHlsZSA9IGluZGljYXRvci5zdHlsZTtcbiAgICAgIGluZGljYXRvci51c2VTdHlsZSh6clV0aWwuZXh0ZW5kKHtcbiAgICAgICAgLy8gVE9ETyBvdGhlciBwcm9wZXJ0aWVzIGxpa2UgeCwgeSA/XG4gICAgICAgIGltYWdlOiBwYXRoU3R5bGUuaW1hZ2UsXG4gICAgICAgIHg6IHBhdGhTdHlsZS54LFxuICAgICAgICB5OiBwYXRoU3R5bGUueSxcbiAgICAgICAgd2lkdGg6IHBhdGhTdHlsZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBwYXRoU3R5bGUuaGVpZ2h0XG4gICAgICB9LCBpbmRpY2F0b3JTdHlsZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRpY2F0b3IudXNlU3R5bGUoaW5kaWNhdG9yU3R5bGUpO1xuICAgIH1cbiAgICBtYWluR3JvdXAuYWRkKGluZGljYXRvcik7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICB2YXIgaW5kaWNhdG9yTGFiZWwgPSBuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgIHNpbGVudDogdHJ1ZSxcbiAgICAgIGludmlzaWJsZTogdHJ1ZSxcbiAgICAgIHN0eWxlOiBjcmVhdGVUZXh0U3R5bGUodGV4dFN0eWxlTW9kZWwsIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgdGV4dDogJydcbiAgICAgIH0pXG4gICAgfSk7XG4gICAgdGhpcy5ncm91cC5hZGQoaW5kaWNhdG9yTGFiZWwpO1xuICAgIHZhciBpbmRpY2F0b3JMYWJlbFBvaW50ID0gWyhvcmllbnQgPT09ICdob3Jpem9udGFsJyA/IHRleHRTaXplIC8gMiA6IEhPVkVSX0xJTktfT1VUKSArIGl0ZW1TaXplWzBdIC8gMiwgMF07XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICBzaGFwZXMuaW5kaWNhdG9yID0gaW5kaWNhdG9yO1xuICAgIHNoYXBlcy5pbmRpY2F0b3JMYWJlbCA9IGluZGljYXRvckxhYmVsO1xuICAgIHNoYXBlcy5pbmRpY2F0b3JMYWJlbFBvaW50ID0gaW5kaWNhdG9yTGFiZWxQb2ludDtcbiAgICB0aGlzLl9maXJzdFNob3dJbmRpY2F0b3IgPSB0cnVlO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2RyYWdIYW5kbGUgPSBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGlzRW5kLFxuICAvLyBkeCBpcyBldmVudCBmcm9tIG9uZHJhZ2VuZCBpZiBpc0VuZCBpcyB0cnVlLiBJdCdzIG5vdCB1c2VkXG4gIGR4LCBkeSkge1xuICAgIGlmICghdGhpcy5fdXNlSGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2RyYWdnaW5nID0gIWlzRW5kO1xuICAgIGlmICghaXNFbmQpIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBkeCwgZHkgdG8gYmFyIGNvb3JkaW5hdGlvbi5cbiAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLl9hcHBseVRyYW5zZm9ybShbZHgsIGR5XSwgdGhpcy5fc2hhcGVzLm1haW5Hcm91cCwgdHJ1ZSk7XG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbChoYW5kbGVJbmRleCwgdmVydGV4WzFdKTtcbiAgICAgIHRoaXMuX2hpZGVJbmRpY2F0b3IoKTtcbiAgICAgIC8vIENvbnNpZGVyaW5nIHJlYWx0aW1lLCB1cGRhdGUgdmlldyBzaG91bGQgYmUgZXhlY3V0ZWRcbiAgICAgIC8vIGJlZm9yZSBkaXNwYXRjaCBhY3Rpb24uXG4gICAgICB0aGlzLl91cGRhdGVWaWV3KCk7XG4gICAgfVxuICAgIC8vIGRyYWdFbmQgZG8gbm90IGRpc3BhdGNoIGFjdGlvbiB3aGVuIHJlYWx0aW1lLlxuICAgIGlmIChpc0VuZCA9PT0gIXRoaXMudmlzdWFsTWFwTW9kZWwuZ2V0KCdyZWFsdGltZScpKSB7XG4gICAgICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogJ3NlbGVjdERhdGFSYW5nZScsXG4gICAgICAgIGZyb206IHRoaXMudWlkLFxuICAgICAgICB2aXN1YWxNYXBJZDogdGhpcy52aXN1YWxNYXBNb2RlbC5pZCxcbiAgICAgICAgc2VsZWN0ZWQ6IHRoaXMuX2RhdGFJbnRlcnZhbC5zbGljZSgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlzRW5kKSB7XG4gICAgICAhdGhpcy5faG92ZXJpbmcgJiYgdGhpcy5fY2xlYXJIb3ZlckxpbmtUb1NlcmllcygpO1xuICAgIH0gZWxzZSBpZiAodXNlSG92ZXJMaW5rT25IYW5kbGUodGhpcy52aXN1YWxNYXBNb2RlbCkpIHtcbiAgICAgIHRoaXMuX2RvSG92ZXJMaW5rVG9TZXJpZXModGhpcy5faGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIGZhbHNlKTtcbiAgICB9XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fcmVzZXRJbnRlcnZhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBkYXRhSW50ZXJ2YWwgPSB0aGlzLl9kYXRhSW50ZXJ2YWwgPSB2aXN1YWxNYXBNb2RlbC5nZXRTZWxlY3RlZCgpO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHNpemVFeHRlbnQgPSBbMCwgdmlzdWFsTWFwTW9kZWwuaXRlbVNpemVbMV1dO1xuICAgIHRoaXMuX2hhbmRsZUVuZHMgPSBbbGluZWFyTWFwKGRhdGFJbnRlcnZhbFswXSwgZGF0YUV4dGVudCwgc2l6ZUV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChkYXRhSW50ZXJ2YWxbMV0sIGRhdGFFeHRlbnQsIHNpemVFeHRlbnQsIHRydWUpXTtcbiAgfTtcbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gaGFuZGxlSW5kZXggMCBvciAxIG9yICdhbGwnXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR5XHJcbiAgICovXG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlSW50ZXJ2YWwgPSBmdW5jdGlvbiAoaGFuZGxlSW5kZXgsIGRlbHRhKSB7XG4gICAgZGVsdGEgPSBkZWx0YSB8fCAwO1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIGhhbmRsZUVuZHMgPSB0aGlzLl9oYW5kbGVFbmRzO1xuICAgIHZhciBzaXplRXh0ZW50ID0gWzAsIHZpc3VhbE1hcE1vZGVsLml0ZW1TaXplWzFdXTtcbiAgICBzbGlkZXJNb3ZlKGRlbHRhLCBoYW5kbGVFbmRzLCBzaXplRXh0ZW50LCBoYW5kbGVJbmRleCxcbiAgICAvLyBjcm9zcyBpcyBmb3JiaWRkZW5cbiAgICAwKTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIC8vIFVwZGF0ZSBkYXRhIGludGVydmFsLlxuICAgIHRoaXMuX2RhdGFJbnRlcnZhbCA9IFtsaW5lYXJNYXAoaGFuZGxlRW5kc1swXSwgc2l6ZUV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSksIGxpbmVhck1hcChoYW5kbGVFbmRzWzFdLCBzaXplRXh0ZW50LCBkYXRhRXh0ZW50LCB0cnVlKV07XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fdXBkYXRlVmlldyA9IGZ1bmN0aW9uIChmb3JTa2V0Y2gpIHtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdmlzdWFsTWFwTW9kZWwuZ2V0RXh0ZW50KCk7XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICB2YXIgb3V0T2ZSYW5nZUhhbmRsZUVuZHMgPSBbMCwgdmlzdWFsTWFwTW9kZWwuaXRlbVNpemVbMV1dO1xuICAgIHZhciBpblJhbmdlSGFuZGxlRW5kcyA9IGZvclNrZXRjaCA/IG91dE9mUmFuZ2VIYW5kbGVFbmRzIDogdGhpcy5faGFuZGxlRW5kcztcbiAgICB2YXIgdmlzdWFsSW5SYW5nZSA9IHRoaXMuX2NyZWF0ZUJhclZpc3VhbCh0aGlzLl9kYXRhSW50ZXJ2YWwsIGRhdGFFeHRlbnQsIGluUmFuZ2VIYW5kbGVFbmRzLCAnaW5SYW5nZScpO1xuICAgIHZhciB2aXN1YWxPdXRPZlJhbmdlID0gdGhpcy5fY3JlYXRlQmFyVmlzdWFsKGRhdGFFeHRlbnQsIGRhdGFFeHRlbnQsIG91dE9mUmFuZ2VIYW5kbGVFbmRzLCAnb3V0T2ZSYW5nZScpO1xuICAgIHNoYXBlcy5pblJhbmdlLnNldFN0eWxlKHtcbiAgICAgIGZpbGw6IHZpc3VhbEluUmFuZ2UuYmFyQ29sb3JcbiAgICAgIC8vIG9wYWNpdHk6IHZpc3VhbEluUmFuZ2Uub3BhY2l0eVxuICAgIH0pLnNldFNoYXBlKCdwb2ludHMnLCB2aXN1YWxJblJhbmdlLmJhclBvaW50cyk7XG4gICAgc2hhcGVzLm91dE9mUmFuZ2Uuc2V0U3R5bGUoe1xuICAgICAgZmlsbDogdmlzdWFsT3V0T2ZSYW5nZS5iYXJDb2xvclxuICAgICAgLy8gb3BhY2l0eTogdmlzdWFsT3V0T2ZSYW5nZS5vcGFjaXR5XG4gICAgfSkuc2V0U2hhcGUoJ3BvaW50cycsIHZpc3VhbE91dE9mUmFuZ2UuYmFyUG9pbnRzKTtcbiAgICB0aGlzLl91cGRhdGVIYW5kbGUoaW5SYW5nZUhhbmRsZUVuZHMsIHZpc3VhbEluUmFuZ2UpO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NyZWF0ZUJhclZpc3VhbCA9IGZ1bmN0aW9uIChkYXRhSW50ZXJ2YWwsIGRhdGFFeHRlbnQsIGhhbmRsZUVuZHMsIGZvcmNlU3RhdGUpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGZvcmNlU3RhdGU6IGZvcmNlU3RhdGUsXG4gICAgICBjb252ZXJ0T3BhY2l0eVRvQWxwaGE6IHRydWVcbiAgICB9O1xuICAgIHZhciBjb2xvclN0b3BzID0gdGhpcy5fbWFrZUNvbG9yR3JhZGllbnQoZGF0YUludGVydmFsLCBvcHRzKTtcbiAgICB2YXIgc3ltYm9sU2l6ZXMgPSBbdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGRhdGFJbnRlcnZhbFswXSwgJ3N5bWJvbFNpemUnLCBvcHRzKSwgdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGRhdGFJbnRlcnZhbFsxXSwgJ3N5bWJvbFNpemUnLCBvcHRzKV07XG4gICAgdmFyIGJhclBvaW50cyA9IHRoaXMuX2NyZWF0ZUJhclBvaW50cyhoYW5kbGVFbmRzLCBzeW1ib2xTaXplcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJhckNvbG9yOiBuZXcgTGluZWFyR3JhZGllbnQoMCwgMCwgMCwgMSwgY29sb3JTdG9wcyksXG4gICAgICBiYXJQb2ludHM6IGJhclBvaW50cyxcbiAgICAgIGhhbmRsZXNDb2xvcjogW2NvbG9yU3RvcHNbMF0uY29sb3IsIGNvbG9yU3RvcHNbY29sb3JTdG9wcy5sZW5ndGggLSAxXS5jb2xvcl1cbiAgICB9O1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX21ha2VDb2xvckdyYWRpZW50ID0gZnVuY3Rpb24gKGRhdGFJbnRlcnZhbCwgb3B0cykge1xuICAgIC8vIENvbnNpZGVyaW5nIGNvbG9ySHVlLCB3aGljaCBpcyBub3QgbGluZWFyLCBzbyB3ZSBoYXZlIHRvIHNhbXBsZVxuICAgIC8vIHRvIGNhbGN1bGF0ZSBncmFkaWVudCBjb2xvciBzdG9wcywgYnV0IG5vdCBvbmx5IGNhbGN1bGF0ZSBoZWFkXG4gICAgLy8gYW5kIHRhaWwuXG4gICAgdmFyIHNhbXBsZU51bWJlciA9IDEwMDsgLy8gQXJiaXRyYXJ5IHZhbHVlLlxuICAgIHZhciBjb2xvclN0b3BzID0gW107XG4gICAgdmFyIHN0ZXAgPSAoZGF0YUludGVydmFsWzFdIC0gZGF0YUludGVydmFsWzBdKSAvIHNhbXBsZU51bWJlcjtcbiAgICBjb2xvclN0b3BzLnB1c2goe1xuICAgICAgY29sb3I6IHRoaXMuZ2V0Q29udHJvbGxlclZpc3VhbChkYXRhSW50ZXJ2YWxbMF0sICdjb2xvcicsIG9wdHMpLFxuICAgICAgb2Zmc2V0OiAwXG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzYW1wbGVOdW1iZXI7IGkrKykge1xuICAgICAgdmFyIGN1cnJWYWx1ZSA9IGRhdGFJbnRlcnZhbFswXSArIHN0ZXAgKiBpO1xuICAgICAgaWYgKGN1cnJWYWx1ZSA+IGRhdGFJbnRlcnZhbFsxXSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbG9yU3RvcHMucHVzaCh7XG4gICAgICAgIGNvbG9yOiB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwoY3VyclZhbHVlLCAnY29sb3InLCBvcHRzKSxcbiAgICAgICAgb2Zmc2V0OiBpIC8gc2FtcGxlTnVtYmVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29sb3JTdG9wcy5wdXNoKHtcbiAgICAgIGNvbG9yOiB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwoZGF0YUludGVydmFsWzFdLCAnY29sb3InLCBvcHRzKSxcbiAgICAgIG9mZnNldDogMVxuICAgIH0pO1xuICAgIHJldHVybiBjb2xvclN0b3BzO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NyZWF0ZUJhclBvaW50cyA9IGZ1bmN0aW9uIChoYW5kbGVFbmRzLCBzeW1ib2xTaXplcykge1xuICAgIHZhciBpdGVtU2l6ZSA9IHRoaXMudmlzdWFsTWFwTW9kZWwuaXRlbVNpemU7XG4gICAgcmV0dXJuIFtbaXRlbVNpemVbMF0gLSBzeW1ib2xTaXplc1swXSwgaGFuZGxlRW5kc1swXV0sIFtpdGVtU2l6ZVswXSwgaGFuZGxlRW5kc1swXV0sIFtpdGVtU2l6ZVswXSwgaGFuZGxlRW5kc1sxXV0sIFtpdGVtU2l6ZVswXSAtIHN5bWJvbFNpemVzWzFdLCBoYW5kbGVFbmRzWzFdXV07XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fY3JlYXRlQmFyR3JvdXAgPSBmdW5jdGlvbiAoaXRlbUFsaWduKSB7XG4gICAgdmFyIG9yaWVudCA9IHRoaXMuX29yaWVudDtcbiAgICB2YXIgaW52ZXJzZSA9IHRoaXMudmlzdWFsTWFwTW9kZWwuZ2V0KCdpbnZlcnNlJyk7XG4gICAgcmV0dXJuIG5ldyBncmFwaGljLkdyb3VwKG9yaWVudCA9PT0gJ2hvcml6b250YWwnICYmICFpbnZlcnNlID8ge1xuICAgICAgc2NhbGVYOiBpdGVtQWxpZ24gPT09ICdib3R0b20nID8gMSA6IC0xLFxuICAgICAgcm90YXRpb246IE1hdGguUEkgLyAyXG4gICAgfSA6IG9yaWVudCA9PT0gJ2hvcml6b250YWwnICYmIGludmVyc2UgPyB7XG4gICAgICBzY2FsZVg6IGl0ZW1BbGlnbiA9PT0gJ2JvdHRvbScgPyAtMSA6IDEsXG4gICAgICByb3RhdGlvbjogLU1hdGguUEkgLyAyXG4gICAgfSA6IG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyAmJiAhaW52ZXJzZSA/IHtcbiAgICAgIHNjYWxlWDogaXRlbUFsaWduID09PSAnbGVmdCcgPyAxIDogLTEsXG4gICAgICBzY2FsZVk6IC0xXG4gICAgfSA6IHtcbiAgICAgIHNjYWxlWDogaXRlbUFsaWduID09PSAnbGVmdCcgPyAxIDogLTFcbiAgICB9KTtcbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl91cGRhdGVIYW5kbGUgPSBmdW5jdGlvbiAoaGFuZGxlRW5kcywgdmlzdWFsSW5SYW5nZSkge1xuICAgIGlmICghdGhpcy5fdXNlSGFuZGxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXM7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgaGFuZGxlVGh1bWJzID0gc2hhcGVzLmhhbmRsZVRodW1icztcbiAgICB2YXIgaGFuZGxlTGFiZWxzID0gc2hhcGVzLmhhbmRsZUxhYmVscztcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIHZhciBhbGlnbiA9IHRoaXMuX2FwcGx5VHJhbnNmb3JtKCdsZWZ0Jywgc2hhcGVzLm1haW5Hcm91cCk7XG4gICAgZWFjaChbMCwgMV0sIGZ1bmN0aW9uIChoYW5kbGVJbmRleCkge1xuICAgICAgdmFyIGhhbmRsZVRodW1iID0gaGFuZGxlVGh1bWJzW2hhbmRsZUluZGV4XTtcbiAgICAgIGhhbmRsZVRodW1iLnNldFN0eWxlKCdmaWxsJywgdmlzdWFsSW5SYW5nZS5oYW5kbGVzQ29sb3JbaGFuZGxlSW5kZXhdKTtcbiAgICAgIGhhbmRsZVRodW1iLnkgPSBoYW5kbGVFbmRzW2hhbmRsZUluZGV4XTtcbiAgICAgIHZhciB2YWwgPSBsaW5lYXJNYXAoaGFuZGxlRW5kc1toYW5kbGVJbmRleF0sIFswLCBpdGVtU2l6ZVsxXV0sIGRhdGFFeHRlbnQsIHRydWUpO1xuICAgICAgdmFyIHN5bWJvbFNpemUgPSB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwodmFsLCAnc3ltYm9sU2l6ZScpO1xuICAgICAgaGFuZGxlVGh1bWIuc2NhbGVYID0gaGFuZGxlVGh1bWIuc2NhbGVZID0gc3ltYm9sU2l6ZSAvIGl0ZW1TaXplWzBdO1xuICAgICAgaGFuZGxlVGh1bWIueCA9IGl0ZW1TaXplWzBdIC0gc3ltYm9sU2l6ZSAvIDI7XG4gICAgICAvLyBVcGRhdGUgaGFuZGxlIGxhYmVsIHBvc2l0aW9uLlxuICAgICAgdmFyIHRleHRQb2ludCA9IGdyYXBoaWMuYXBwbHlUcmFuc2Zvcm0oc2hhcGVzLmhhbmRsZUxhYmVsUG9pbnRzW2hhbmRsZUluZGV4XSwgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oaGFuZGxlVGh1bWIsIHRoaXMuZ3JvdXApKTtcbiAgICAgIGlmICh0aGlzLl9vcmllbnQgPT09ICdob3Jpem9udGFsJykge1xuICAgICAgICAvLyBJZiB2aXN1YWxNYXAgY29udHJvbHMgc3ltYm9sIHNpemUsIGFuIGFkZGl0aW9uYWwgb2Zmc2V0IG5lZWRzIHRvIGJlIGFkZGVkIHRvIGxhYmVscyB0byBhdm9pZCBjb2xsaXNpb24gYXQgbWluaW11bSBzaXplLlxuICAgICAgICAvLyBPZmZzZXQgcmVhY2hlcyB2YWx1ZSBvZiAwIGF0IFwibWF4aW11bVwiIHBvc2l0aW9uLCBzbyBtYXhpbXVtIHBvc2l0aW9uIGlzIG5vdCBhbHRlcmVkIGF0IGFsbC5cbiAgICAgICAgdmFyIG1pbmltdW1PZmZzZXQgPSBhbGlnbiA9PT0gJ2xlZnQnIHx8IGFsaWduID09PSAndG9wJyA/IChpdGVtU2l6ZVswXSAtIHN5bWJvbFNpemUpIC8gMiA6IChpdGVtU2l6ZVswXSAtIHN5bWJvbFNpemUpIC8gLTI7XG4gICAgICAgIHRleHRQb2ludFsxXSArPSBtaW5pbXVtT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaGFuZGxlTGFiZWxzW2hhbmRsZUluZGV4XS5zZXRTdHlsZSh7XG4gICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgeTogdGV4dFBvaW50WzFdLFxuICAgICAgICB0ZXh0OiB2aXN1YWxNYXBNb2RlbC5mb3JtYXRWYWx1ZVRleHQodGhpcy5fZGF0YUludGVydmFsW2hhbmRsZUluZGV4XSksXG4gICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxuICAgICAgICBhbGlnbjogdGhpcy5fb3JpZW50ID09PSAndmVydGljYWwnID8gdGhpcy5fYXBwbHlUcmFuc2Zvcm0oJ2xlZnQnLCBzaGFwZXMubWFpbkdyb3VwKSA6ICdjZW50ZXInXG4gICAgICB9KTtcbiAgICB9LCB0aGlzKTtcbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9zaG93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGN1cnNvclZhbHVlLCB0ZXh0VmFsdWUsIHJhbmdlU3ltYm9sLCBoYWxmSG92ZXJMaW5rU2l6ZSkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIGRhdGFFeHRlbnQgPSB2aXN1YWxNYXBNb2RlbC5nZXRFeHRlbnQoKTtcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgc2l6ZUV4dGVudCA9IFswLCBpdGVtU2l6ZVsxXV07XG4gICAgdmFyIHNoYXBlcyA9IHRoaXMuX3NoYXBlcztcbiAgICB2YXIgaW5kaWNhdG9yID0gc2hhcGVzLmluZGljYXRvcjtcbiAgICBpZiAoIWluZGljYXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbmRpY2F0b3IuYXR0cignaW52aXNpYmxlJywgZmFsc2UpO1xuICAgIHZhciBvcHRzID0ge1xuICAgICAgY29udmVydE9wYWNpdHlUb0FscGhhOiB0cnVlXG4gICAgfTtcbiAgICB2YXIgY29sb3IgPSB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwoY3Vyc29yVmFsdWUsICdjb2xvcicsIG9wdHMpO1xuICAgIHZhciBzeW1ib2xTaXplID0gdGhpcy5nZXRDb250cm9sbGVyVmlzdWFsKGN1cnNvclZhbHVlLCAnc3ltYm9sU2l6ZScpO1xuICAgIHZhciB5ID0gbGluZWFyTWFwKGN1cnNvclZhbHVlLCBkYXRhRXh0ZW50LCBzaXplRXh0ZW50LCB0cnVlKTtcbiAgICB2YXIgeCA9IGl0ZW1TaXplWzBdIC0gc3ltYm9sU2l6ZSAvIDI7XG4gICAgdmFyIG9sZEluZGljYXRvclBvcyA9IHtcbiAgICAgIHg6IGluZGljYXRvci54LFxuICAgICAgeTogaW5kaWNhdG9yLnlcbiAgICB9O1xuICAgIC8vIFVwZGF0ZSBoYW5kbGUgbGFiZWwgcG9zaXRpb24uXG4gICAgaW5kaWNhdG9yLnkgPSB5O1xuICAgIGluZGljYXRvci54ID0geDtcbiAgICB2YXIgdGV4dFBvaW50ID0gZ3JhcGhpYy5hcHBseVRyYW5zZm9ybShzaGFwZXMuaW5kaWNhdG9yTGFiZWxQb2ludCwgZ3JhcGhpYy5nZXRUcmFuc2Zvcm0oaW5kaWNhdG9yLCB0aGlzLmdyb3VwKSk7XG4gICAgdmFyIGluZGljYXRvckxhYmVsID0gc2hhcGVzLmluZGljYXRvckxhYmVsO1xuICAgIGluZGljYXRvckxhYmVsLmF0dHIoJ2ludmlzaWJsZScsIGZhbHNlKTtcbiAgICB2YXIgYWxpZ24gPSB0aGlzLl9hcHBseVRyYW5zZm9ybSgnbGVmdCcsIHNoYXBlcy5tYWluR3JvdXApO1xuICAgIHZhciBvcmllbnQgPSB0aGlzLl9vcmllbnQ7XG4gICAgdmFyIGlzSG9yaXpvbnRhbCA9IG9yaWVudCA9PT0gJ2hvcml6b250YWwnO1xuICAgIGluZGljYXRvckxhYmVsLnNldFN0eWxlKHtcbiAgICAgIHRleHQ6IChyYW5nZVN5bWJvbCA/IHJhbmdlU3ltYm9sIDogJycpICsgdmlzdWFsTWFwTW9kZWwuZm9ybWF0VmFsdWVUZXh0KHRleHRWYWx1ZSksXG4gICAgICB2ZXJ0aWNhbEFsaWduOiBpc0hvcml6b250YWwgPyBhbGlnbiA6ICdtaWRkbGUnLFxuICAgICAgYWxpZ246IGlzSG9yaXpvbnRhbCA/ICdjZW50ZXInIDogYWxpZ25cbiAgICB9KTtcbiAgICB2YXIgaW5kaWNhdG9yTmV3UHJvcHMgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGZpbGw6IGNvbG9yXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbGFiZWxOZXdQcm9wcyA9IHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHg6IHRleHRQb2ludFswXSxcbiAgICAgICAgeTogdGV4dFBvaW50WzFdXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAodmlzdWFsTWFwTW9kZWwuZWNNb2RlbC5pc0FuaW1hdGlvbkVuYWJsZWQoKSAmJiAhdGhpcy5fZmlyc3RTaG93SW5kaWNhdG9yKSB7XG4gICAgICB2YXIgYW5pbWF0aW9uQ2ZnID0ge1xuICAgICAgICBkdXJhdGlvbjogMTAwLFxuICAgICAgICBlYXNpbmc6ICdjdWJpY0luT3V0JyxcbiAgICAgICAgYWRkaXRpdmU6IHRydWVcbiAgICAgIH07XG4gICAgICBpbmRpY2F0b3IueCA9IG9sZEluZGljYXRvclBvcy54O1xuICAgICAgaW5kaWNhdG9yLnkgPSBvbGRJbmRpY2F0b3JQb3MueTtcbiAgICAgIGluZGljYXRvci5hbmltYXRlVG8oaW5kaWNhdG9yTmV3UHJvcHMsIGFuaW1hdGlvbkNmZyk7XG4gICAgICBpbmRpY2F0b3JMYWJlbC5hbmltYXRlVG8obGFiZWxOZXdQcm9wcywgYW5pbWF0aW9uQ2ZnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNhdG9yLmF0dHIoaW5kaWNhdG9yTmV3UHJvcHMpO1xuICAgICAgaW5kaWNhdG9yTGFiZWwuYXR0cihsYWJlbE5ld1Byb3BzKTtcbiAgICB9XG4gICAgdGhpcy5fZmlyc3RTaG93SW5kaWNhdG9yID0gZmFsc2U7XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IHRoaXMuX3NoYXBlcy5oYW5kbGVMYWJlbHM7XG4gICAgaWYgKGhhbmRsZUxhYmVscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmFkZSBvdXQgaGFuZGxlIGxhYmVscy5cbiAgICAgICAgLy8gTk9URTogTXVzdCB1c2UgYXBpIGVudGVyL2xlYXZlIG9uIGVtcGhhc2lzL2JsdXIvc2VsZWN0IHN0YXRlLiBPciB0aGUgZ2xvYmFsIHN0YXRlcyBtYW5hZ2VyIHdpbGwgY2hhbmdlIGl0LlxuICAgICAgICB0aGlzLmFwaS5lbnRlckJsdXIoaGFuZGxlTGFiZWxzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fZW5hYmxlSG92ZXJMaW5rVG9TZXJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3NoYXBlcy5tYWluR3JvdXAub24oJ21vdXNlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBzZWxmLl9ob3ZlcmluZyA9IHRydWU7XG4gICAgICBpZiAoIXNlbGYuX2RyYWdnaW5nKSB7XG4gICAgICAgIHZhciBpdGVtU2l6ZSA9IHNlbGYudmlzdWFsTWFwTW9kZWwuaXRlbVNpemU7XG4gICAgICAgIHZhciBwb3MgPSBzZWxmLl9hcHBseVRyYW5zZm9ybShbZS5vZmZzZXRYLCBlLm9mZnNldFldLCBzZWxmLl9zaGFwZXMubWFpbkdyb3VwLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgLy8gRm9yIGhvdmVyIGxpbmsgc2hvdyB3aGVuIGhvdmVyIGhhbmRsZSwgd2hpY2ggbWlnaHQgYmVcbiAgICAgICAgLy8gYmVsb3cgb3IgdXBwZXIgdGhhbiBzaXplRXh0ZW50LlxuICAgICAgICBwb3NbMV0gPSBtYXRoTWluKG1hdGhNYXgoMCwgcG9zWzFdKSwgaXRlbVNpemVbMV0pO1xuICAgICAgICBzZWxmLl9kb0hvdmVyTGlua1RvU2VyaWVzKHBvc1sxXSwgMCA8PSBwb3NbMF0gJiYgcG9zWzBdIDw9IGl0ZW1TaXplWzBdKTtcbiAgICAgIH1cbiAgICB9KS5vbignbW91c2VvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBXaGVuIG1vdXNlIGlzIG91dCBvZiBoYW5kbGUsIGhvdmVyTGluayBzdGlsbCBuZWVkXG4gICAgICAvLyB0byBiZSBkaXNwbGF5ZWQgd2hlbiByZWFsdGltZSBpcyBzZXQgYXMgZmFsc2UuXG4gICAgICBzZWxmLl9ob3ZlcmluZyA9IGZhbHNlO1xuICAgICAgIXNlbGYuX2RyYWdnaW5nICYmIHNlbGYuX2NsZWFySG92ZXJMaW5rVG9TZXJpZXMoKTtcbiAgICB9KTtcbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9lbmFibGVIb3ZlckxpbmtGcm9tU2VyaWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB6ciA9IHRoaXMuYXBpLmdldFpyKCk7XG4gICAgaWYgKHRoaXMudmlzdWFsTWFwTW9kZWwub3B0aW9uLmhvdmVyTGluaykge1xuICAgICAgenIub24oJ21vdXNlb3ZlcicsIHRoaXMuX2hvdmVyTGlua0Zyb21TZXJpZXNNb3VzZU92ZXIsIHRoaXMpO1xuICAgICAgenIub24oJ21vdXNlb3V0JywgdGhpcy5faGlkZUluZGljYXRvciwgdGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NsZWFySG92ZXJMaW5rRnJvbVNlcmllcygpO1xuICAgIH1cbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9kb0hvdmVyTGlua1RvU2VyaWVzID0gZnVuY3Rpb24gKGN1cnNvclBvcywgaG92ZXJPbkJhcikge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIGl0ZW1TaXplID0gdmlzdWFsTWFwTW9kZWwuaXRlbVNpemU7XG4gICAgaWYgKCF2aXN1YWxNYXBNb2RlbC5vcHRpb24uaG92ZXJMaW5rKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzaXplRXh0ZW50ID0gWzAsIGl0ZW1TaXplWzFdXTtcbiAgICB2YXIgZGF0YUV4dGVudCA9IHZpc3VhbE1hcE1vZGVsLmdldEV4dGVudCgpO1xuICAgIC8vIEZvciBob3ZlciBsaW5rIHNob3cgd2hlbiBob3ZlciBoYW5kbGUsIHdoaWNoIG1pZ2h0IGJlIGJlbG93IG9yIHVwcGVyIHRoYW4gc2l6ZUV4dGVudC5cbiAgICBjdXJzb3JQb3MgPSBtYXRoTWluKG1hdGhNYXgoc2l6ZUV4dGVudFswXSwgY3Vyc29yUG9zKSwgc2l6ZUV4dGVudFsxXSk7XG4gICAgdmFyIGhhbGZIb3ZlckxpbmtTaXplID0gZ2V0SGFsZkhvdmVyTGlua1NpemUodmlzdWFsTWFwTW9kZWwsIGRhdGFFeHRlbnQsIHNpemVFeHRlbnQpO1xuICAgIHZhciBob3ZlclJhbmdlID0gW2N1cnNvclBvcyAtIGhhbGZIb3ZlckxpbmtTaXplLCBjdXJzb3JQb3MgKyBoYWxmSG92ZXJMaW5rU2l6ZV07XG4gICAgdmFyIGN1cnNvclZhbHVlID0gbGluZWFyTWFwKGN1cnNvclBvcywgc2l6ZUV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSk7XG4gICAgdmFyIHZhbHVlUmFuZ2UgPSBbbGluZWFyTWFwKGhvdmVyUmFuZ2VbMF0sIHNpemVFeHRlbnQsIGRhdGFFeHRlbnQsIHRydWUpLCBsaW5lYXJNYXAoaG92ZXJSYW5nZVsxXSwgc2l6ZUV4dGVudCwgZGF0YUV4dGVudCwgdHJ1ZSldO1xuICAgIC8vIENvbnNpZGVyIGRhdGEgcmFuZ2UgaXMgb3V0IG9mIHZpc3VhbE1hcCByYW5nZSwgc2VlIHRlc3QvdmlzdWFsTWFwLWNvbnRpbnVvdXMuaHRtbCxcbiAgICAvLyB3aGVyZSBjaGluYSBhbmQgaW5kaWEgaGFzIHZlcnkgbGFyZ2UgcG9wdWxhdGlvbi5cbiAgICBob3ZlclJhbmdlWzBdIDwgc2l6ZUV4dGVudFswXSAmJiAodmFsdWVSYW5nZVswXSA9IC1JbmZpbml0eSk7XG4gICAgaG92ZXJSYW5nZVsxXSA+IHNpemVFeHRlbnRbMV0gJiYgKHZhbHVlUmFuZ2VbMV0gPSBJbmZpbml0eSk7XG4gICAgLy8gRG8gbm90IHNob3cgaW5kaWNhdG9yIHdoZW4gbW91c2UgaXMgb3ZlciBoYW5kbGUsXG4gICAgLy8gb3RoZXJ3aXNlIGxhYmVscyBvdmVybGFwLCBlc3BlY2lhbGx5IHdoZW4gZHJhZ2dpbmcuXG4gICAgaWYgKGhvdmVyT25CYXIpIHtcbiAgICAgIGlmICh2YWx1ZVJhbmdlWzBdID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgdGhpcy5fc2hvd0luZGljYXRvcihjdXJzb3JWYWx1ZSwgdmFsdWVSYW5nZVsxXSwgJzwgJywgaGFsZkhvdmVyTGlua1NpemUpO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZVJhbmdlWzFdID09PSBJbmZpbml0eSkge1xuICAgICAgICB0aGlzLl9zaG93SW5kaWNhdG9yKGN1cnNvclZhbHVlLCB2YWx1ZVJhbmdlWzBdLCAnPiAnLCBoYWxmSG92ZXJMaW5rU2l6ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zaG93SW5kaWNhdG9yKGN1cnNvclZhbHVlLCBjdXJzb3JWYWx1ZSwgJ+KJiCAnLCBoYWxmSG92ZXJMaW5rU2l6ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFdoZW4gcmVhbHRpbWUgaXMgc2V0IGFzIGZhbHNlLCBoYW5kbGVzLCB3aGljaCBhcmUgaW4gYmFyR3JvdXAsXG4gICAgLy8gYWxzbyB0cmlnZ2VyIGhvdmVyTGluaywgd2hpY2ggaGVscCB1c2VyIHRvIHJlYWxpemUgd2hlcmUgdGhleVxuICAgIC8vIGZvY3VzIG9uIHdoZW4gZHJhZ2dpbmcuIChzZWUgdGVzdC9oZWF0bWFwLWxhcmdlLmh0bWwpXG4gICAgLy8gV2hlbiByZWFsdGltZSBpcyBzZXQgYXMgdHJ1ZSwgaGlnaGxpZ2h0IHdpbGwgbm90IHNob3cgd2hlbiBob3ZlclxuICAgIC8vIGhhbmRsZSwgYmVjYXVzZSB0aGUgbGFiZWwgb24gaGFuZGxlLCB3aGljaCBkaXNwbGF5cyBhIGV4YWN0IHZhbHVlXG4gICAgLy8gYnV0IG5vdCByYW5nZSwgbWlnaHQgbWlzbGVhZCB1c2Vycy5cbiAgICB2YXIgb2xkQmF0Y2ggPSB0aGlzLl9ob3ZlckxpbmtEYXRhSW5kaWNlcztcbiAgICB2YXIgbmV3QmF0Y2ggPSBbXTtcbiAgICBpZiAoaG92ZXJPbkJhciB8fCB1c2VIb3ZlckxpbmtPbkhhbmRsZSh2aXN1YWxNYXBNb2RlbCkpIHtcbiAgICAgIG5ld0JhdGNoID0gdGhpcy5faG92ZXJMaW5rRGF0YUluZGljZXMgPSB2aXN1YWxNYXBNb2RlbC5maW5kVGFyZ2V0RGF0YUluZGljZXModmFsdWVSYW5nZSk7XG4gICAgfVxuICAgIHZhciByZXN1bHRCYXRjaGVzID0gbW9kZWxVdGlsLmNvbXByZXNzQmF0Y2hlcyhvbGRCYXRjaCwgbmV3QmF0Y2gpO1xuICAgIHRoaXMuX2Rpc3BhdGNoSGlnaERvd24oJ2Rvd25wbGF5JywgaGVscGVyLm1ha2VIaWdoRG93bkJhdGNoKHJlc3VsdEJhdGNoZXNbMF0sIHZpc3VhbE1hcE1vZGVsKSk7XG4gICAgdGhpcy5fZGlzcGF0Y2hIaWdoRG93bignaGlnaGxpZ2h0JywgaGVscGVyLm1ha2VIaWdoRG93bkJhdGNoKHJlc3VsdEJhdGNoZXNbMV0sIHZpc3VhbE1hcE1vZGVsKSk7XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5faG92ZXJMaW5rRnJvbVNlcmllc01vdXNlT3ZlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGVjRGF0YTtcbiAgICBmaW5kRXZlbnREaXNwYXRjaGVyKGUudGFyZ2V0LCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICB2YXIgY3VyckVDRGF0YSA9IGdldEVDRGF0YSh0YXJnZXQpO1xuICAgICAgaWYgKGN1cnJFQ0RhdGEuZGF0YUluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgZWNEYXRhID0gY3VyckVDRGF0YTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gICAgaWYgKCFlY0RhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGFNb2RlbCA9IHRoaXMuZWNNb2RlbC5nZXRTZXJpZXNCeUluZGV4KGVjRGF0YS5zZXJpZXNJbmRleCk7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICBpZiAoIXZpc3VhbE1hcE1vZGVsLmlzVGFyZ2V0U2VyaWVzKGRhdGFNb2RlbCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBkYXRhTW9kZWwuZ2V0RGF0YShlY0RhdGEuZGF0YVR5cGUpO1xuICAgIHZhciB2YWx1ZSA9IGRhdGEuZ2V0U3RvcmUoKS5nZXQodmlzdWFsTWFwTW9kZWwuZ2V0RGF0YURpbWVuc2lvbkluZGV4KGRhdGEpLCBlY0RhdGEuZGF0YUluZGV4KTtcbiAgICBpZiAoIWlzTmFOKHZhbHVlKSkge1xuICAgICAgdGhpcy5fc2hvd0luZGljYXRvcih2YWx1ZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9oaWRlSW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzaGFwZXMgPSB0aGlzLl9zaGFwZXM7XG4gICAgc2hhcGVzLmluZGljYXRvciAmJiBzaGFwZXMuaW5kaWNhdG9yLmF0dHIoJ2ludmlzaWJsZScsIHRydWUpO1xuICAgIHNoYXBlcy5pbmRpY2F0b3JMYWJlbCAmJiBzaGFwZXMuaW5kaWNhdG9yTGFiZWwuYXR0cignaW52aXNpYmxlJywgdHJ1ZSk7XG4gICAgdmFyIGhhbmRsZUxhYmVscyA9IHRoaXMuX3NoYXBlcy5oYW5kbGVMYWJlbHM7XG4gICAgaWYgKGhhbmRsZUxhYmVscykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVMYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gRmFkZSBvdXQgaGFuZGxlIGxhYmVscy5cbiAgICAgICAgLy8gTk9URTogTXVzdCB1c2UgYXBpIGVudGVyL2xlYXZlIG9uIGVtcGhhc2lzL2JsdXIvc2VsZWN0IHN0YXRlLiBPciB0aGUgZ2xvYmFsIHN0YXRlcyBtYW5hZ2VyIHdpbGwgY2hhbmdlIGl0LlxuICAgICAgICB0aGlzLmFwaS5sZWF2ZUJsdXIoaGFuZGxlTGFiZWxzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENvbnRpbnVvdXNWaWV3LnByb3RvdHlwZS5fY2xlYXJIb3ZlckxpbmtUb1NlcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlSW5kaWNhdG9yKCk7XG4gICAgdmFyIGluZGljZXMgPSB0aGlzLl9ob3ZlckxpbmtEYXRhSW5kaWNlcztcbiAgICB0aGlzLl9kaXNwYXRjaEhpZ2hEb3duKCdkb3ducGxheScsIGhlbHBlci5tYWtlSGlnaERvd25CYXRjaChpbmRpY2VzLCB0aGlzLnZpc3VhbE1hcE1vZGVsKSk7XG4gICAgaW5kaWNlcy5sZW5ndGggPSAwO1xuICB9O1xuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2NsZWFySG92ZXJMaW5rRnJvbVNlcmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9oaWRlSW5kaWNhdG9yKCk7XG4gICAgdmFyIHpyID0gdGhpcy5hcGkuZ2V0WnIoKTtcbiAgICB6ci5vZmYoJ21vdXNlb3ZlcicsIHRoaXMuX2hvdmVyTGlua0Zyb21TZXJpZXNNb3VzZU92ZXIpO1xuICAgIHpyLm9mZignbW91c2VvdXQnLCB0aGlzLl9oaWRlSW5kaWNhdG9yKTtcbiAgfTtcbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLl9hcHBseVRyYW5zZm9ybSA9IGZ1bmN0aW9uICh2ZXJ0ZXgsIGVsZW1lbnQsIGludmVyc2UsIGdsb2JhbCkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBncmFwaGljLmdldFRyYW5zZm9ybShlbGVtZW50LCBnbG9iYWwgPyBudWxsIDogdGhpcy5ncm91cCk7XG4gICAgcmV0dXJuIHpyVXRpbC5pc0FycmF5KHZlcnRleCkgPyBncmFwaGljLmFwcGx5VHJhbnNmb3JtKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnNlKSA6IGdyYXBoaWMudHJhbnNmb3JtRGlyZWN0aW9uKHZlcnRleCwgdHJhbnNmb3JtLCBpbnZlcnNlKTtcbiAgfTtcbiAgLy8gVE9ETzogVFlQRSBtb3JlIHNwZWNpZmllZCBwYXlsb2FkIHR5cGVzLlxuICBDb250aW51b3VzVmlldy5wcm90b3R5cGUuX2Rpc3BhdGNoSGlnaERvd24gPSBmdW5jdGlvbiAodHlwZSwgYmF0Y2gpIHtcbiAgICBiYXRjaCAmJiBiYXRjaC5sZW5ndGggJiYgdGhpcy5hcGkuZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGJhdGNoOiBiYXRjaFxuICAgIH0pO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgQ29udGludW91c1ZpZXcucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fY2xlYXJIb3ZlckxpbmtGcm9tU2VyaWVzKCk7XG4gICAgdGhpcy5fY2xlYXJIb3ZlckxpbmtUb1NlcmllcygpO1xuICB9O1xuICBDb250aW51b3VzVmlldy50eXBlID0gJ3Zpc3VhbE1hcC5jb250aW51b3VzJztcbiAgcmV0dXJuIENvbnRpbnVvdXNWaWV3O1xufShWaXN1YWxNYXBWaWV3KTtcbmZ1bmN0aW9uIGNyZWF0ZVBvbHlnb24ocG9pbnRzLCBjdXJzb3IsIG9uRHJpZnQsIG9uRHJhZ0VuZCkge1xuICByZXR1cm4gbmV3IGdyYXBoaWMuUG9seWdvbih7XG4gICAgc2hhcGU6IHtcbiAgICAgIHBvaW50czogcG9pbnRzXG4gICAgfSxcbiAgICBkcmFnZ2FibGU6ICEhb25EcmlmdCxcbiAgICBjdXJzb3I6IGN1cnNvcixcbiAgICBkcmlmdDogb25EcmlmdCxcbiAgICBvbm1vdXNlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgIC8vIEZvciBtb2JpbGUgZGV2aWNlLCBwcmV2ZW50IHNjcmVlbiBzbGlkZXIgb24gdGhlIGJ1dHRvbi5cbiAgICAgIGV2ZW50VG9vbC5zdG9wKGUuZXZlbnQpO1xuICAgIH0sXG4gICAgb25kcmFnZW5kOiBvbkRyYWdFbmRcbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRIYWxmSG92ZXJMaW5rU2l6ZSh2aXN1YWxNYXBNb2RlbCwgZGF0YUV4dGVudCwgc2l6ZUV4dGVudCkge1xuICB2YXIgaGFsZkhvdmVyTGlua1NpemUgPSBIT1ZFUl9MSU5LX1NJWkUgLyAyO1xuICB2YXIgaG92ZXJMaW5rRGF0YVNpemUgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ2hvdmVyTGlua0RhdGFTaXplJyk7XG4gIGlmIChob3ZlckxpbmtEYXRhU2l6ZSkge1xuICAgIGhhbGZIb3ZlckxpbmtTaXplID0gbGluZWFyTWFwKGhvdmVyTGlua0RhdGFTaXplLCBkYXRhRXh0ZW50LCBzaXplRXh0ZW50LCB0cnVlKSAvIDI7XG4gIH1cbiAgcmV0dXJuIGhhbGZIb3ZlckxpbmtTaXplO1xufVxuZnVuY3Rpb24gdXNlSG92ZXJMaW5rT25IYW5kbGUodmlzdWFsTWFwTW9kZWwpIHtcbiAgdmFyIGhvdmVyTGlua09uSGFuZGxlID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCdob3ZlckxpbmtPbkhhbmRsZScpO1xuICByZXR1cm4gISEoaG92ZXJMaW5rT25IYW5kbGUgPT0gbnVsbCA/IHZpc3VhbE1hcE1vZGVsLmdldCgncmVhbHRpbWUnKSA6IGhvdmVyTGlua09uSGFuZGxlKTtcbn1cbmZ1bmN0aW9uIGdldEN1cnNvcihvcmllbnQpIHtcbiAgcmV0dXJuIG9yaWVudCA9PT0gJ3ZlcnRpY2FsJyA/ICducy1yZXNpemUnIDogJ2V3LXJlc2l6ZSc7XG59XG5leHBvcnQgZGVmYXVsdCBDb250aW51b3VzVmlldzsiLCJcbi8qXG4qIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4qIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Vcbiogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuKlxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuKlxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4qIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4qIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuXG4vKipcbiAqIEFVVE8tR0VORVJBVEVEIEZJTEUuIERPIE5PVCBNT0RJRlkuXG4gKi9cblxuLypcclxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXHJcbiogb3IgbW9yZSBjb250cmlidXRvciBsaWNlbnNlIGFncmVlbWVudHMuICBTZWUgdGhlIE5PVElDRSBmaWxlXHJcbiogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cclxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXHJcbiogdG8geW91IHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZVxyXG4qIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxyXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuKlxyXG4qICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcbipcclxuKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsXHJcbiogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cclxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4qIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZVxyXG4qIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcclxuKiB1bmRlciB0aGUgTGljZW5zZS5cclxuKi9cbmltcG9ydCBDb250aW51b3VzTW9kZWwgZnJvbSAnLi9Db250aW51b3VzTW9kZWwuanMnO1xuaW1wb3J0IENvbnRpbnVvdXNWaWV3IGZyb20gJy4vQ29udGludW91c1ZpZXcuanMnO1xuaW1wb3J0IGluc3RhbGxDb21tb24gZnJvbSAnLi9pbnN0YWxsQ29tbW9uLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChDb250aW51b3VzTW9kZWwpO1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRWaWV3KENvbnRpbnVvdXNWaWV3KTtcbiAgaW5zdGFsbENvbW1vbihyZWdpc3RlcnMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67113\n")},68781:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  a: () => (/* binding */ install)\n});\n\n// EXTERNAL MODULE: ./node_modules/echarts/node_modules/tslib/tslib.es6.js\nvar tslib_es6 = __webpack_require__(74179);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/core/util.js\nvar util = __webpack_require__(98026);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/VisualMapModel.js\nvar VisualMapModel = __webpack_require__(26192);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/VisualMapping.js\nvar VisualMapping = __webpack_require__(7857);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/visual/visualDefault.js\nvar visualDefault = __webpack_require__(54942);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/number.js\nvar number = __webpack_require__(24326);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/component.js\nvar component = __webpack_require__(12616);\n;// ./node_modules/echarts/lib/component/visualMap/PiecewiseModel.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\nvar PiecewiseModel = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PiecewiseModel, _super);\n  function PiecewiseModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PiecewiseModel.type;\n    /**\r\n     * The order is always [low, ..., high].\r\n     * [{text: string, interval: Array.<number>}, ...]\r\n     */\n    _this._pieceList = [];\n    return _this;\n  }\n  PiecewiseModel.prototype.optionUpdated = function (newOption, isInit) {\n    _super.prototype.optionUpdated.apply(this, arguments);\n    this.resetExtent();\n    var mode = this._mode = this._determineMode();\n    this._pieceList = [];\n    resetMethods[this._mode].call(this, this._pieceList);\n    this._resetSelected(newOption, isInit);\n    var categories = this.option.categories;\n    this.resetVisual(function (mappingOption, state) {\n      if (mode === 'categories') {\n        mappingOption.mappingMethod = 'category';\n        mappingOption.categories = util.clone(categories);\n      } else {\n        mappingOption.dataExtent = this.getExtent();\n        mappingOption.mappingMethod = 'piecewise';\n        mappingOption.pieceList = util.map(this._pieceList, function (piece) {\n          piece = util.clone(piece);\n          if (state !== 'inRange') {\n            // FIXME\n            // outOfRange do not support special visual in pieces.\n            piece.visual = null;\n          }\n          return piece;\n        });\n      }\n    });\n  };\n  /**\r\n   * @protected\r\n   * @override\r\n   */\n  PiecewiseModel.prototype.completeVisualOption = function () {\n    // Consider this case:\n    // visualMap: {\n    //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]\n    // }\n    // where no inRange/outOfRange set but only pieces. So we should make\n    // default inRange/outOfRange for this case, otherwise visuals that only\n    // appear in `pieces` will not be taken into account in visual encoding.\n    var option = this.option;\n    var visualTypesInPieces = {};\n    var visualTypes = VisualMapping/* default */.A.listVisualTypes();\n    var isCategory = this.isCategory();\n    util.each(option.pieces, function (piece) {\n      util.each(visualTypes, function (visualType) {\n        if (piece.hasOwnProperty(visualType)) {\n          visualTypesInPieces[visualType] = 1;\n        }\n      });\n    });\n    util.each(visualTypesInPieces, function (v, visualType) {\n      var exists = false;\n      util.each(this.stateList, function (state) {\n        exists = exists || has(option, state, visualType) || has(option.target, state, visualType);\n      }, this);\n      !exists && util.each(this.stateList, function (state) {\n        (option[state] || (option[state] = {}))[visualType] = visualDefault/* default */.A.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory);\n      });\n    }, this);\n    function has(obj, state, visualType) {\n      return obj && obj[state] && obj[state].hasOwnProperty(visualType);\n    }\n    _super.prototype.completeVisualOption.apply(this, arguments);\n  };\n  PiecewiseModel.prototype._resetSelected = function (newOption, isInit) {\n    var thisOption = this.option;\n    var pieceList = this._pieceList;\n    // Selected do not merge but all override.\n    var selected = (isInit ? thisOption : newOption).selected || {};\n    thisOption.selected = selected;\n    // Consider 'not specified' means true.\n    util.each(pieceList, function (piece, index) {\n      var key = this.getSelectedMapKey(piece);\n      if (!selected.hasOwnProperty(key)) {\n        selected[key] = true;\n      }\n    }, this);\n    if (thisOption.selectedMode === 'single') {\n      // Ensure there is only one selected.\n      var hasSel_1 = false;\n      util.each(pieceList, function (piece, index) {\n        var key = this.getSelectedMapKey(piece);\n        if (selected[key]) {\n          hasSel_1 ? selected[key] = false : hasSel_1 = true;\n        }\n      }, this);\n    }\n    // thisOption.selectedMode === 'multiple', default: all selected.\n  };\n  /**\r\n   * @public\r\n   */\n  PiecewiseModel.prototype.getItemSymbol = function () {\n    return this.get('itemSymbol');\n  };\n  /**\r\n   * @public\r\n   */\n  PiecewiseModel.prototype.getSelectedMapKey = function (piece) {\n    return this._mode === 'categories' ? piece.value + '' : piece.index + '';\n  };\n  /**\r\n   * @public\r\n   */\n  PiecewiseModel.prototype.getPieceList = function () {\n    return this._pieceList;\n  };\n  /**\r\n   * @return {string}\r\n   */\n  PiecewiseModel.prototype._determineMode = function () {\n    var option = this.option;\n    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';\n  };\n  /**\r\n   * @override\r\n   */\n  PiecewiseModel.prototype.setSelected = function (selected) {\n    this.option.selected = util.clone(selected);\n  };\n  /**\r\n   * @override\r\n   */\n  PiecewiseModel.prototype.getValueState = function (value) {\n    var index = VisualMapping/* default */.A.findPieceIndex(value, this._pieceList);\n    return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';\n  };\n  /**\r\n   * @public\r\n   * @param pieceIndex piece index in visualMapModel.getPieceList()\r\n   */\n  PiecewiseModel.prototype.findTargetDataIndices = function (pieceIndex) {\n    var result = [];\n    var pieceList = this._pieceList;\n    this.eachTargetSeries(function (seriesModel) {\n      var dataIndices = [];\n      var data = seriesModel.getData();\n      data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {\n        // Should always base on model pieceList, because it is order sensitive.\n        var pIdx = VisualMapping/* default */.A.findPieceIndex(value, pieceList);\n        pIdx === pieceIndex && dataIndices.push(dataIndex);\n      }, this);\n      result.push({\n        seriesId: seriesModel.id,\n        dataIndex: dataIndices\n      });\n    }, this);\n    return result;\n  };\n  /**\r\n   * @private\r\n   * @param piece piece.value or piece.interval is required.\r\n   * @return  Can be Infinity or -Infinity\r\n   */\n  PiecewiseModel.prototype.getRepresentValue = function (piece) {\n    var representValue;\n    if (this.isCategory()) {\n      representValue = piece.value;\n    } else {\n      if (piece.value != null) {\n        representValue = piece.value;\n      } else {\n        var pieceInterval = piece.interval || [];\n        representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2;\n      }\n    }\n    return representValue;\n  };\n  PiecewiseModel.prototype.getVisualMeta = function (getColorVisual) {\n    // Do not support category. (category axis is ordinal, numerical)\n    if (this.isCategory()) {\n      return;\n    }\n    var stops = [];\n    var outerColors = ['', ''];\n    var visualMapModel = this;\n    function setStop(interval, valueState) {\n      var representValue = visualMapModel.getRepresentValue({\n        interval: interval\n      }); // Not category\n      if (!valueState) {\n        valueState = visualMapModel.getValueState(representValue);\n      }\n      var color = getColorVisual(representValue, valueState);\n      if (interval[0] === -Infinity) {\n        outerColors[0] = color;\n      } else if (interval[1] === Infinity) {\n        outerColors[1] = color;\n      } else {\n        stops.push({\n          value: interval[0],\n          color: color\n        }, {\n          value: interval[1],\n          color: color\n        });\n      }\n    }\n    // Suplement\n    var pieceList = this._pieceList.slice();\n    if (!pieceList.length) {\n      pieceList.push({\n        interval: [-Infinity, Infinity]\n      });\n    } else {\n      var edge = pieceList[0].interval[0];\n      edge !== -Infinity && pieceList.unshift({\n        interval: [-Infinity, edge]\n      });\n      edge = pieceList[pieceList.length - 1].interval[1];\n      edge !== Infinity && pieceList.push({\n        interval: [edge, Infinity]\n      });\n    }\n    var curr = -Infinity;\n    util.each(pieceList, function (piece) {\n      var interval = piece.interval;\n      if (interval) {\n        // Fulfill gap.\n        interval[0] > curr && setStop([curr, interval[0]], 'outOfRange');\n        setStop(interval.slice());\n        curr = interval[1];\n      }\n    }, this);\n    return {\n      stops: stops,\n      outerColors: outerColors\n    };\n  };\n  PiecewiseModel.type = 'visualMap.piecewise';\n  PiecewiseModel.defaultOption = (0,component/* inheritDefaultOption */.G_)(VisualMapModel/* default */.A.defaultOption, {\n    selected: null,\n    minOpen: false,\n    maxOpen: false,\n    align: 'auto',\n    itemWidth: 20,\n    itemHeight: 14,\n    itemSymbol: 'roundRect',\n    pieces: null,\n    categories: null,\n    splitNumber: 5,\n    selectedMode: 'multiple',\n    itemGap: 10,\n    hoverLink: true // Enable hover highlight.\n  });\n  return PiecewiseModel;\n}(VisualMapModel/* default */.A);\n;\n/**\r\n * Key is this._mode\r\n * @type {Object}\r\n * @this {module:echarts/component/viusalMap/PiecewiseMode}\r\n */\nvar resetMethods = {\n  splitNumber: function (outPieceList) {\n    var thisOption = this.option;\n    var precision = Math.min(thisOption.precision, 20);\n    var dataExtent = this.getExtent();\n    var splitNumber = thisOption.splitNumber;\n    splitNumber = Math.max(parseInt(splitNumber, 10), 1);\n    thisOption.splitNumber = splitNumber;\n    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;\n    // Precision auto-adaption\n    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {\n      precision++;\n    }\n    thisOption.precision = precision;\n    splitStep = +splitStep.toFixed(precision);\n    if (thisOption.minOpen) {\n      outPieceList.push({\n        interval: [-Infinity, dataExtent[0]],\n        close: [0, 0]\n      });\n    }\n    for (var index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {\n      var max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep;\n      outPieceList.push({\n        interval: [curr, max],\n        close: [1, 1]\n      });\n    }\n    if (thisOption.maxOpen) {\n      outPieceList.push({\n        interval: [dataExtent[1], Infinity],\n        close: [0, 0]\n      });\n    }\n    (0,number/* reformIntervals */.sL)(outPieceList);\n    util.each(outPieceList, function (piece, index) {\n      piece.index = index;\n      piece.text = this.formatValueText(piece.interval);\n    }, this);\n  },\n  categories: function (outPieceList) {\n    var thisOption = this.option;\n    util.each(thisOption.categories, function (cate) {\n      // FIXME categorypieceListvisualMappingpieceList\n      // \n      outPieceList.push({\n        text: this.formatValueText(cate, true),\n        value: cate\n      });\n    }, this);\n    // See \"Order Rule\".\n    normalizeReverse(thisOption, outPieceList);\n  },\n  pieces: function (outPieceList) {\n    var thisOption = this.option;\n    util.each(thisOption.pieces, function (pieceListItem, index) {\n      if (!util.isObject(pieceListItem)) {\n        pieceListItem = {\n          value: pieceListItem\n        };\n      }\n      var item = {\n        text: '',\n        index: index\n      };\n      if (pieceListItem.label != null) {\n        item.text = pieceListItem.label;\n      }\n      if (pieceListItem.hasOwnProperty('value')) {\n        var value = item.value = pieceListItem.value;\n        item.interval = [value, value];\n        item.close = [1, 1];\n      } else {\n        // `min` `max` is legacy option.\n        // `lt` `gt` `lte` `gte` is recommended.\n        var interval = item.interval = [];\n        var close_1 = item.close = [0, 0];\n        var closeList = [1, 0, 1];\n        var infinityList = [-Infinity, Infinity];\n        var useMinMax = [];\n        for (var lg = 0; lg < 2; lg++) {\n          var names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg];\n          for (var i = 0; i < 3 && interval[lg] == null; i++) {\n            interval[lg] = pieceListItem[names[i]];\n            close_1[lg] = closeList[i];\n            useMinMax[lg] = i === 2;\n          }\n          interval[lg] == null && (interval[lg] = infinityList[lg]);\n        }\n        useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0);\n        useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0);\n        if (false) {}\n        if (interval[0] === interval[1] && close_1[0] && close_1[1]) {\n          // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],\n          // we use value to lift the priority when min === max\n          item.value = interval[0];\n        }\n      }\n      item.visual = VisualMapping/* default */.A.retrieveVisuals(pieceListItem);\n      outPieceList.push(item);\n    }, this);\n    // See \"Order Rule\".\n    normalizeReverse(thisOption, outPieceList);\n    // Only pieces\n    (0,number/* reformIntervals */.sL)(outPieceList);\n    util.each(outPieceList, function (piece) {\n      var close = piece.close;\n      var edgeSymbols = [['<', ''][close[1]], ['>', ''][close[0]]];\n      piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols);\n    }, this);\n  }\n};\nfunction normalizeReverse(thisOption, pieceList) {\n  var inverse = thisOption.inverse;\n  if (thisOption.orient === 'vertical' ? !inverse : inverse) {\n    pieceList.reverse();\n  }\n}\n/* harmony default export */ const visualMap_PiecewiseModel = (PiecewiseModel);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/VisualMapView.js\nvar VisualMapView = __webpack_require__(59044);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Group.js\nvar Group = __webpack_require__(43870);\n// EXTERNAL MODULE: ./node_modules/zrender/lib/graphic/Text.js\nvar Text = __webpack_require__(32322);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/symbol.js\nvar symbol = __webpack_require__(62103);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/util/layout.js\nvar layout = __webpack_require__(34253);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/helper.js\nvar helper = __webpack_require__(46259);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/label/labelStyle.js\nvar labelStyle = __webpack_require__(89632);\n;// ./node_modules/echarts/lib/component/visualMap/PiecewiseView.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\n\n\n\n\n\nvar PiecewiseVisualMapView = /** @class */function (_super) {\n  (0,tslib_es6/* __extends */.C6)(PiecewiseVisualMapView, _super);\n  function PiecewiseVisualMapView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = PiecewiseVisualMapView.type;\n    return _this;\n  }\n  PiecewiseVisualMapView.prototype.doRender = function () {\n    var thisGroup = this.group;\n    thisGroup.removeAll();\n    var visualMapModel = this.visualMapModel;\n    var textGap = visualMapModel.get('textGap');\n    var textStyleModel = visualMapModel.textStyleModel;\n    var textFont = textStyleModel.getFont();\n    var textFill = textStyleModel.getTextColor();\n    var itemAlign = this._getItemAlign();\n    var itemSize = visualMapModel.itemSize;\n    var viewData = this._getViewData();\n    var endsText = viewData.endsText;\n    var showLabel = util.retrieve(visualMapModel.get('showLabel', true), !endsText);\n    var silent = !visualMapModel.get('selectedMode');\n    endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign);\n    util.each(viewData.viewPieceList, function (item) {\n      var piece = item.piece;\n      var itemGroup = new Group/* default */.A();\n      itemGroup.onclick = util.bind(this._onItemClick, this, piece);\n      this._enableHoverLink(itemGroup, item.indexInModelPieceList);\n      // TODO Category\n      var representValue = visualMapModel.getRepresentValue(piece);\n      this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]], silent);\n      if (showLabel) {\n        var visualState = this.visualMapModel.getValueState(representValue);\n        itemGroup.add(new Text/* default */.Ay({\n          style: {\n            x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,\n            y: itemSize[1] / 2,\n            text: piece.text,\n            verticalAlign: 'middle',\n            align: itemAlign,\n            font: textFont,\n            fill: textFill,\n            opacity: visualState === 'outOfRange' ? 0.5 : 1\n          },\n          silent: silent\n        }));\n      }\n      thisGroup.add(itemGroup);\n    }, this);\n    endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign);\n    layout/* box */.aP(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));\n    this.renderBackground(thisGroup);\n    this.positionGroup(thisGroup);\n  };\n  PiecewiseVisualMapView.prototype._enableHoverLink = function (itemGroup, pieceIndex) {\n    var _this = this;\n    itemGroup.on('mouseover', function () {\n      return onHoverLink('highlight');\n    }).on('mouseout', function () {\n      return onHoverLink('downplay');\n    });\n    var onHoverLink = function (method) {\n      var visualMapModel = _this.visualMapModel;\n      // TODO: TYPE More detailed action types\n      visualMapModel.option.hoverLink && _this.api.dispatchAction({\n        type: method,\n        batch: helper/* makeHighDownBatch */.l(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)\n      });\n    };\n  };\n  PiecewiseVisualMapView.prototype._getItemAlign = function () {\n    var visualMapModel = this.visualMapModel;\n    var modelOption = visualMapModel.option;\n    if (modelOption.orient === 'vertical') {\n      return helper/* getItemAlign */.J(visualMapModel, this.api, visualMapModel.itemSize);\n    } else {\n      // horizontal, most case left unless specifying right.\n      var align = modelOption.align;\n      if (!align || align === 'auto') {\n        align = 'left';\n      }\n      return align;\n    }\n  };\n  PiecewiseVisualMapView.prototype._renderEndsText = function (group, text, itemSize, showLabel, itemAlign) {\n    if (!text) {\n      return;\n    }\n    var itemGroup = new Group/* default */.A();\n    var textStyleModel = this.visualMapModel.textStyleModel;\n    itemGroup.add(new Text/* default */.Ay({\n      style: (0,labelStyle/* createTextStyle */.VB)(textStyleModel, {\n        x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,\n        y: itemSize[1] / 2,\n        verticalAlign: 'middle',\n        align: showLabel ? itemAlign : 'center',\n        text: text\n      })\n    }));\n    group.add(itemGroup);\n  };\n  /**\r\n   * @private\r\n   * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.\r\n   */\n  PiecewiseVisualMapView.prototype._getViewData = function () {\n    var visualMapModel = this.visualMapModel;\n    var viewPieceList = util.map(visualMapModel.getPieceList(), function (piece, index) {\n      return {\n        piece: piece,\n        indexInModelPieceList: index\n      };\n    });\n    var endsText = visualMapModel.get('text');\n    // Consider orient and inverse.\n    var orient = visualMapModel.get('orient');\n    var inverse = visualMapModel.get('inverse');\n    // Order of model pieceList is always [low, ..., high]\n    if (orient === 'horizontal' ? inverse : !inverse) {\n      viewPieceList.reverse();\n    }\n    // Origin order of endsText is [high, low]\n    else if (endsText) {\n      endsText = endsText.slice().reverse();\n    }\n    return {\n      viewPieceList: viewPieceList,\n      endsText: endsText\n    };\n  };\n  PiecewiseVisualMapView.prototype._createItemSymbol = function (group, representValue, shapeParam, silent) {\n    var itemSymbol = (0,symbol/* createSymbol */.v5)(\n    // symbol will be string\n    this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3],\n    // color will be string\n    this.getControllerVisual(representValue, 'color'));\n    itemSymbol.silent = silent;\n    group.add(itemSymbol);\n  };\n  PiecewiseVisualMapView.prototype._onItemClick = function (piece) {\n    var visualMapModel = this.visualMapModel;\n    var option = visualMapModel.option;\n    var selectedMode = option.selectedMode;\n    if (!selectedMode) {\n      return;\n    }\n    var selected = util.clone(option.selected);\n    var newKey = visualMapModel.getSelectedMapKey(piece);\n    if (selectedMode === 'single' || selectedMode === true) {\n      selected[newKey] = true;\n      util.each(selected, function (o, key) {\n        selected[key] = key === newKey;\n      });\n    } else {\n      selected[newKey] = !selected[newKey];\n    }\n    this.api.dispatchAction({\n      type: 'selectDataRange',\n      from: this.uid,\n      visualMapId: this.visualMapModel.id,\n      selected: selected\n    });\n  };\n  PiecewiseVisualMapView.type = 'visualMap.piecewise';\n  return PiecewiseVisualMapView;\n}(VisualMapView/* default */.A);\n/* harmony default export */ const PiecewiseView = (PiecewiseVisualMapView);\n// EXTERNAL MODULE: ./node_modules/echarts/lib/component/visualMap/installCommon.js + 3 modules\nvar installCommon = __webpack_require__(41369);\n;// ./node_modules/echarts/lib/component/visualMap/installVisualMapPiecewise.js\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n\n\n\nfunction install(registers) {\n  registers.registerComponentModel(visualMap_PiecewiseModel);\n  registers.registerComponentView(PiecewiseView);\n  (0,installCommon/* default */.A)(registers);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNjg3ODEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3JiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9QaWVjZXdpc2VNb2RlbC5qcz8wNTNhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9lY2hhcnRzL2xpYi9jb21wb25lbnQvdmlzdWFsTWFwL1BpZWNld2lzZVZpZXcuanM/MjU4NyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZWNoYXJ0cy9saWIvY29tcG9uZW50L3Zpc3VhbE1hcC9pbnN0YWxsVmlzdWFsTWFwUGllY2V3aXNlLmpzPzI0YzkiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFZpc3VhbE1hcE1vZGVsIGZyb20gJy4vVmlzdWFsTWFwTW9kZWwuanMnO1xuaW1wb3J0IFZpc3VhbE1hcHBpbmcgZnJvbSAnLi4vLi4vdmlzdWFsL1Zpc3VhbE1hcHBpbmcuanMnO1xuaW1wb3J0IHZpc3VhbERlZmF1bHQgZnJvbSAnLi4vLi4vdmlzdWFsL3Zpc3VhbERlZmF1bHQuanMnO1xuaW1wb3J0IHsgcmVmb3JtSW50ZXJ2YWxzIH0gZnJvbSAnLi4vLi4vdXRpbC9udW1iZXIuanMnO1xuaW1wb3J0IHsgaW5oZXJpdERlZmF1bHRPcHRpb24gfSBmcm9tICcuLi8uLi91dGlsL2NvbXBvbmVudC5qcyc7XG52YXIgUGllY2V3aXNlTW9kZWwgPSAvKiogQGNsYXNzICovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoUGllY2V3aXNlTW9kZWwsIF9zdXBlcik7XG4gIGZ1bmN0aW9uIFBpZWNld2lzZU1vZGVsKCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQaWVjZXdpc2VNb2RlbC50eXBlO1xuICAgIC8qKlxyXG4gICAgICogVGhlIG9yZGVyIGlzIGFsd2F5cyBbbG93LCAuLi4sIGhpZ2hdLlxyXG4gICAgICogW3t0ZXh0OiBzdHJpbmcsIGludGVydmFsOiBBcnJheS48bnVtYmVyPn0sIC4uLl1cclxuICAgICAqL1xuICAgIF90aGlzLl9waWVjZUxpc3QgPSBbXTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQgPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBpc0luaXQpIHtcbiAgICBfc3VwZXIucHJvdG90eXBlLm9wdGlvblVwZGF0ZWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLnJlc2V0RXh0ZW50KCk7XG4gICAgdmFyIG1vZGUgPSB0aGlzLl9tb2RlID0gdGhpcy5fZGV0ZXJtaW5lTW9kZSgpO1xuICAgIHRoaXMuX3BpZWNlTGlzdCA9IFtdO1xuICAgIHJlc2V0TWV0aG9kc1t0aGlzLl9tb2RlXS5jYWxsKHRoaXMsIHRoaXMuX3BpZWNlTGlzdCk7XG4gICAgdGhpcy5fcmVzZXRTZWxlY3RlZChuZXdPcHRpb24sIGlzSW5pdCk7XG4gICAgdmFyIGNhdGVnb3JpZXMgPSB0aGlzLm9wdGlvbi5jYXRlZ29yaWVzO1xuICAgIHRoaXMucmVzZXRWaXN1YWwoZnVuY3Rpb24gKG1hcHBpbmdPcHRpb24sIHN0YXRlKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2NhdGVnb3JpZXMnKSB7XG4gICAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdjYXRlZ29yeSc7XG4gICAgICAgIG1hcHBpbmdPcHRpb24uY2F0ZWdvcmllcyA9IHpyVXRpbC5jbG9uZShjYXRlZ29yaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcHBpbmdPcHRpb24uZGF0YUV4dGVudCA9IHRoaXMuZ2V0RXh0ZW50KCk7XG4gICAgICAgIG1hcHBpbmdPcHRpb24ubWFwcGluZ01ldGhvZCA9ICdwaWVjZXdpc2UnO1xuICAgICAgICBtYXBwaW5nT3B0aW9uLnBpZWNlTGlzdCA9IHpyVXRpbC5tYXAodGhpcy5fcGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgICAgICBwaWVjZSA9IHpyVXRpbC5jbG9uZShwaWVjZSk7XG4gICAgICAgICAgaWYgKHN0YXRlICE9PSAnaW5SYW5nZScpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgICAvLyBvdXRPZlJhbmdlIGRvIG5vdCBzdXBwb3J0IHNwZWNpYWwgdmlzdWFsIGluIHBpZWNlcy5cbiAgICAgICAgICAgIHBpZWNlLnZpc3VhbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwaWVjZTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcm90ZWN0ZWRcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLmNvbXBsZXRlVmlzdWFsT3B0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIENvbnNpZGVyIHRoaXMgY2FzZTpcbiAgICAvLyB2aXN1YWxNYXA6IHtcbiAgICAvLyAgICAgIHBpZWNlczogW3tzeW1ib2w6ICdjaXJjbGUnLCBsdDogMH0sIHtzeW1ib2w6ICdyZWN0JywgZ3RlOiAwfV1cbiAgICAvLyB9XG4gICAgLy8gd2hlcmUgbm8gaW5SYW5nZS9vdXRPZlJhbmdlIHNldCBidXQgb25seSBwaWVjZXMuIFNvIHdlIHNob3VsZCBtYWtlXG4gICAgLy8gZGVmYXVsdCBpblJhbmdlL291dE9mUmFuZ2UgZm9yIHRoaXMgY2FzZSwgb3RoZXJ3aXNlIHZpc3VhbHMgdGhhdCBvbmx5XG4gICAgLy8gYXBwZWFyIGluIGBwaWVjZXNgIHdpbGwgbm90IGJlIHRha2VuIGludG8gYWNjb3VudCBpbiB2aXN1YWwgZW5jb2RpbmcuXG4gICAgdmFyIG9wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciB2aXN1YWxUeXBlc0luUGllY2VzID0ge307XG4gICAgdmFyIHZpc3VhbFR5cGVzID0gVmlzdWFsTWFwcGluZy5saXN0VmlzdWFsVHlwZXMoKTtcbiAgICB2YXIgaXNDYXRlZ29yeSA9IHRoaXMuaXNDYXRlZ29yeSgpO1xuICAgIHpyVXRpbC5lYWNoKG9wdGlvbi5waWVjZXMsIGZ1bmN0aW9uIChwaWVjZSkge1xuICAgICAgenJVdGlsLmVhY2godmlzdWFsVHlwZXMsIGZ1bmN0aW9uICh2aXN1YWxUeXBlKSB7XG4gICAgICAgIGlmIChwaWVjZS5oYXNPd25Qcm9wZXJ0eSh2aXN1YWxUeXBlKSkge1xuICAgICAgICAgIHZpc3VhbFR5cGVzSW5QaWVjZXNbdmlzdWFsVHlwZV0gPSAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB6clV0aWwuZWFjaCh2aXN1YWxUeXBlc0luUGllY2VzLCBmdW5jdGlvbiAodiwgdmlzdWFsVHlwZSkge1xuICAgICAgdmFyIGV4aXN0cyA9IGZhbHNlO1xuICAgICAgenJVdGlsLmVhY2godGhpcy5zdGF0ZUxpc3QsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBleGlzdHMgPSBleGlzdHMgfHwgaGFzKG9wdGlvbiwgc3RhdGUsIHZpc3VhbFR5cGUpIHx8IGhhcyhvcHRpb24udGFyZ2V0LCBzdGF0ZSwgdmlzdWFsVHlwZSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgICFleGlzdHMgJiYgenJVdGlsLmVhY2godGhpcy5zdGF0ZUxpc3QsIGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAob3B0aW9uW3N0YXRlXSB8fCAob3B0aW9uW3N0YXRlXSA9IHt9KSlbdmlzdWFsVHlwZV0gPSB2aXN1YWxEZWZhdWx0LmdldCh2aXN1YWxUeXBlLCBzdGF0ZSA9PT0gJ2luUmFuZ2UnID8gJ2FjdGl2ZScgOiAnaW5hY3RpdmUnLCBpc0NhdGVnb3J5KTtcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuICAgIGZ1bmN0aW9uIGhhcyhvYmosIHN0YXRlLCB2aXN1YWxUeXBlKSB7XG4gICAgICByZXR1cm4gb2JqICYmIG9ialtzdGF0ZV0gJiYgb2JqW3N0YXRlXS5oYXNPd25Qcm9wZXJ0eSh2aXN1YWxUeXBlKTtcbiAgICB9XG4gICAgX3N1cGVyLnByb3RvdHlwZS5jb21wbGV0ZVZpc3VhbE9wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuX3Jlc2V0U2VsZWN0ZWQgPSBmdW5jdGlvbiAobmV3T3B0aW9uLCBpc0luaXQpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBwaWVjZUxpc3QgPSB0aGlzLl9waWVjZUxpc3Q7XG4gICAgLy8gU2VsZWN0ZWQgZG8gbm90IG1lcmdlIGJ1dCBhbGwgb3ZlcnJpZGUuXG4gICAgdmFyIHNlbGVjdGVkID0gKGlzSW5pdCA/IHRoaXNPcHRpb24gOiBuZXdPcHRpb24pLnNlbGVjdGVkIHx8IHt9O1xuICAgIHRoaXNPcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAvLyBDb25zaWRlciAnbm90IHNwZWNpZmllZCcgbWVhbnMgdHJ1ZS5cbiAgICB6clV0aWwuZWFjaChwaWVjZUxpc3QsIGZ1bmN0aW9uIChwaWVjZSwgaW5kZXgpIHtcbiAgICAgIHZhciBrZXkgPSB0aGlzLmdldFNlbGVjdGVkTWFwS2V5KHBpZWNlKTtcbiAgICAgIGlmICghc2VsZWN0ZWQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBzZWxlY3RlZFtrZXldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcbiAgICBpZiAodGhpc09wdGlvbi5zZWxlY3RlZE1vZGUgPT09ICdzaW5nbGUnKSB7XG4gICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0ZWQuXG4gICAgICB2YXIgaGFzU2VsXzEgPSBmYWxzZTtcbiAgICAgIHpyVXRpbC5lYWNoKHBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5nZXRTZWxlY3RlZE1hcEtleShwaWVjZSk7XG4gICAgICAgIGlmIChzZWxlY3RlZFtrZXldKSB7XG4gICAgICAgICAgaGFzU2VsXzEgPyBzZWxlY3RlZFtrZXldID0gZmFsc2UgOiBoYXNTZWxfMSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgICAvLyB0aGlzT3B0aW9uLnNlbGVjdGVkTW9kZSA9PT0gJ211bHRpcGxlJywgZGVmYXVsdDogYWxsIHNlbGVjdGVkLlxuICB9O1xuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5nZXRJdGVtU3ltYm9sID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgnaXRlbVN5bWJvbCcpO1xuICB9O1xuICAvKipcclxuICAgKiBAcHVibGljXHJcbiAgICovXG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5nZXRTZWxlY3RlZE1hcEtleSA9IGZ1bmN0aW9uIChwaWVjZSkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlID09PSAnY2F0ZWdvcmllcycgPyBwaWVjZS52YWx1ZSArICcnIDogcGllY2UuaW5kZXggKyAnJztcbiAgfTtcbiAgLyoqXHJcbiAgICogQHB1YmxpY1xyXG4gICAqL1xuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuZ2V0UGllY2VMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9waWVjZUxpc3Q7XG4gIH07XG4gIC8qKlxyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cclxuICAgKi9cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLl9kZXRlcm1pbmVNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICByZXR1cm4gb3B0aW9uLnBpZWNlcyAmJiBvcHRpb24ucGllY2VzLmxlbmd0aCA+IDAgPyAncGllY2VzJyA6IHRoaXMub3B0aW9uLmNhdGVnb3JpZXMgPyAnY2F0ZWdvcmllcycgOiAnc3BsaXROdW1iZXInO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLnNldFNlbGVjdGVkID0gZnVuY3Rpb24gKHNlbGVjdGVkKSB7XG4gICAgdGhpcy5vcHRpb24uc2VsZWN0ZWQgPSB6clV0aWwuY2xvbmUoc2VsZWN0ZWQpO1xuICB9O1xuICAvKipcclxuICAgKiBAb3ZlcnJpZGVcclxuICAgKi9cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLmdldFZhbHVlU3RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSBWaXN1YWxNYXBwaW5nLmZpbmRQaWVjZUluZGV4KHZhbHVlLCB0aGlzLl9waWVjZUxpc3QpO1xuICAgIHJldHVybiBpbmRleCAhPSBudWxsID8gdGhpcy5vcHRpb24uc2VsZWN0ZWRbdGhpcy5nZXRTZWxlY3RlZE1hcEtleSh0aGlzLl9waWVjZUxpc3RbaW5kZXhdKV0gPyAnaW5SYW5nZScgOiAnb3V0T2ZSYW5nZScgOiAnb3V0T2ZSYW5nZSc7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwdWJsaWNcclxuICAgKiBAcGFyYW0gcGllY2VJbmRleCBwaWVjZSBpbmRleCBpbiB2aXN1YWxNYXBNb2RlbC5nZXRQaWVjZUxpc3QoKVxyXG4gICAqL1xuICBQaWVjZXdpc2VNb2RlbC5wcm90b3R5cGUuZmluZFRhcmdldERhdGFJbmRpY2VzID0gZnVuY3Rpb24gKHBpZWNlSW5kZXgpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHBpZWNlTGlzdCA9IHRoaXMuX3BpZWNlTGlzdDtcbiAgICB0aGlzLmVhY2hUYXJnZXRTZXJpZXMoZnVuY3Rpb24gKHNlcmllc01vZGVsKSB7XG4gICAgICB2YXIgZGF0YUluZGljZXMgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gc2VyaWVzTW9kZWwuZ2V0RGF0YSgpO1xuICAgICAgZGF0YS5lYWNoKHRoaXMuZ2V0RGF0YURpbWVuc2lvbkluZGV4KGRhdGEpLCBmdW5jdGlvbiAodmFsdWUsIGRhdGFJbmRleCkge1xuICAgICAgICAvLyBTaG91bGQgYWx3YXlzIGJhc2Ugb24gbW9kZWwgcGllY2VMaXN0LCBiZWNhdXNlIGl0IGlzIG9yZGVyIHNlbnNpdGl2ZS5cbiAgICAgICAgdmFyIHBJZHggPSBWaXN1YWxNYXBwaW5nLmZpbmRQaWVjZUluZGV4KHZhbHVlLCBwaWVjZUxpc3QpO1xuICAgICAgICBwSWR4ID09PSBwaWVjZUluZGV4ICYmIGRhdGFJbmRpY2VzLnB1c2goZGF0YUluZGV4KTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBzZXJpZXNJZDogc2VyaWVzTW9kZWwuaWQsXG4gICAgICAgIGRhdGFJbmRleDogZGF0YUluZGljZXNcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHBpZWNlIHBpZWNlLnZhbHVlIG9yIHBpZWNlLmludGVydmFsIGlzIHJlcXVpcmVkLlxyXG4gICAqIEByZXR1cm4gIENhbiBiZSBJbmZpbml0eSBvciAtSW5maW5pdHlcclxuICAgKi9cbiAgUGllY2V3aXNlTW9kZWwucHJvdG90eXBlLmdldFJlcHJlc2VudFZhbHVlID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdmFyIHJlcHJlc2VudFZhbHVlO1xuICAgIGlmICh0aGlzLmlzQ2F0ZWdvcnkoKSkge1xuICAgICAgcmVwcmVzZW50VmFsdWUgPSBwaWVjZS52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBpZWNlLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgcmVwcmVzZW50VmFsdWUgPSBwaWVjZS52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwaWVjZUludGVydmFsID0gcGllY2UuaW50ZXJ2YWwgfHwgW107XG4gICAgICAgIHJlcHJlc2VudFZhbHVlID0gcGllY2VJbnRlcnZhbFswXSA9PT0gLUluZmluaXR5ICYmIHBpZWNlSW50ZXJ2YWxbMV0gPT09IEluZmluaXR5ID8gMCA6IChwaWVjZUludGVydmFsWzBdICsgcGllY2VJbnRlcnZhbFsxXSkgLyAyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVwcmVzZW50VmFsdWU7XG4gIH07XG4gIFBpZWNld2lzZU1vZGVsLnByb3RvdHlwZS5nZXRWaXN1YWxNZXRhID0gZnVuY3Rpb24gKGdldENvbG9yVmlzdWFsKSB7XG4gICAgLy8gRG8gbm90IHN1cHBvcnQgY2F0ZWdvcnkuIChjYXRlZ29yeSBheGlzIGlzIG9yZGluYWwsIG51bWVyaWNhbClcbiAgICBpZiAodGhpcy5pc0NhdGVnb3J5KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHN0b3BzID0gW107XG4gICAgdmFyIG91dGVyQ29sb3JzID0gWycnLCAnJ107XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcztcbiAgICBmdW5jdGlvbiBzZXRTdG9wKGludGVydmFsLCB2YWx1ZVN0YXRlKSB7XG4gICAgICB2YXIgcmVwcmVzZW50VmFsdWUgPSB2aXN1YWxNYXBNb2RlbC5nZXRSZXByZXNlbnRWYWx1ZSh7XG4gICAgICAgIGludGVydmFsOiBpbnRlcnZhbFxuICAgICAgfSk7IC8vIE5vdCBjYXRlZ29yeVxuICAgICAgaWYgKCF2YWx1ZVN0YXRlKSB7XG4gICAgICAgIHZhbHVlU3RhdGUgPSB2aXN1YWxNYXBNb2RlbC5nZXRWYWx1ZVN0YXRlKHJlcHJlc2VudFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb2xvciA9IGdldENvbG9yVmlzdWFsKHJlcHJlc2VudFZhbHVlLCB2YWx1ZVN0YXRlKTtcbiAgICAgIGlmIChpbnRlcnZhbFswXSA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIG91dGVyQ29sb3JzWzBdID0gY29sb3I7XG4gICAgICB9IGVsc2UgaWYgKGludGVydmFsWzFdID09PSBJbmZpbml0eSkge1xuICAgICAgICBvdXRlckNvbG9yc1sxXSA9IGNvbG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgICAgdmFsdWU6IGludGVydmFsWzBdLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9LCB7XG4gICAgICAgICAgdmFsdWU6IGludGVydmFsWzFdLFxuICAgICAgICAgIGNvbG9yOiBjb2xvclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU3VwbGVtZW50XG4gICAgdmFyIHBpZWNlTGlzdCA9IHRoaXMuX3BpZWNlTGlzdC5zbGljZSgpO1xuICAgIGlmICghcGllY2VMaXN0Lmxlbmd0aCkge1xuICAgICAgcGllY2VMaXN0LnB1c2goe1xuICAgICAgICBpbnRlcnZhbDogWy1JbmZpbml0eSwgSW5maW5pdHldXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVkZ2UgPSBwaWVjZUxpc3RbMF0uaW50ZXJ2YWxbMF07XG4gICAgICBlZGdlICE9PSAtSW5maW5pdHkgJiYgcGllY2VMaXN0LnVuc2hpZnQoe1xuICAgICAgICBpbnRlcnZhbDogWy1JbmZpbml0eSwgZWRnZV1cbiAgICAgIH0pO1xuICAgICAgZWRnZSA9IHBpZWNlTGlzdFtwaWVjZUxpc3QubGVuZ3RoIC0gMV0uaW50ZXJ2YWxbMV07XG4gICAgICBlZGdlICE9PSBJbmZpbml0eSAmJiBwaWVjZUxpc3QucHVzaCh7XG4gICAgICAgIGludGVydmFsOiBbZWRnZSwgSW5maW5pdHldXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIGN1cnIgPSAtSW5maW5pdHk7XG4gICAgenJVdGlsLmVhY2gocGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgIHZhciBpbnRlcnZhbCA9IHBpZWNlLmludGVydmFsO1xuICAgICAgaWYgKGludGVydmFsKSB7XG4gICAgICAgIC8vIEZ1bGZpbGwgZ2FwLlxuICAgICAgICBpbnRlcnZhbFswXSA+IGN1cnIgJiYgc2V0U3RvcChbY3VyciwgaW50ZXJ2YWxbMF1dLCAnb3V0T2ZSYW5nZScpO1xuICAgICAgICBzZXRTdG9wKGludGVydmFsLnNsaWNlKCkpO1xuICAgICAgICBjdXJyID0gaW50ZXJ2YWxbMV07XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0b3BzOiBzdG9wcyxcbiAgICAgIG91dGVyQ29sb3JzOiBvdXRlckNvbG9yc1xuICAgIH07XG4gIH07XG4gIFBpZWNld2lzZU1vZGVsLnR5cGUgPSAndmlzdWFsTWFwLnBpZWNld2lzZSc7XG4gIFBpZWNld2lzZU1vZGVsLmRlZmF1bHRPcHRpb24gPSBpbmhlcml0RGVmYXVsdE9wdGlvbihWaXN1YWxNYXBNb2RlbC5kZWZhdWx0T3B0aW9uLCB7XG4gICAgc2VsZWN0ZWQ6IG51bGwsXG4gICAgbWluT3BlbjogZmFsc2UsXG4gICAgbWF4T3BlbjogZmFsc2UsXG4gICAgYWxpZ246ICdhdXRvJyxcbiAgICBpdGVtV2lkdGg6IDIwLFxuICAgIGl0ZW1IZWlnaHQ6IDE0LFxuICAgIGl0ZW1TeW1ib2w6ICdyb3VuZFJlY3QnLFxuICAgIHBpZWNlczogbnVsbCxcbiAgICBjYXRlZ29yaWVzOiBudWxsLFxuICAgIHNwbGl0TnVtYmVyOiA1LFxuICAgIHNlbGVjdGVkTW9kZTogJ211bHRpcGxlJyxcbiAgICBpdGVtR2FwOiAxMCxcbiAgICBob3Zlckxpbms6IHRydWUgLy8gRW5hYmxlIGhvdmVyIGhpZ2hsaWdodC5cbiAgfSk7XG4gIHJldHVybiBQaWVjZXdpc2VNb2RlbDtcbn0oVmlzdWFsTWFwTW9kZWwpO1xuO1xuLyoqXHJcbiAqIEtleSBpcyB0aGlzLl9tb2RlXHJcbiAqIEB0eXBlIHtPYmplY3R9XHJcbiAqIEB0aGlzIHttb2R1bGU6ZWNoYXJ0cy9jb21wb25lbnQvdml1c2FsTWFwL1BpZWNld2lzZU1vZGV9XHJcbiAqL1xudmFyIHJlc2V0TWV0aG9kcyA9IHtcbiAgc3BsaXROdW1iZXI6IGZ1bmN0aW9uIChvdXRQaWVjZUxpc3QpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHZhciBwcmVjaXNpb24gPSBNYXRoLm1pbih0aGlzT3B0aW9uLnByZWNpc2lvbiwgMjApO1xuICAgIHZhciBkYXRhRXh0ZW50ID0gdGhpcy5nZXRFeHRlbnQoKTtcbiAgICB2YXIgc3BsaXROdW1iZXIgPSB0aGlzT3B0aW9uLnNwbGl0TnVtYmVyO1xuICAgIHNwbGl0TnVtYmVyID0gTWF0aC5tYXgocGFyc2VJbnQoc3BsaXROdW1iZXIsIDEwKSwgMSk7XG4gICAgdGhpc09wdGlvbi5zcGxpdE51bWJlciA9IHNwbGl0TnVtYmVyO1xuICAgIHZhciBzcGxpdFN0ZXAgPSAoZGF0YUV4dGVudFsxXSAtIGRhdGFFeHRlbnRbMF0pIC8gc3BsaXROdW1iZXI7XG4gICAgLy8gUHJlY2lzaW9uIGF1dG8tYWRhcHRpb25cbiAgICB3aGlsZSAoK3NwbGl0U3RlcC50b0ZpeGVkKHByZWNpc2lvbikgIT09IHNwbGl0U3RlcCAmJiBwcmVjaXNpb24gPCA1KSB7XG4gICAgICBwcmVjaXNpb24rKztcbiAgICB9XG4gICAgdGhpc09wdGlvbi5wcmVjaXNpb24gPSBwcmVjaXNpb247XG4gICAgc3BsaXRTdGVwID0gK3NwbGl0U3RlcC50b0ZpeGVkKHByZWNpc2lvbik7XG4gICAgaWYgKHRoaXNPcHRpb24ubWluT3Blbikge1xuICAgICAgb3V0UGllY2VMaXN0LnB1c2goe1xuICAgICAgICBpbnRlcnZhbDogWy1JbmZpbml0eSwgZGF0YUV4dGVudFswXV0sXG4gICAgICAgIGNsb3NlOiBbMCwgMF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIGN1cnIgPSBkYXRhRXh0ZW50WzBdOyBpbmRleCA8IHNwbGl0TnVtYmVyOyBjdXJyICs9IHNwbGl0U3RlcCwgaW5kZXgrKykge1xuICAgICAgdmFyIG1heCA9IGluZGV4ID09PSBzcGxpdE51bWJlciAtIDEgPyBkYXRhRXh0ZW50WzFdIDogY3VyciArIHNwbGl0U3RlcDtcbiAgICAgIG91dFBpZWNlTGlzdC5wdXNoKHtcbiAgICAgICAgaW50ZXJ2YWw6IFtjdXJyLCBtYXhdLFxuICAgICAgICBjbG9zZTogWzEsIDFdXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXNPcHRpb24ubWF4T3Blbikge1xuICAgICAgb3V0UGllY2VMaXN0LnB1c2goe1xuICAgICAgICBpbnRlcnZhbDogW2RhdGFFeHRlbnRbMV0sIEluZmluaXR5XSxcbiAgICAgICAgY2xvc2U6IFswLCAwXVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJlZm9ybUludGVydmFscyhvdXRQaWVjZUxpc3QpO1xuICAgIHpyVXRpbC5lYWNoKG91dFBpZWNlTGlzdCwgZnVuY3Rpb24gKHBpZWNlLCBpbmRleCkge1xuICAgICAgcGllY2UuaW5kZXggPSBpbmRleDtcbiAgICAgIHBpZWNlLnRleHQgPSB0aGlzLmZvcm1hdFZhbHVlVGV4dChwaWVjZS5pbnRlcnZhbCk7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG4gIGNhdGVnb3JpZXM6IGZ1bmN0aW9uIChvdXRQaWVjZUxpc3QpIHtcbiAgICB2YXIgdGhpc09wdGlvbiA9IHRoaXMub3B0aW9uO1xuICAgIHpyVXRpbC5lYWNoKHRoaXNPcHRpb24uY2F0ZWdvcmllcywgZnVuY3Rpb24gKGNhdGUpIHtcbiAgICAgIC8vIEZJWE1FIGNhdGVnb3J55qih5byP5Lmf5L2/55SocGllY2VMaXN077yM5L2G5ZyodmlzdWFsTWFwcGluZ+S4reS4jeaYr+S9v+eUqHBpZWNlTGlzdOOAglxuICAgICAgLy8g5piv5ZCm5pS55LiA6Ie044CCXG4gICAgICBvdXRQaWVjZUxpc3QucHVzaCh7XG4gICAgICAgIHRleHQ6IHRoaXMuZm9ybWF0VmFsdWVUZXh0KGNhdGUsIHRydWUpLFxuICAgICAgICB2YWx1ZTogY2F0ZVxuICAgICAgfSk7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gU2VlIFwiT3JkZXIgUnVsZVwiLlxuICAgIG5vcm1hbGl6ZVJldmVyc2UodGhpc09wdGlvbiwgb3V0UGllY2VMaXN0KTtcbiAgfSxcbiAgcGllY2VzOiBmdW5jdGlvbiAob3V0UGllY2VMaXN0KSB7XG4gICAgdmFyIHRoaXNPcHRpb24gPSB0aGlzLm9wdGlvbjtcbiAgICB6clV0aWwuZWFjaCh0aGlzT3B0aW9uLnBpZWNlcywgZnVuY3Rpb24gKHBpZWNlTGlzdEl0ZW0sIGluZGV4KSB7XG4gICAgICBpZiAoIXpyVXRpbC5pc09iamVjdChwaWVjZUxpc3RJdGVtKSkge1xuICAgICAgICBwaWVjZUxpc3RJdGVtID0ge1xuICAgICAgICAgIHZhbHVlOiBwaWVjZUxpc3RJdGVtXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgdGV4dDogJycsXG4gICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGlmIChwaWVjZUxpc3RJdGVtLmxhYmVsICE9IG51bGwpIHtcbiAgICAgICAgaXRlbS50ZXh0ID0gcGllY2VMaXN0SXRlbS5sYWJlbDtcbiAgICAgIH1cbiAgICAgIGlmIChwaWVjZUxpc3RJdGVtLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGl0ZW0udmFsdWUgPSBwaWVjZUxpc3RJdGVtLnZhbHVlO1xuICAgICAgICBpdGVtLmludGVydmFsID0gW3ZhbHVlLCB2YWx1ZV07XG4gICAgICAgIGl0ZW0uY2xvc2UgPSBbMSwgMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgbWluYCBgbWF4YCBpcyBsZWdhY3kgb3B0aW9uLlxuICAgICAgICAvLyBgbHRgIGBndGAgYGx0ZWAgYGd0ZWAgaXMgcmVjb21tZW5kZWQuXG4gICAgICAgIHZhciBpbnRlcnZhbCA9IGl0ZW0uaW50ZXJ2YWwgPSBbXTtcbiAgICAgICAgdmFyIGNsb3NlXzEgPSBpdGVtLmNsb3NlID0gWzAsIDBdO1xuICAgICAgICB2YXIgY2xvc2VMaXN0ID0gWzEsIDAsIDFdO1xuICAgICAgICB2YXIgaW5maW5pdHlMaXN0ID0gWy1JbmZpbml0eSwgSW5maW5pdHldO1xuICAgICAgICB2YXIgdXNlTWluTWF4ID0gW107XG4gICAgICAgIGZvciAodmFyIGxnID0gMDsgbGcgPCAyOyBsZysrKSB7XG4gICAgICAgICAgdmFyIG5hbWVzID0gW1snZ3RlJywgJ2d0JywgJ21pbiddLCBbJ2x0ZScsICdsdCcsICdtYXgnXV1bbGddO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMyAmJiBpbnRlcnZhbFtsZ10gPT0gbnVsbDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcnZhbFtsZ10gPSBwaWVjZUxpc3RJdGVtW25hbWVzW2ldXTtcbiAgICAgICAgICAgIGNsb3NlXzFbbGddID0gY2xvc2VMaXN0W2ldO1xuICAgICAgICAgICAgdXNlTWluTWF4W2xnXSA9IGkgPT09IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGludGVydmFsW2xnXSA9PSBudWxsICYmIChpbnRlcnZhbFtsZ10gPSBpbmZpbml0eUxpc3RbbGddKTtcbiAgICAgICAgfVxuICAgICAgICB1c2VNaW5NYXhbMF0gJiYgaW50ZXJ2YWxbMV0gPT09IEluZmluaXR5ICYmIChjbG9zZV8xWzBdID0gMCk7XG4gICAgICAgIHVzZU1pbk1heFsxXSAmJiBpbnRlcnZhbFswXSA9PT0gLUluZmluaXR5ICYmIChjbG9zZV8xWzFdID0gMCk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGludGVydmFsWzBdID4gaW50ZXJ2YWxbMV0pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUGllY2UgJyArIGluZGV4ICsgJ2lzIGlsbGVnYWw6ICcgKyBpbnRlcnZhbCArICcgbG93ZXIgYm91bmQgc2hvdWxkIG5vdCBncmVhdGVyIHRoZW4gdXBwcGVyIGJvdW5kLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJ2YWxbMF0gPT09IGludGVydmFsWzFdICYmIGNsb3NlXzFbMF0gJiYgY2xvc2VfMVsxXSkge1xuICAgICAgICAgIC8vIENvbnNpZGVyOiBbe21pbjogNSwgbWF4OiA1LCB2aXN1YWw6IHsuLi59fSwge21pbjogMCwgbWF4OiA1fV0sXG4gICAgICAgICAgLy8gd2UgdXNlIHZhbHVlIHRvIGxpZnQgdGhlIHByaW9yaXR5IHdoZW4gbWluID09PSBtYXhcbiAgICAgICAgICBpdGVtLnZhbHVlID0gaW50ZXJ2YWxbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGl0ZW0udmlzdWFsID0gVmlzdWFsTWFwcGluZy5yZXRyaWV2ZVZpc3VhbHMocGllY2VMaXN0SXRlbSk7XG4gICAgICBvdXRQaWVjZUxpc3QucHVzaChpdGVtKTtcbiAgICB9LCB0aGlzKTtcbiAgICAvLyBTZWUgXCJPcmRlciBSdWxlXCIuXG4gICAgbm9ybWFsaXplUmV2ZXJzZSh0aGlzT3B0aW9uLCBvdXRQaWVjZUxpc3QpO1xuICAgIC8vIE9ubHkgcGllY2VzXG4gICAgcmVmb3JtSW50ZXJ2YWxzKG91dFBpZWNlTGlzdCk7XG4gICAgenJVdGlsLmVhY2gob3V0UGllY2VMaXN0LCBmdW5jdGlvbiAocGllY2UpIHtcbiAgICAgIHZhciBjbG9zZSA9IHBpZWNlLmNsb3NlO1xuICAgICAgdmFyIGVkZ2VTeW1ib2xzID0gW1snPCcsICfiiaQnXVtjbG9zZVsxXV0sIFsnPicsICfiiaUnXVtjbG9zZVswXV1dO1xuICAgICAgcGllY2UudGV4dCA9IHBpZWNlLnRleHQgfHwgdGhpcy5mb3JtYXRWYWx1ZVRleHQocGllY2UudmFsdWUgIT0gbnVsbCA/IHBpZWNlLnZhbHVlIDogcGllY2UuaW50ZXJ2YWwsIGZhbHNlLCBlZGdlU3ltYm9scyk7XG4gICAgfSwgdGhpcyk7XG4gIH1cbn07XG5mdW5jdGlvbiBub3JtYWxpemVSZXZlcnNlKHRoaXNPcHRpb24sIHBpZWNlTGlzdCkge1xuICB2YXIgaW52ZXJzZSA9IHRoaXNPcHRpb24uaW52ZXJzZTtcbiAgaWYgKHRoaXNPcHRpb24ub3JpZW50ID09PSAndmVydGljYWwnID8gIWludmVyc2UgOiBpbnZlcnNlKSB7XG4gICAgcGllY2VMaXN0LnJldmVyc2UoKTtcbiAgfVxufVxuZXhwb3J0IGRlZmF1bHQgUGllY2V3aXNlTW9kZWw7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgeyBfX2V4dGVuZHMgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCAqIGFzIHpyVXRpbCBmcm9tICd6cmVuZGVyL2xpYi9jb3JlL3V0aWwuanMnO1xuaW1wb3J0IFZpc3VhbE1hcFZpZXcgZnJvbSAnLi9WaXN1YWxNYXBWaWV3LmpzJztcbmltcG9ydCAqIGFzIGdyYXBoaWMgZnJvbSAnLi4vLi4vdXRpbC9ncmFwaGljLmpzJztcbmltcG9ydCB7IGNyZWF0ZVN5bWJvbCB9IGZyb20gJy4uLy4uL3V0aWwvc3ltYm9sLmpzJztcbmltcG9ydCAqIGFzIGxheW91dCBmcm9tICcuLi8uLi91dGlsL2xheW91dC5qcyc7XG5pbXBvcnQgKiBhcyBoZWxwZXIgZnJvbSAnLi9oZWxwZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlVGV4dFN0eWxlIH0gZnJvbSAnLi4vLi4vbGFiZWwvbGFiZWxTdHlsZS5qcyc7XG52YXIgUGllY2V3aXNlVmlzdWFsTWFwVmlldyA9IC8qKiBAY2xhc3MgKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LCBfc3VwZXIpO1xuICBmdW5jdGlvbiBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3KCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIF90aGlzLnR5cGUgPSBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnR5cGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIFBpZWNld2lzZVZpc3VhbE1hcFZpZXcucHJvdG90eXBlLmRvUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGlzR3JvdXAgPSB0aGlzLmdyb3VwO1xuICAgIHRoaXNHcm91cC5yZW1vdmVBbGwoKTtcbiAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSB0aGlzLnZpc3VhbE1hcE1vZGVsO1xuICAgIHZhciB0ZXh0R2FwID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCd0ZXh0R2FwJyk7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdmlzdWFsTWFwTW9kZWwudGV4dFN0eWxlTW9kZWw7XG4gICAgdmFyIHRleHRGb250ID0gdGV4dFN0eWxlTW9kZWwuZ2V0Rm9udCgpO1xuICAgIHZhciB0ZXh0RmlsbCA9IHRleHRTdHlsZU1vZGVsLmdldFRleHRDb2xvcigpO1xuICAgIHZhciBpdGVtQWxpZ24gPSB0aGlzLl9nZXRJdGVtQWxpZ24oKTtcbiAgICB2YXIgaXRlbVNpemUgPSB2aXN1YWxNYXBNb2RlbC5pdGVtU2l6ZTtcbiAgICB2YXIgdmlld0RhdGEgPSB0aGlzLl9nZXRWaWV3RGF0YSgpO1xuICAgIHZhciBlbmRzVGV4dCA9IHZpZXdEYXRhLmVuZHNUZXh0O1xuICAgIHZhciBzaG93TGFiZWwgPSB6clV0aWwucmV0cmlldmUodmlzdWFsTWFwTW9kZWwuZ2V0KCdzaG93TGFiZWwnLCB0cnVlKSwgIWVuZHNUZXh0KTtcbiAgICB2YXIgc2lsZW50ID0gIXZpc3VhbE1hcE1vZGVsLmdldCgnc2VsZWN0ZWRNb2RlJyk7XG4gICAgZW5kc1RleHQgJiYgdGhpcy5fcmVuZGVyRW5kc1RleHQodGhpc0dyb3VwLCBlbmRzVGV4dFswXSwgaXRlbVNpemUsIHNob3dMYWJlbCwgaXRlbUFsaWduKTtcbiAgICB6clV0aWwuZWFjaCh2aWV3RGF0YS52aWV3UGllY2VMaXN0LCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHBpZWNlID0gaXRlbS5waWVjZTtcbiAgICAgIHZhciBpdGVtR3JvdXAgPSBuZXcgZ3JhcGhpYy5Hcm91cCgpO1xuICAgICAgaXRlbUdyb3VwLm9uY2xpY2sgPSB6clV0aWwuYmluZCh0aGlzLl9vbkl0ZW1DbGljaywgdGhpcywgcGllY2UpO1xuICAgICAgdGhpcy5fZW5hYmxlSG92ZXJMaW5rKGl0ZW1Hcm91cCwgaXRlbS5pbmRleEluTW9kZWxQaWVjZUxpc3QpO1xuICAgICAgLy8gVE9ETyBDYXRlZ29yeVxuICAgICAgdmFyIHJlcHJlc2VudFZhbHVlID0gdmlzdWFsTWFwTW9kZWwuZ2V0UmVwcmVzZW50VmFsdWUocGllY2UpO1xuICAgICAgdGhpcy5fY3JlYXRlSXRlbVN5bWJvbChpdGVtR3JvdXAsIHJlcHJlc2VudFZhbHVlLCBbMCwgMCwgaXRlbVNpemVbMF0sIGl0ZW1TaXplWzFdXSwgc2lsZW50KTtcbiAgICAgIGlmIChzaG93TGFiZWwpIHtcbiAgICAgICAgdmFyIHZpc3VhbFN0YXRlID0gdGhpcy52aXN1YWxNYXBNb2RlbC5nZXRWYWx1ZVN0YXRlKHJlcHJlc2VudFZhbHVlKTtcbiAgICAgICAgaXRlbUdyb3VwLmFkZChuZXcgZ3JhcGhpYy5UZXh0KHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgeDogaXRlbUFsaWduID09PSAncmlnaHQnID8gLXRleHRHYXAgOiBpdGVtU2l6ZVswXSArIHRleHRHYXAsXG4gICAgICAgICAgICB5OiBpdGVtU2l6ZVsxXSAvIDIsXG4gICAgICAgICAgICB0ZXh0OiBwaWVjZS50ZXh0LFxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgICAgICBhbGlnbjogaXRlbUFsaWduLFxuICAgICAgICAgICAgZm9udDogdGV4dEZvbnQsXG4gICAgICAgICAgICBmaWxsOiB0ZXh0RmlsbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IHZpc3VhbFN0YXRlID09PSAnb3V0T2ZSYW5nZScgPyAwLjUgOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzaWxlbnQ6IHNpbGVudFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0aGlzR3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gICAgfSwgdGhpcyk7XG4gICAgZW5kc1RleHQgJiYgdGhpcy5fcmVuZGVyRW5kc1RleHQodGhpc0dyb3VwLCBlbmRzVGV4dFsxXSwgaXRlbVNpemUsIHNob3dMYWJlbCwgaXRlbUFsaWduKTtcbiAgICBsYXlvdXQuYm94KHZpc3VhbE1hcE1vZGVsLmdldCgnb3JpZW50JyksIHRoaXNHcm91cCwgdmlzdWFsTWFwTW9kZWwuZ2V0KCdpdGVtR2FwJykpO1xuICAgIHRoaXMucmVuZGVyQmFja2dyb3VuZCh0aGlzR3JvdXApO1xuICAgIHRoaXMucG9zaXRpb25Hcm91cCh0aGlzR3JvdXApO1xuICB9O1xuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fZW5hYmxlSG92ZXJMaW5rID0gZnVuY3Rpb24gKGl0ZW1Hcm91cCwgcGllY2VJbmRleCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgaXRlbUdyb3VwLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gb25Ib3ZlckxpbmsoJ2hpZ2hsaWdodCcpO1xuICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbkhvdmVyTGluaygnZG93bnBsYXknKTtcbiAgICB9KTtcbiAgICB2YXIgb25Ib3ZlckxpbmsgPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICB2YXIgdmlzdWFsTWFwTW9kZWwgPSBfdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICAgIC8vIFRPRE86IFRZUEUgTW9yZSBkZXRhaWxlZCBhY3Rpb24gdHlwZXNcbiAgICAgIHZpc3VhbE1hcE1vZGVsLm9wdGlvbi5ob3ZlckxpbmsgJiYgX3RoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgICAgdHlwZTogbWV0aG9kLFxuICAgICAgICBiYXRjaDogaGVscGVyLm1ha2VIaWdoRG93bkJhdGNoKHZpc3VhbE1hcE1vZGVsLmZpbmRUYXJnZXREYXRhSW5kaWNlcyhwaWVjZUluZGV4KSwgdmlzdWFsTWFwTW9kZWwpXG4gICAgICB9KTtcbiAgICB9O1xuICB9O1xuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnByb3RvdHlwZS5fZ2V0SXRlbUFsaWduID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIG1vZGVsT3B0aW9uID0gdmlzdWFsTWFwTW9kZWwub3B0aW9uO1xuICAgIGlmIChtb2RlbE9wdGlvbi5vcmllbnQgPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiBoZWxwZXIuZ2V0SXRlbUFsaWduKHZpc3VhbE1hcE1vZGVsLCB0aGlzLmFwaSwgdmlzdWFsTWFwTW9kZWwuaXRlbVNpemUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3Jpem9udGFsLCBtb3N0IGNhc2UgbGVmdCB1bmxlc3Mgc3BlY2lmeWluZyByaWdodC5cbiAgICAgIHZhciBhbGlnbiA9IG1vZGVsT3B0aW9uLmFsaWduO1xuICAgICAgaWYgKCFhbGlnbiB8fCBhbGlnbiA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIGFsaWduID0gJ2xlZnQnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH1cbiAgfTtcbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuX3JlbmRlckVuZHNUZXh0ID0gZnVuY3Rpb24gKGdyb3VwLCB0ZXh0LCBpdGVtU2l6ZSwgc2hvd0xhYmVsLCBpdGVtQWxpZ24pIHtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGl0ZW1Hcm91cCA9IG5ldyBncmFwaGljLkdyb3VwKCk7XG4gICAgdmFyIHRleHRTdHlsZU1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbC50ZXh0U3R5bGVNb2RlbDtcbiAgICBpdGVtR3JvdXAuYWRkKG5ldyBncmFwaGljLlRleHQoe1xuICAgICAgc3R5bGU6IGNyZWF0ZVRleHRTdHlsZSh0ZXh0U3R5bGVNb2RlbCwge1xuICAgICAgICB4OiBzaG93TGFiZWwgPyBpdGVtQWxpZ24gPT09ICdyaWdodCcgPyBpdGVtU2l6ZVswXSA6IDAgOiBpdGVtU2l6ZVswXSAvIDIsXG4gICAgICAgIHk6IGl0ZW1TaXplWzFdIC8gMixcbiAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXG4gICAgICAgIGFsaWduOiBzaG93TGFiZWwgPyBpdGVtQWxpZ24gOiAnY2VudGVyJyxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfSlcbiAgICB9KSk7XG4gICAgZ3JvdXAuYWRkKGl0ZW1Hcm91cCk7XG4gIH07XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7T2JqZWN0fSB7cGVpY2VMaXN0LCBlbmRzVGV4dH0gVGhlIG9yZGVyIGlzIHRoZSBzYW1lIGFzIHNjcmVlbiBwaXhlbCBvcmRlci5cclxuICAgKi9cbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuX2dldFZpZXdEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aXN1YWxNYXBNb2RlbCA9IHRoaXMudmlzdWFsTWFwTW9kZWw7XG4gICAgdmFyIHZpZXdQaWVjZUxpc3QgPSB6clV0aWwubWFwKHZpc3VhbE1hcE1vZGVsLmdldFBpZWNlTGlzdCgpLCBmdW5jdGlvbiAocGllY2UsIGluZGV4KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaWVjZTogcGllY2UsXG4gICAgICAgIGluZGV4SW5Nb2RlbFBpZWNlTGlzdDogaW5kZXhcbiAgICAgIH07XG4gICAgfSk7XG4gICAgdmFyIGVuZHNUZXh0ID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCd0ZXh0Jyk7XG4gICAgLy8gQ29uc2lkZXIgb3JpZW50IGFuZCBpbnZlcnNlLlxuICAgIHZhciBvcmllbnQgPSB2aXN1YWxNYXBNb2RlbC5nZXQoJ29yaWVudCcpO1xuICAgIHZhciBpbnZlcnNlID0gdmlzdWFsTWFwTW9kZWwuZ2V0KCdpbnZlcnNlJyk7XG4gICAgLy8gT3JkZXIgb2YgbW9kZWwgcGllY2VMaXN0IGlzIGFsd2F5cyBbbG93LCAuLi4sIGhpZ2hdXG4gICAgaWYgKG9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gaW52ZXJzZSA6ICFpbnZlcnNlKSB7XG4gICAgICB2aWV3UGllY2VMaXN0LnJldmVyc2UoKTtcbiAgICB9XG4gICAgLy8gT3JpZ2luIG9yZGVyIG9mIGVuZHNUZXh0IGlzIFtoaWdoLCBsb3ddXG4gICAgZWxzZSBpZiAoZW5kc1RleHQpIHtcbiAgICAgIGVuZHNUZXh0ID0gZW5kc1RleHQuc2xpY2UoKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB2aWV3UGllY2VMaXN0OiB2aWV3UGllY2VMaXN0LFxuICAgICAgZW5kc1RleHQ6IGVuZHNUZXh0XG4gICAgfTtcbiAgfTtcbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuX2NyZWF0ZUl0ZW1TeW1ib2wgPSBmdW5jdGlvbiAoZ3JvdXAsIHJlcHJlc2VudFZhbHVlLCBzaGFwZVBhcmFtLCBzaWxlbnQpIHtcbiAgICB2YXIgaXRlbVN5bWJvbCA9IGNyZWF0ZVN5bWJvbChcbiAgICAvLyBzeW1ib2wgd2lsbCBiZSBzdHJpbmdcbiAgICB0aGlzLmdldENvbnRyb2xsZXJWaXN1YWwocmVwcmVzZW50VmFsdWUsICdzeW1ib2wnKSwgc2hhcGVQYXJhbVswXSwgc2hhcGVQYXJhbVsxXSwgc2hhcGVQYXJhbVsyXSwgc2hhcGVQYXJhbVszXSxcbiAgICAvLyBjb2xvciB3aWxsIGJlIHN0cmluZ1xuICAgIHRoaXMuZ2V0Q29udHJvbGxlclZpc3VhbChyZXByZXNlbnRWYWx1ZSwgJ2NvbG9yJykpO1xuICAgIGl0ZW1TeW1ib2wuc2lsZW50ID0gc2lsZW50O1xuICAgIGdyb3VwLmFkZChpdGVtU3ltYm9sKTtcbiAgfTtcbiAgUGllY2V3aXNlVmlzdWFsTWFwVmlldy5wcm90b3R5cGUuX29uSXRlbUNsaWNrID0gZnVuY3Rpb24gKHBpZWNlKSB7XG4gICAgdmFyIHZpc3VhbE1hcE1vZGVsID0gdGhpcy52aXN1YWxNYXBNb2RlbDtcbiAgICB2YXIgb3B0aW9uID0gdmlzdWFsTWFwTW9kZWwub3B0aW9uO1xuICAgIHZhciBzZWxlY3RlZE1vZGUgPSBvcHRpb24uc2VsZWN0ZWRNb2RlO1xuICAgIGlmICghc2VsZWN0ZWRNb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBzZWxlY3RlZCA9IHpyVXRpbC5jbG9uZShvcHRpb24uc2VsZWN0ZWQpO1xuICAgIHZhciBuZXdLZXkgPSB2aXN1YWxNYXBNb2RlbC5nZXRTZWxlY3RlZE1hcEtleShwaWVjZSk7XG4gICAgaWYgKHNlbGVjdGVkTW9kZSA9PT0gJ3NpbmdsZScgfHwgc2VsZWN0ZWRNb2RlID09PSB0cnVlKSB7XG4gICAgICBzZWxlY3RlZFtuZXdLZXldID0gdHJ1ZTtcbiAgICAgIHpyVXRpbC5lYWNoKHNlbGVjdGVkLCBmdW5jdGlvbiAobywga2V5KSB7XG4gICAgICAgIHNlbGVjdGVkW2tleV0gPSBrZXkgPT09IG5ld0tleTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxlY3RlZFtuZXdLZXldID0gIXNlbGVjdGVkW25ld0tleV07XG4gICAgfVxuICAgIHRoaXMuYXBpLmRpc3BhdGNoQWN0aW9uKHtcbiAgICAgIHR5cGU6ICdzZWxlY3REYXRhUmFuZ2UnLFxuICAgICAgZnJvbTogdGhpcy51aWQsXG4gICAgICB2aXN1YWxNYXBJZDogdGhpcy52aXN1YWxNYXBNb2RlbC5pZCxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFxuICAgIH0pO1xuICB9O1xuICBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3LnR5cGUgPSAndmlzdWFsTWFwLnBpZWNld2lzZSc7XG4gIHJldHVybiBQaWVjZXdpc2VWaXN1YWxNYXBWaWV3O1xufShWaXN1YWxNYXBWaWV3KTtcbmV4cG9ydCBkZWZhdWx0IFBpZWNld2lzZVZpc3VhbE1hcFZpZXc7IiwiXG4vKlxuKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuKiBkaXN0cmlidXRlZCB3aXRoIHRoaXMgd29yayBmb3IgYWRkaXRpb25hbCBpbmZvcm1hdGlvblxuKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiogXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlXG4qIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbipcbiogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbipcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuKiBzb2Z0d2FyZSBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhblxuKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiogc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZCBsaW1pdGF0aW9uc1xuKiB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cblxuLyoqXG4gKiBBVVRPLUdFTkVSQVRFRCBGSUxFLiBETyBOT1QgTU9ESUZZLlxuICovXG5cbi8qXHJcbiogTGljZW5zZWQgdG8gdGhlIEFwYWNoZSBTb2Z0d2FyZSBGb3VuZGF0aW9uIChBU0YpIHVuZGVyIG9uZVxyXG4qIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxyXG4qIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXHJcbiogcmVnYXJkaW5nIGNvcHlyaWdodCBvd25lcnNoaXAuICBUaGUgQVNGIGxpY2Vuc2VzIHRoaXMgZmlsZVxyXG4qIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcclxuKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcclxuKiB3aXRoIHRoZSBMaWNlbnNlLiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcbipcclxuKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG4qXHJcbiogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxyXG4qIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXHJcbiogXCJBUyBJU1wiIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcclxuKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXHJcbiogdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiovXG5pbXBvcnQgUGllY2V3aXNlTW9kZWwgZnJvbSAnLi9QaWVjZXdpc2VNb2RlbC5qcyc7XG5pbXBvcnQgUGllY2V3aXNlVmlldyBmcm9tICcuL1BpZWNld2lzZVZpZXcuanMnO1xuaW1wb3J0IGluc3RhbGxDb21tb24gZnJvbSAnLi9pbnN0YWxsQ29tbW9uLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpbnN0YWxsKHJlZ2lzdGVycykge1xuICByZWdpc3RlcnMucmVnaXN0ZXJDb21wb25lbnRNb2RlbChQaWVjZXdpc2VNb2RlbCk7XG4gIHJlZ2lzdGVycy5yZWdpc3RlckNvbXBvbmVudFZpZXcoUGllY2V3aXNlVmlldyk7XG4gIGluc3RhbGxDb21tb24ocmVnaXN0ZXJzKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///68781\n")}}]);